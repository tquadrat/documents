%\RequirePackage{lmodern}
\documentclass[11pt,a4paper,titlepage, parskip=half, headsepline, footsepline, cleardoubleplain]{scrbook}
%\usepackage{DejaVuSansMono}
\usepackage{dejavu}
\usepackage[T1]{fontenc}
\usepackage{scrhack}
\usepackage{graphicx} 
\usepackage[manualmark]{scrlayer-scrpage}
\usepackage[utf8]{inputenc}
\usepackage{tocbasic}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{eurosym}
\usepackage{ragged2e}
\usepackage{textcomp}
\usepackage{framed}
\usepackage{ltxtable}
\usepackage{filecontents}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,gray]{xcolor}
\usepackage{listings}
\usepackage[inline]{enumitem}
\usepackage{varioref}
\usepackage[iso,english]{isodate}
\usepackage{makecell}
\usepackage[english]{babel}
\usepackage[babel]{csquotes}
\usepackage[style=numeric,urldate=iso8601,backend=biber]{biblatex}
\usepackage{nameref}
\usepackage[colorlinks=true]{hyperref}

\addbibresource{JavaCodingConventions.bib}

\automark[section]{chapter}
\lehead*[]{\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}~~\headmark}
\rohead*[\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}]{\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}}

\lstset{
language=Java,
%morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield},
morekeywords={var,yield},
backgroundcolor=\color[gray]{.9},
frame=single,
framerule=0.2pt,
basicstyle=\ttfamily\footnotesize,
commentstyle=\color[gray]{.2}\itshape,
keywordstyle=\color[gray]{.4}\bfseries,
identifierstyle=\bfseries,
stringstyle=\itshape,
xleftmargin=.2cm,
xrightmargin=.2cm,
breaklines=true,
breakatwhitespace=true,
inputencoding=utf8,
extendedchars=true,
literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
  {©}{{\copyright}}1
  {…}{{\dots }}2
  {–}{{--}}1
}

\colorlet{shadecolor}{gray!10}

%---* New Commands *-----------------------------------------------------------
\newcommand*{\tqfullref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”}}
\newcommand*{\tqfullvref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”} on page \pageref{#1}}
\newcommand*{\tqref}[1]{\hyperref[{#1}]{\ref*{#1}}}
\newcommand*{\tqvref}[1]{\hyperref[{#1}]{\ref*{#1}} on page \pageref{#1}}

\begin{document}
\isodate
\titlehead{\includegraphics[height=4cm]{Logo_gross}}
\author{Thomas Thrien\\(thomas.thrien@tquadrat.org)}
\title{Extended Coding Conventions for Java}
\subtitle{Coding and Formatting Rules, Recommendations and Best Practices}
\date{\today}
\maketitle
\tableofcontents

\chapter{Introduction}

\begin{quotation}
“Everybody can write code that can be read by a computer,
but only good developers will write code that can be read by humans.”
\autocite{Fowler:Refactoring}
\end{quotation}

From a magazine dealing with software development tools, I found the following statement:

\begin{quotation}
“If you compare software development with the Apollo program, most programmers would be very successful bringing man to the moon, but never will get them back alive because of their common incapability to deliver software that can be maintained over a longer period of time with reasonable costs.”
\end{quotation}

Coding conventions are primarily rules that should help making code better to maintain. Usually, this starts with making it more readable. Obviously, “readability” is a relative term, depending from one's habit. So some people are more familiar with the Kernighan-Ritchie (K\&R) style

\begin{lstlisting}
public void method (){
    if (flag) {
        …
    }
}
\end{lstlisting}

as it is also shown in the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS}, other prefer to have the curly braces on a line of their own (sometimes referred to as GNU or BSD style\footnote{All, BSD, GNU and K\&R styles, will define more than just how to place the curly braces. In addition, all three are originally code conventions for programming in C and/or C++ that cannot applied to Java without modifications. See chapter \tqfullvref{sec:OtherProgrammingLanguages} on this topic.}):

\begin{lstlisting}
public void method()
{
    if( flag )
    {
    	…
    }
}
\end{lstlisting}

Both styles will work, but they look different. So as a lot of other rules from a code conventions document, too, this is a matter of taste (but refer to chapter \tqfullvref{sec:IndentationStyle}).

Nevertheless, the main purpose of those rules is to ensure that all source code looks familiar to all members of the team. As a side effect, such a look identifies source code as written by the team, as its trademark.

But there are more practical reasons to enforce these rules on the source: they make it easier …
\begin{itemize}[nosep]
\item … to understand the code
\item … to navigate inside the code
\item … to detect bugs
\item … to fix these bugs
\item … and to amend and enhance the code.
\end{itemize}

It can make it also easier to use automated tools on the source code.

All this is important because most of the lifetime cost of a piece of software is going into maintenance – some sources say 80 to 90\% – and nearly no source is maintained by its original author or even a single programmer for its whole lifetime.

The base of the coding conventions presented in this document are the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS} we have already mentioned above, but with some changes and enhancements that seemed necessary or at least useful to me.

\section{About this Document}
The document itself consists of four major parts: first we want to talk about proper formatting of the source files, next it covers the naming of the program elements before I discuss some guidelines for writing proper comments. The final chapter before the appendices will cover general coding rules.

The code samples in this document should underline some particular aspect or demonstrate a single rule or recommendation; to stay focused on that purpose, and to keep the samples at a reasonable length, they may often hurt other rules or ignore other recommendations. For instance, in most cases, methods are lacking the required comments, or the names are not really meaningful. In addition, some rules or recommendations are first used in the samples \textit{after} being introduced.

For source code samples that obey all rules and follow all recommendations, refer to chapter \tqfullvref{sec:Examples}.

All rules and recommendations assume that at least Java~17\footnote{see the language specification in \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION}} is used to write the code. I used that version also for the samples.

If you have questions or comments regarding this document, please send me an email to \href{mailto:thomas.thrien@tquadrat.org}{thomas.thrien@tquadrat.org}. Or leave it at \url{https://tquadrat.github.io/}.

\section{History and Implementation}
I compiled a first version of this document around the year 2000, based on the way I wrote Java code at that time. I was asked to do so for a team of developers that had been new to Java (and to programming …).

Later versions were created for other developer teams, and several software products had been created successfully following these coding conventions – proving my initial statement that coding conventions help to create maintainable software. Some of the code written by the various teams is still running, after 20~years now, another code is live since 12~years now.

I wrote some libraries that supports some of the rules and recommendations, in particalur those mentioned in chapter \tqfullref{sec:CodingRules}, starting on page~\pageref{sec:CodingRules}. If interested, have a look to \autocite{TQUADRAT_ORG}.

\section{Other Programming Languages}\label{sec:OtherProgrammingLanguages}
Of course coding conventions like those described with this document are not only useful for Java programs, but for code in any other programming language also.\footnote{Even for descriptive languages like XML and HTML they make sense, also for documents written in \TeX/\LaTeX.} But each language has its unique features and specialities, meaning that coding conventions written for one programming language do not necessarily match the requirements for another.

Obviously there are some common rules that are valid for every programming language\footnote{E.g. the request to use meaningful names.}, but usually the differences will outweigh the similarities. So it is not a good idea to do something in language \verb#A# just and only it is done that way in language \verb#B#. On the other side, it should always be proved whether something that worked fine for one language would not be a great idea to be applied to code in another language, too.

In this sense, I would like to steal the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython,PYTHON_ORG_MAILING_LIST:ThePythonWay}\footnote{The numbering was added by me; I also added the ellipsis.} for this document:
\begin{enumerate}[nosep]
\item Beautiful is better than ugly.
\item Explicit is better than implicit.\label{lst:ZoP:ExplicitVsImplicit}
\item Simple is better than complex.
\item Complex is better than complicated.
\item Flat is better than nested.
\item Sparse is better than dense.
\item Readability counts.
\item Special cases aren't special enough to break the rules …
\item … although practicality beats purity.
\item Errors should never pass silently …
\item … unless explicitly silenced.
\item In the face of ambiguity, refuse the temptation to guess.
\item There should be one – and preferably only one – obvious way to do\\ it …
\item … although that way may not be obvious at first unless you're Dutch.
\item Now is better than never …\label{lst:ZoP:Now}
\item … although never is often better than \textit{right now}.\label{lst:ZoP:RightNow}
\item If the implementation is hard to explain, it's a bad idea.
\item If the implementation is easy to explain, it may be a good idea.
\item Namespaces are one honking great idea – let's do more of those!\label{lst:ZoP:Namespaces}
\end{enumerate}
Only number~\ref{lst:ZoP:Namespaces} does not work for code written in Java, unless you translate “Namespace” to “Package” (or “Module” …).

A good example for the other way round – other programming languages adopting a feature from Java – is the idea to add documentation comments to the source code and to use a tool like JavaDoc to externalise them and publish them as the API documentation. It was adopted for various other languages, including so different specimen as C/C++, JavaScript and PL/SQL.\footnote{Although we have to confess that the commenting style is not part of the specification of these languages but only supported by external tools.} Obviously, if you want to benefit from that adopted feature, you have to write your C++ (JavaScript, PL/SQL, …) code (more precise, your comments) according to coding conventions similar to those defined here.

But no matter what programming language is used: The \textit{Basic Rule} as defined in chapter \tqfullref{sec:TheBasicRule} below will be applicable to each!\footnote{And that does not contradict with numbers~\ref{lst:ZoP:Now} and \ref{lst:ZoP:RightNow} from the “Zen of Python”!}

A sample for code conventions for JavaScript can be found in the web at \autocite{JAVASCRIPT_CODE_CONVENTIONS}.

In chapter \tqfullvref{sec:FormattingSQLInsideJava} we have added some rules on how to format SQL statements when added as literals into a Java program.

\section{Code Generators}
Java code that is automatically generated by another piece of software should implement this coding conventions in the same way as “hand crafted” code. Most generators are highly configurable and/or allow to use code templates that are customisable.\footnote{Perhaps you want to have a look to \autocite{TQUADRAT_ORG_FOUNDATION_JAVACOMPOSER}}

Especially if base classes will be generated it is important that proper comments are generated at least for all API elements; this means all \lstinline|public| and \lstinline|protected| elements, and in some cases all package-local elements, too.

Since Java~6 there is an annotation \lstinline|javax.annotation.Generated| (\lstinline|@Generated|) that should be used to mark generated code. Refer to \autocite{ORACLE_DOC_GENERATED_ANNOTATION} for the details.\footnote{In case still Java~5 is used as the source code version, it should be considered to create an own \lstinline|@Generated| annotation along the lines given by that existing in Java~6 and later.}

\section{Programming for Sustaining}
And what to do with “legacy” code that has to be fixed?

Most probably that code will not follow these coding conventions (if any at all …), and it is rarely a good idea to reformat or rewrite it completely just to align it with the conventions. Instead a fix should be limited to the area that is broken.

But if possible, the fix should incorporate the standards defined by this document. Be creative how to implement the these standards. So if a method has to be reimplemented completely, format it as described here and add the appropriate JavaDoc comments, if missing. Or if a new field has to be added to a class, add the “m\_” prefix to its name (see chapter \tqfullref{sec:Fields}).

Obviously, completely new interfaces and classes should be implemented fully compliant to this conventions.

In this context, see also chapter \tqfullvref{sec:MaintenanceComments}.

\section{Tool Support}
Several of the rules and recommendations can be implemented through the configuration of the programming enviroment that is used, especially those from chapter \tqfullref{sec:FormattingTheSourceCode} that deals with the formatting of the source code.

The chapter \tqfullref{sec:IDEConfiguration} provides some configuration samples for Eclipse and JetBrains IntelliJ IDEA.

\section{The Basic Rule}\label{sec:TheBasicRule}
One rule should be followed before any other rule or recommendation given in this document:

\begin{center}
\begin{huge}
\fbox{\textbf{Always do it right in the first place!}}
\end{huge}
\end{center}

Experiences with lots of programming projects has shown that programmers seldom touch their code again, once it is written.\footnote{Usually, they will return to the code only when it is broken – and then they want to fix the bug, not adding missing comments …} As a result, missing comments will never be added, shady programming patterns would not be fixed – with the consequence that in case of a bug the maintainer is lost in a poorly documented chaos of badly formatted source code.

\textit{And this is exactly what we want to avoid!} 

This means there is never ever any excuse for omitting comments, using ‘temporary’ names or doing other ‘funny’ things. And we all know about the quick and dirty PoC that made it into a product without significant changes …

So again:

\begin{center}
\begin{huge}
\fbox{\textbf{Always do it right in the first place!}}
\end{huge}
\end{center}

\chapter{Formatting the Source Code}\label{sec:FormattingTheSourceCode}
This chapter deals with the proper formatting of Java source code. The formatting of comments is covered in chapter \tqfullvref{sec:WritingProperComments}.

I start the chapter with a description of the general structure of a source file, then I give some general conventions before I cover the formatting of single elements of the code.

\section{Java Source File Structure}
A file with Java source code consists of sections that should be separated by blank lines and a comment identifying each section.

Files longer than 2000~lines are cumbersome and should be avoided.\footnote{There are some well known scenarios where it is difficult to adhere with this limit. The first is with generated code, the other one is with classes having lots of attributes: the formatting style and coding rules proposed in this document require a least 5~lines for each attribute, 6~lines for each getter method and 11~lines for each setter method, always including all comments and blank lines. This is about 22~lines for each attribute. Nearly one hundred attributes seems to be a lot, but we have seen more than one real life application where database tables had more than that number of columns. I do not think that this is a good design anyway, but if our new Java class has to reflect the legacy data model, it has to have that number of attributes.}

Each Java source file contains a single \lstinline|public| class or interface. When \lstinline|private| top-level classes and interfaces are associated with a \lstinline|public| class, they can be put into the same source file as the \lstinline|public| class, although this is not recommended.\footnote{Usually, it should be considered to have these classes or interfaces as \textit{inner} classes/interfaces} In such a case, the \lstinline|public| class should be the first class or interface in the file.

The sections of a Java source file have the following ordering:

\begin{enumerate}[nosep]
\item{Beginning comments}
\item{Package and import statements}
\item{Class and interface declarations}
\item{Closing comment}
\end{enumerate}

\subsection{Beginning Comments}\label{sec:BeginningComments}
All source files have to start with a c-style comment that gives the copyright notice and the license information:\footnote{This is different from \autocite{SUN_CODE_CONVENTIONS:BeginningComments}; the Sun coding conventions recommend to put also the class name and the date into the beginning comment. I omitted the name of the class because this is obvious from the file name in case of a \lstinline|public| class, and it would confuse the reader if the file contains more than one class. The date is considered obsolete.}
\begin{lstlisting}[numbers=left,caption={Beginning Comment}]
/*
 * ==================================================================
 * Copyright © <Year> <Copyright Notice>
 * ==================================================================
 *
 * <License Notice>
 */
\end{lstlisting}
 
\verb#<Year>#, \verb#<Copyright Notice># and \verb#<License Notice># has to be replaced by the appropriate texts.\footnote{The special character \copyright is used not only because is looks better; it tells you immediately whether your environment is capable to deal with UTF-8 encoded files.}

The lines with the equals signs (“===”) will end at column 80; refer to chapter \tqfullvref{sec:LineLength}.

No other information should be added to this comment block.

\subsection{Package and Import Statements}

The first non-comment line of a Java source file is the \lstinline|package| statement\footnote{Production code will never use the default package, so there will be always a \lstinline|package| statement in every source file.}.

After that, usually several \lstinline|import| statements will follow. For example:

\begin{lstlisting}
package java.awt;

import static java.lang.String.format;
import static java.lang.System.out;
…

import java.awt.peer.CanvasPeer;
import java.io.InputStream;
…
\end{lstlisting}

Static imports has to be placed before imports for classes. Inside these blocks, the imports should be ordered alphabetically. Wildcard imports like

\begin{lstlisting}
import static java.lang.String.*;
…

import java.util.*;
…
\end{lstlisting}

are not allowed.

For the names of packages, see chapter \tqfullvref{sec:Packages}.

Eclipse users can use the function \verb#Source|Organize Imports# from the menu, or the short-key \verb#Shift+Ctrl+O#. This will reorder the import statements, explode the wildcards and remove unused imports; it will even add currently missing imports – given that this properly configured in the \verb#preferences# at \verb#Java|Code Style|Organize Imports#.

At IntelliJ~IDEA, the function \verb#Code|Optimize Imports# from the menu does something similar; the short key would be \verb#Ctrl+Alt+O#.

\subsection{Class and Interface Declarations}\label{sec:ClassAndInterfaceDeclarations}
At least since Java~5, there are not only classes and interfaces that are declared in a Java source file. We have

\begin{itemize}[nosep]
\item{classes (keyword \lstinline|class|)}
\item{interfaces (keyword \lstinline|interface|)}
\item{enums (keyword \lstinline|enum|)}
\item{records (keyword \lstinline|record|)}
\item{annotations (keyword \lstinline|@interface|)}
\end{itemize}

Each of these allows different parts in their declaration; the following tables describe the various parts and the order that they should appear in the files. Each part has a header comment, and inside each part, the elements are ordered alphabetically.

\subsubsection{Class}
A skeleton for a Java class may look like this:

\begin{lstlisting}[numbers=left,caption={Class Skeleton}]
public class MyClass 
{
        /*---------------*\
    ====** Inner Classes **==========================================
        \*---------------*/
    …    
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
            
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …            
}
//  class MyClass
\end{lstlisting}
 
\begin{filecontents}{ClassParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of a class declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Inner Classes (optional) & Given the class defines inner classes or interfaces, either \lstinline|private| or \lstinline|public|, they will come first. Internally, they will follow the same rules as their containing classes. \\ 
  \hline 
  Constants (optional) & This part takes all constants defined by this class (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here go the attributes for the class; technically, this part is in fact optional for a class, but usually a class without any attributes does not make much sense. Attributes are \lstinline|private| (under some exceptional circumstances, they can be \lstinline|protected|) and usually, they are not \lstinline|static|. \\ 
  \hline 
  Static Initialisations (optional) & If a class declares \lstinline|static| fields that are not mere constants or their initialisation is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block.
  
  This is also the right place for the serialVersionUID of a seria­lisable class. \\ 
  \hline 
  Constructors (optional) & All the constructors for the class go into this part. It is optional in case the class will have only an empty \lstinline|public| default constructor, but usually this will be coded, too. \\ 
  \hline 
  Methods (optional) & All methods of the class are in this part. Again, this part is technically optional, but classes without methods are barely useful.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{ClassParts.tbl}

\subsubsection{Interface}
A skeleton for an interface may look like this:

\begin{lstlisting}[numbers=left,caption={Interface Skeleton}]
public interface MyInterface 
{
        /*---------------*\
    ====** Inner Classes **==========================================
        \*---------------*/
    …
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  interface MyInterface
\end{lstlisting}
 
\begin{filecontents}{InterfaceParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an interface declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Inner Classes (optional) & Defining inner classes for an interface is discouraged, although there are some valid use cases for this. If the interface defines inner classes or interfaces, they have to be \lstinline|public| – classes have to be \lstinline|static|, too, and they will be the first part. Internally, they will follow the same rules as for top-level classes. \\ 
  \hline 
  Constants (optional) & This part takes all constants defined by this class (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time. \\ 
  \hline 
  Methods (optional) & All methods of the interface are in this part. Again, this part is technically optional, it can be omitted for so-called \textit{marker interfaces}.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{InterfaceParts.tbl}

\subsubsection{enum}
An \lstinline|enum| is a special case of a Java class. Usually it only contains the enumeration values, but it can have more components. A skeleton for a enum class may look like this:

\begin{lstlisting}[numbers=left,caption={enum Skeleton}]
public enum MyEnum 
{
        /*------------------*\
    ====** Enum Definitions **=======================================
        \*------------------*/
    …
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
        
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  enum MyEnum
\end{lstlisting}
 
\begin{filecontents}{EnumParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an enum declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Enum Definitions & This part is mandatory. Each \lstinline|enum| is an instance of the enum class. \\ 
  \hline 
  Constants (optional) & This part takes all additional constants defined by this enum (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here goes the attributes for the enum, if any. Each attribute has to be \lstinline|private final| and will be initialised by the constructor. \\ 
  \hline 
  Static Initialisations (optional) & If an enum declares \lstinline|static final| fields with an initialisation that is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block. \\
  \hline 
  Constructors (optional) & All the constructors for the enum (rarely there is more than one) go into this part, if any. A constructor has to \lstinline|private|. \\ 
  \hline 
  Methods (optional) & All methods of the class are in this part.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{EnumParts.tbl}

\subsubsection{Record}
Records had been introduced to Java with version~14. Like an enum, a record is a restricted form of a Java class. It’s ideal for “plain data carriers” classes that contain data not meant to be altered and has only the most fundamental methods such as constructors and accessors.\autocite{ORACLE_DOC_RECORD,ORACLE_DOC_LANGUAGE_SPECIFICATION:RecordClasses}

A skeleton for a Java record class may look like this, with all parts being optional:
\begin{lstlisting}[numbers=left,caption={Record Skeleton}]
public record MyRecord( ... ) 
{
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
        
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  record MyRecord
\end{lstlisting}
 
\begin{filecontents}{RecordParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of a record declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Constants (optional) & This part takes all constants defined by this record (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here go the attributes for the class; this part is optional, because usually, all attributes are defined as arguments to the \lstinline|record| definition. \\ 
  \hline 
  Static Initialisations (optional) & If a record declares \lstinline|static| fields that are not mere constants or their initialisation is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block. \\ 
  \hline 
  Constructors (optional) & If the record needs additional constructors, these go into this part. It is optional, because in most cases no additional constructor is need. \\ 
  \hline 
  Methods (optional) & All additional methods of the record are in this part. \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{RecordParts.tbl}

\subsubsection{Annotation}
Annotations had been introduced with Java~5.\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:AnnotationInterfaces} A skeleton for an annotation interface may look like this:

\begin{lstlisting}[numbers=left,caption={Annotation Skeleton}]
public @interface MyAnnotation 
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
                
}
//  @interface MyAnnotation
\end{lstlisting}
 
\begin{filecontents}{AnnotationParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an annotation declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Attributes (optional) & Here go the attributes for the annotation, if any. \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{AnnotationParts.tbl}

\subsection{Closing Comment}
A closing comment like
\begin{lstlisting}[numbers=left, caption={Closing Comment}]
/*
 *  End of File
 */
\end{lstlisting}
at the end of the source file is helpful to detect whether a source file was corrupted: if missing, there is a good chance that the file is incomplete.

I confess that this kind of error has got very unlikely with modern hard-drives, but it can still happen when sending around sources over the net.

\section{Indentation}
Indentation, together with empty lines, is the most important tool to structure any source code.

\subsection{Indentation Style}\label{sec:IndentationStyle}
I prefer the so-called GNU or BSD style and recommend it to you as well, because it makes it easier to detect the begin and the end of a code block. It demands to have the opening and closing curly braces on a line of their own, like this:

\begin{lstlisting}
public class MyClass
{
    public void method()
    {
        if( flag )
        {
            /* do something */
        }
        
        for( final var i = 0; i < max; ++i )
        {
            /* do something else */
        } 
    }   //  method()
}   //  class MyClass
\end{lstlisting}

\subsection{Indentation Size}
Four (4) spaces should be used as the unit of indentation. Tabs are \textit{not} allowed.\footnote{This is different from \autocite{SUN_CODE_CONVENTIONS}; the Sun Coding Convention do not explicitly specify whether to use blanks or tabs.} Usually this can be configured in your IDE; in Eclipse this is part of the \textit{Formatter} definition (\verb#Window|Preferences|Java|Code Style|Formatter#).

\subsection{Line Length}\label{sec:LineLength}
Some sources (including the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS}) recommend to avoid lines longer than 80 characters, because they were not handled well by many terminals and tools.

This had been true at the time those documents were written, but today's  graphical screens are much wider (sometimes even 200 characters can be put into one line), and modern tools do not even care about line length, so we do not want to recommend a fixed line length for source code.

\textbf{Note:} Sample code for use in documentation should have a limited line length – generally not more than 70 characters.

Different to that, comment lines are limited to 80 characters – or more precise, they have to end at column 80. All lines with “ASCII graphics” are extended to that column. This is pertaining to the beginning comments (chapter \tqfullvref{sec:BeginningComments}), the structuring comments (chapter \tqfullvref{sec:StructuringComments}) and most single-line comments (chapter \tqfullref{sec:SingleLineComments}).

\subsubsection{Wrapping Lines}\label{sec:WrappingLines}
When an expression does not fit on a single line, break it according to these general principles:
\begin{itemize}[nosep]
\item{Break after a comma.}
\item{Break before an operator.}
\item{Prefer higher-level breaks to lower-level breaks.}
\item{Align the new line with the beginning of the expression at the same level on the previous line.}
\item{If the above rules lead to confusing code or to code that's squished up against the right margin, just indent 8 (eight) spaces instead.}
\end{itemize}

Here are some examples of breaking method calls:
\begin{lstlisting}[numbers=left]
// USUAL
someMethod( longExpression1, longExpression2, longExpression3,
    longExpression4, longExpression5 );
        
// SINGLE LINE FOR EACH ARGUMENT
someMethod
( 
    longExpression1,
    longExpression2,
    longExpression3,
    longExpression4, // some comment
    longExpression5
);

// LONG EXPRESSIONS
var = someMethod1( longExpression1,
        someMethod2( longExpression2,
                longExpression3 ) );
\end{lstlisting}

Using a single line for each argument makes especially sense in cases where one or more expressions are really long, or if a comment should be added to the argument.

Next there are two examples of breaking an arithmetic expression. The first is preferred, since the break occurs outside the parenthesized expression, which is at a higher level.
\begin{lstlisting}[numbers=left]
// PREFER
longName1 = longName2 * (longName3 + longName4 - longName5)
           + 4 * longname6;
           
// AVOID!!!           
longName1 = longName2 * (longName3 + longName4
                       - longName5) + 4 * longname6;
\end{lstlisting}

Then we have three examples of indenting method declarations. The first is the conventional case. The second would shift the second and third lines to the far right if it uses conventional indentation, so instead it indents only 8 spaces. The final one uses a single line for each argument.

A throws clause will be either appended on the same line as the closing parentheses, or it can be on its own line with an indentation of four blanks.
\begin{lstlisting}[numbers=left]
// CONVENTIONAL INDENTATION
public void someMethod( int anArg, Object anotherArg,
    String yetAnotherArg, Object andStillAnother )
{
    …
}

public void otherMethod( int anArg, Object anotherArg,
    	String yetAnotherArg, Object andStillAnother )
    throws IllegalArgumentException, IOException
{
    …
}

// INDENT 8 SPACES TO AVOID VERY DEEP INDENTS
private static synchronized void horkingLongMethodName( int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother )
{
    …
}

private static synchronized void horkingLongMethodThrows( int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother ) throws IllegalArgumentException
{
    …
}

// SINGLE LINE FOR EACH ARGUMENT
private static synchronized anotherHorkingLongMethodLine
(
    int anArg,
    Object anotherArg,
    String yetAnotherArg,
    Object andStillAnother
)
{
    …
}

private static synchronized anotherHorkingLongMethodLineThrows
(
    int anArg,
    Object anotherArg,
    String yetAnotherArg,
    Object andStillAnother
) throws IllegalArgumentException, IOException
{
    …
}
\end{lstlisting}

Here are three acceptable ways to format ternary expressions\footnote{Read more about the ternary operator \lstinline|?| in chapter \tqfullvref{sec:TheTernaryOperator}.}:
\begin{lstlisting}[numbers=left]
alpha = (aLongBooleanExpression) ? beta : gamma;
alpha = (aLongBooleanExpression) ? beta
                                 : gamma;
alpha = (aLongBooleanExpression)
        ? beta
        : gamma;
\end{lstlisting}

\section{Declarations}
This chapter deals with the formatting of declarations. See also chapter \tqfullvref{sec:WrappingLines} for informations on how to wrap long declarations.

\subsection{Multiple Declarations per Line}
It is strongly encouraged to have only one declaration per line, as it is also comforting to add comments to the declaration. In other words, 
\begin{lstlisting}
int level; // indentation level
int size;  // size of table
\end{lstlisting}

is preferred over

\begin{lstlisting}
// AVOID!!!
int level, size;
\end{lstlisting}

Do not put different types on the same line, despite the compiler does not complain about it. Example:
\begin{lstlisting}
// WRONG!!!!
int foo, fooarray [];
\end{lstlisting}

\subsection{Array Declarations}
The brackets for an array declaration always have to be put to the type, not to the name. So it should read
\begin{lstlisting}
int [] foo;
String [] bar;
java.awt.Button [] buttons;
\end{lstlisting}
and not
\begin{lstlisting}
// AVOID!!!
int foo [];
// AVOID!!!
String bar [];
// AVOID!!!
java.awt.Button buttons [];
\end{lstlisting}
This is the same way as an array would be declared as the return value for a method:
\begin{lstlisting}
public final static String [] getTexts()
{
    return m_Texts;
}	//	getTexts()
\end{lstlisting}

\subsection{Placement of Declarations}
You should put declarations where there are needed; usually this means that it should be waited with the declaration of variables until their first use.\footnote{In this aspect, my point of view is completely contradicting to that of the authors of \autocite{SUN_CODE_CONVENTIONS}.}

This is true even for variables inside a loop:
\begin{lstlisting}
for( var i = 0; i < limit; ++i )
{
    final var a = getValue( i );
    …
}
\end{lstlisting}

Only the repeated initialisation of a variable inside a loop should be avoided, when possible:
\begin{lstlisting}[numbers=left]
// AVOID!
for( var i = 0; i < limit; ++i )
{
    final var a = new VeryComplexType();
    …
}
\end{lstlisting}
In this case, line~4 should be moved before the loop header (line~2).

Absolutely avoid local declarations that hide declarations at higher levels. For example, do not declare a variable with the same name as a field:
\begin{lstlisting}
public class MyClass
{
    int count;

    public void method()
    {
        if( condition )
        {
            int count = 0; // AVOID!
            // more code
        }
        // more code
    }
}   //  class MyClass
\end{lstlisting}
There are a settings for both Eclipse preferences and IntelliJ~IDEA that triggers a warning or even an error in such cases. In addition, the rules for the naming of fields (refer to chapter \tqfullvref{sec:Fields}) would make such a situation unlikely.

\subsection{Class and Interface Declarations}
When coding Java classes and interfaces, the following formatting rules has to be followed:
\begin{itemize}
\item{No space between a method or constructor name and the parenthesis “(” starting its formal parameters list.}
\item{If using generics, no space between the name of the class or interface and the opening “<”.}
\item{An open curly brace “{” appears at a line by itself with the same indentation as the declaration statement.}
\item{A closing curly brace “}” starts a new line, indented to match its corresponding opening statement; in case of a method or constructor declaration, it is followed by a comment with the name of the method. For classes or interfaces, the name of the class or interface is repeated in a new line after the closing brace.}
\item{Inner classes, constants, attributes, constructors, methods, they all are separated by a blank line (see chapter \tqfullref{sec:BlankLines}.}
\item{Short methods may be written in one single line. In this case, “one single line” means exactly that: \textit{one single} line! Any line break requires the full form as for the sample “composeCorrectKey()” below (line 28).}
\end{itemize}
An example:
\begin{lstlisting}[numbers=left]
class Sample extends Object implements Comparable<Sample>
{
    int ivar1;
    
    int ivar2;
    
    Sample( int i, int j ) 
    {
        ivar1 = i;
        ivar2 = j;
        …
    }  //  Sample()
    
    void method()
    {
        …
    }  //  method()
    
    // SHORT METHOD
    int getIVar1() { return ivar1; }
    
    // AVOID!!! Not a short method!
    String composeWrongKey( String component1, String component2,
                            String component3 ) { return component1
        + component2 + component3; }
        
    // Correct
    String composeCorrectKey( String component1, String component2,
                              String component3 )
    {
        return component1 + component2 + component3;
    }   //  composeCorrectKey()
}
//  class Sample
\end{lstlisting}

The comments at the end of the methods make it easier to navigate inside long source files, especially when scrolling upwards.

\section{White Space}
This chapter deals with the white space other than the indentation blanks.

\subsection{Blank Lines}\label{sec:BlankLines}
Blank lines improve readability by setting off sections of code that are logically related.
If not separated by an explicit comment, two blank lines should always be used in the following circumstances:
\begin{itemize}
\item{Between sections of a source file\footnote{Although this would hurt the rules for commenting as set in chapter \tqfullref{sec:StructuringComments}}}
\item{Between class and interface definitions}
\end{itemize}

One blank line should always be used in the following circumstances:
\begin{itemize}
\item{Between methods}
\item{Before a block or single-line comment}
\item{Between logical sections inside a method to improve readability}
\item{To group some code lines logically}
\end{itemize}
More than one blank line should be avoided, except for the case mentioned above.

\subsection{Parenthesis}\label{sec:Parenthesis}
We distinguish between arithmetical parenthesis and parameter parenthesis; the first is used in expressions to order the terms, the latter is used with method or constructor calls or in lambdas.

\paragraph{Arithmetical Parenthesis}–
An opening arithmetical parenthesis is always preceded by a blank or another opening parenthesis and never followed by a blank, a closing one is never preceded by a blank, but always followed either by another closing parenthesis, a blank, or a newline (or a semicolon, in case the statement ends).

\paragraph{Parameter Parenthesis}\label{sec:ParameterParenthesis}–
An opening parameter parenthesis is never preceded by a blank and ever followed by one, while a closing one is always preceded by one. The only exception is for empty arguments lists where the opening parenthesis is immediately followed by the closing parenthesis.

Regarding to this rule, \lstinline|if|, \lstinline|for|, \lstinline|while|, \lstinline|try| and \lstinline|switch| are treated like functions (see also chapter \tqfullref{sec:BlankLines}).\footnote{And also the keywords \lstinline|catch| and \lstinline|synchronized|, but they do not allow complex terms inside there 'argument list'.}

This rule can improve the readability of complex terms drastically, as the examples below will illustrate.

\begin{lstlisting}[numbers=left]
int v = (a + b) * 5;
double d = sin( (a + b) / c );
System.out.println( "Finished!" );
set( get() );
System.out.println( sin( ((a + b) * (c + 4) + c)) / d ) );
if( a < b ) c = (d + e) / sin( f );
while( ((line = reader.readLine()) != null) && (++i < capacity) )
    processLine( line );
\end{lstlisting}

\subsection{Blank Spaces}\label{sec:BlankSpaces}
Additionally, blank spaces should be used in the following circumstances:
\begin{itemize}
\item{With a keyword followed by a parenthesis, like \lstinline|if|, \lstinline|while|, \lstinline|for| etc. There is no blank space between the keyword and the opening parenthesis, but  between that parenthesis and the argument. Another blank space is between the (last) argument and the closing parenthesis. As a short it can be said that parenthesis for these keywords will be treated like parameter parenthesis, as already stated in \tqfullref{sec:ParameterParenthesis}.\footnote{This is in opposite to the sun codeing conventions \autocite{SUN_CODE_CONVENTIONS}; there it is recommended to have a blank between the keyword and the opening parenthesis while not using it between the method name and the opening parenthesis here, just to distinguish between keywords and methods calls. We think that it is more important to distinguish between parenthesis in arithmetical expressions and those in method calls.}

Examples:
\begin{lstlisting}[numbers=left]
while( true )
{
    …
}

for( int i = 0; i < 10; ++i ) { … }

try
{
    …
}
catch( Exception e )
{
    e.printStackTrace();
}

if( list.isEmpty() ) { … }
\end{lstlisting}}
\item{A blank space has to appear after commas in argument lists. The exception are generics where the comma is not followed by a blank space in case there is more than one type.

Examples:
\begin{lstlisting}[numbers=left]
Map<String,String> map = new HashMap<String,String>();
Map<String,String> map = new HashMap<>(); // using the diamond operator
map.put( key, value );
\end{lstlisting}}
\item{All binary operators except “.” has to be separated from their operands by spaces. Blank spaces should never separate unary operators such as unary minus, increment (“++”), and decrement (“--”) from their operands.

Example:
\begin{lstlisting}[numbers=left]
a += c + d;
a = (a + b) / (c * d);

while( d-- > s++ )
{
    ++n;
}

printSize( "size is " + foo + "\n" );
\end{lstlisting}}
\item{The expressions in a \lstinline|for| statement has to be separated by blank spaces after the semicolon.

Example:
\begin{lstlisting}
for( expr1; expr2; expr3 )
{
    …
}
\end{lstlisting}

For an extended for loop, blank spaces has to be placed around the colon, too:
\begin{lstlisting}[numbers=left]
for( String s : stringArray ) System.out.println( s );
\end{lstlisting}}
\item{For ternary statements, the question mark (“?”) and the colon (“:”) has to be surrounded by blank spaces:

Example:
\begin{lstlisting}
int signum = d < 0 ? -1 : d > 0 ? 1 : 0;
\end{lstlisting}

In this sample, some parentheses would be helpful, too.}
\item{Casts should be followed by a blank space. 

Examples:
\begin{lstlisting}
method( (byte) aNum, (Object) x);
method( (int) (cp + 5), ((int) (i + 3)) + 1 );
\end{lstlisting}}
\end{itemize}

\section{Statements}
Now we will have a look on how to format statements.

\subsection{Simple Statements}
Each line should contain at most one statement. Or, the other way round, each (simple) statement has to be written to its own line.

Example:
\begin{lstlisting}
// CORRECT
++argv;
--argc;

// AVOID!!!
--argv; --argc;
\end{lstlisting}

\subsection{Compound Statements}\label{sec:CompoundStatements}
Compound statements are statements that contain lists of statements enclosed in curly braces “{ statements }”. See the following sections for examples.

Here some general rules first:
\begin{itemize}
\item{The enclosed statements should be indented one more level than the compound statement.}
\item{The opening brace should be at a line of itself, indented to the same level as the compound statement.
Accordingly, the closing brace should begin a line and be indented to the beginning of the compound statement. The exception are short methods where all is one line (refer to chapter \tqfullvref{sec:ClassAndInterfaceDeclarations})}.
\item{Braces are used around all statements (meaning even if there is just one) when they are part of a control structure, such as a \lstinline|if-else| or \lstinline|for| statement. This makes it easier to add statements without accidentally introducing bugs due to forgetting to add braces.

The only exception from this rule is when a single statement is written on the same line as the compound statement itself.

Examples:

\begin{lstlisting}[numbers=left]
// Ok
if( a < b ) c = d;

// AVOID!!!
if( a < b ) c = d; else e = f;
if( a < b )
    c = d;
if( a < b )
    c = d;
else
    e = f;

// RECOMMENDED
if( a < b )
{
    c = d;
}
else
{
    e = f;
}

// Ok
for( String s : strings ) ++i;

// AVOID!!!!
for( String s : strings )
    ++i;

// RECOMMENDED
for( String s : strings )
{
    ++i;
}

// DISCOURAGED!!!
for( String s : strings ) if( a < b ) c = d;
\end{lstlisting}

See also the chapters \tqfullref{sec:IfStatements}, \tqfullref{sec:SwitchStatements}, and \tqfullref{sec:WhileStatements}.}

\item{Long compound statements (long code blocks) should get an end comment. See chapters \tqfullref{sec:LabelsAndBreakStatements}, \tqfullref{sec:TrailingOrEndOfLineComments}, and \tqfullref{sec:CommentsWhen}.} 
\end{itemize}

\subsection{“Chaining”}
The interface for some classes allow to chain methods. If it is especially designed to allow this, it is referred to as the “Builder pattern”. Examples for this are \lstinline|java.lang.StringBuffer|, \lstinline|java.lang.StringBuilder|, and since Java~5, also \lstinline|java.io.Writer| and the classes derived from that class.

“Chaining” would allow to write

\begin{lstlisting}
writer.append( "Caption\t: " ).append( value );
\end{lstlisting}

instead of

\begin{lstlisting}
writer.append( "Caption\t: " );
writer.append( value );
\end{lstlisting}

The formatting rules are as follows:
\begin{itemize}
\item{If the “chain” does not fit completely into a single line, each method call has to be written into a single line of its own (as in line 4 below}
\item{The dot has to be written in front of the method's name}
\item{The methods will be indented regularly}
\end{itemize}

Some samples:
\begin{lstlisting}[numbers=left]
// Acceptable
writer.append( "Caption\t: " ).append( value );

// RECOMMENDED
writer.append( "Caption\t: " )
    .append( value );
    
// WRONG: The dot is trailing!
writer.append( "Caption\t: " ).
    append( value );
\end{lstlisting}

Java~8 introduced Streams and those will be formatted in the same way.

Example:
\begin{lstlisting}[numbers=left]
final var names = customers.stream()
    .filter( c -> c.getCountry().equals( GERMANY )
    .filter( c -> c.getTurnover() > limit )
    .map( Customer::getName )
    .sorted()
    .toArray( String []::new );
\end{lstlisting}

\subsection{return Statements}
A \lstinline|return| statement with a value should not use parentheses unless they make the return value more obvious in some way. Please see also chapter \tqfullvref{sec:ReturningValues}!
Example:
\begin{lstlisting}[numbers=left]
// Usually obsolete
return;

// NOT RECOMMENDED
return myDisk.size();

// MAY BE OK
return (m_Size > 0 ? m_Size : m_DefaultSize); 

// AVOID!!!
return( retValue );

// RECOMMENDED; usually the only valid form 
return retValue; 
\end{lstlisting}

\subsection{if, if-else, if-else-if-else Statements}\label{sec:IfStatements}
The chapters \tqfullref{sec:Parenthesis}, \tqfullref{sec:BlankSpaces}, and \tqfullref{sec:CompoundStatements} covered already some aspects of the \lstinline|if-else| class of statements that may be repeated here again.

The base forms for this class of statements are the following ones:
\begin{lstlisting}[numbers=left]
if( <condition> )
{
    <statements>;
}

if( <condition>)
{
    <statements>;
}
else
{
    <statements>;
}

if( <condition1>)
{
    <statements>;
}
else if( <condition2>)
{
    <statements>;
}
else
{
    <statements>;
}
\end{lstlisting}

In case there are more conditions to check, but a switch statement cannot be used due to the data types involved or the logic for the conditions, use the form in line 15.

The only occasion where an if statement does not need the curly braces (“{}”) is when there is a single statement on the same line as the \lstinline|if| clause and there is no \lstinline|else| clause:

\begin{lstlisting}
if( <condition> ) <singleStatement>;
\end{lstlisting}

In any other case the curly brace are mandatory, to avoid the following error-prone forms:

\begin{lstlisting}[numbers=left]
// AVOID! MISSING CURLY BRACES {}!
if( <condition> )
    <statement>;

// AVOID!!! EVEN WORSE THAN ABOVE!!    
if( <condition> )
    <statement>;
else
    <statement>;
\end{lstlisting}

Please refer also to chapter \tqfullvref{sec:TheTernaryOperator} that discusses the ternary “?” operator.


\subsection{switch Statements}\label{sec:SwitchStatements}
Beginning with the first preview in Java~12, an alternative syntax for \lstinline|switch| was introduced, so that we have now two (in fact, three) different forms of that construct.

\subsubsection{The traditional Form of switch}
Originally, a \lstinline|switch| statement in Java looked like this:
\begin{lstlisting}[numbers=left]
switch( <selector> )
{
    case <switchlabel1>:
        <statements>;
        // Falls through!

    case <switchlabel2>:
        <statements>;
        break;

    case <switchlabel3>: <singleStatement>; break;

    case <switchlabel4>:
    {
        <statements>;
        break;
    }

    case <switchlabel5>: // Also a fall-through
    case <switchlabel6>:
    {
        <statements>;
        break;
    }

    default:
       <statements>;
       break;
}
\end{lstlisting}

If a \lstinline|case| falls through, as in line~4, a comment “\lstinline|// Falls through!|” as in the sample is mandatory! In fact, this construct should be avoided when possible, because it also forces a special sequence of the \lstinline|case| clauses – requiring an additional comment to the \lstinline|switch| itself.

Different to that, no comment is required in the case shown in the lines~19 and 20: here we have two case that triggers the \textit{exactly the same} action.

For longer \lstinline|switch| statements it is highly recommended to use a label with the \lstinline|break| statement\footnote{In fact, I recommend to use always a label with \lstinline|break|; see chapter \tqfullref{sec:LabelsAndBreakStatements} on this topic.}; this can look like this:
\begin{lstlisting}
final Color color;
ColorSelector: switch( colorIndex )
{
    case 1: color = RED; break ColorSelector;
    case 2: color = BLUE; break ColorSelector;
    case 3: color = YELLOW; break ColorSelector;
    case 4: color = GREEN; break ColorSelector;
    default: color = NONE; break ColorSelector;
}   //  ColorSelector:
\end{lstlisting}

The break in the default case is redundant, but it prevents a fall-through error if later another case is added – although it should be assured that the default case is always the last case in the switch statement. Of course no \lstinline|break| is required when the branch is left by throwing an exception.

\subsubsection{The new Form of switch}
The alternative syntax for \lstinline|switch| comes in two flavours and looks like this:

\begin{lstlisting}[numbers=left]
// switch statement
switch( <selector> )
{
    case <switchlabel1> -> <singleStatement>;

    case <switchlabel2>, <switchlabel3> -> <singleStatement>;

    case <switchlabel4> ->
    {
        <statements>;
    }

    case <switchlabel4>, <switchlabel5> ->
    {
        <statements>;
    }

    default -> <singleStatement>;
}

// switch expression
var result = switch( <selector> )
{
    case <switchlabel1> -> <expression>;

    case <switchlabel2>, <switchlabel3> -> <expression>;

    case <switchlabel4> ->
    {
        <expressions>;
        yield <value>;
    }

    case <switchlabel4>, <switchlabel5> ->
    {
        <expressions>;
        yield <value>;
    }

    default -> <expression>;
}
\end{lstlisting}

Of course the \lstinline|default| in line~18 can be followed by a statement block as the \lstinline|case| in line~8, and the \lstinline|default| in line~40 can have a complex expression like the \lstinline|case| in line~28.

If used with pattern matching (refer to \autocite{ORACLE_DOC_PATTERNMATCHING}), it looks like this:

\begin{lstlisting}[numbers=left]
var selector = <anObject>
// switch statement
switch( selector )
{
    case null -> <singleStatement>;
    case <class1> <name1> -> <singleStatement>;

    case <class2> <name2> ->
    {
        <statements>;
    }

    default -> <singleStatement>;
}

// switch statement
var result = switch( selector )
{
    case null -> <expression>;
    case <class1> <name1> -> <expression>;

    case <class2> <name2> ->
    {
        <expressions>;
        yield <value>;
    }

    default -> <expression>;
}
\end{lstlisting}

Same as for \lstinline|default|, \lstinline|case null| can be followed by a statement block or a complex expression.

And an expression can also be always a \lstinline|throw|.

\subsubsection{General Rules for switch}
Every \lstinline|switch| statement should include a \lstinline|default| case, even when the cases are exhaustive.

If really all values are covered, the \lstinline|default| should throw an exception about an unknown value.\footnote{Refer to chapter \tqfullref{sec:UnsupportedEnumError} for a sample.}

Syntactically, the use of curly braces in the cases is optional, even for multi-line statements, but here it is set as mandatory. One reason is that it allows to declare additional variables for a given branch that are local to the given branch.

\subsection{for Statements}
A \lstinline|for| statement should have one of the following forms:

\begin{lstlisting}[numbers=left]
// Classic for loop:
for( <initialization>; <condition>; <update> )
{
    <statements>;
}
for( <initialization>; <condition>; <update> ) <singleStatement>;

// Enhanced for loop:
for( <declaration> : <iterable> )
{
    <statements>;
}
for( <declaration> : <iterable> ) <singleStatement>;
\end{lstlisting}

This means that curly braces have to be used in any case when more than one statement has to be executed in the loop. In addition, this single statement has to be written completely into the same line as the \lstinline|for| itself. 

Examples:
\begin{lstlisting}[numbers=left]
// Ok
for( var i = 0; i < max; ++i ) sum += i;
for( final var s : texts ) System.out.println( s );

// DISCOURAGED
for( var i = 0; i < max; ++i ) if( v [i] > 0 ) sum += v [i];
for( final var s : texts ) if( !s.empty() ) out.println( s );

// AVOID!!!
for( var i = 0; i < max; ++i ) if( v [i] > 0 )
{
    sum += v [i];
}
else
{
    sum -= v [i];
}

for( final var s : texts ) if( !s.empty() )
{
    System.out.print( "Value: " );
    System.out.println( s );
}
\end{lstlisting}
The samples in lines~6 and 7 are correct according to this rule, but as said in the comment above them, their use is discouraged and therefore it should be avoided, too.

An empty \lstinline|for|-loop (one in which all the work is done in the initialization, condition, and update clauses) should have the following form:\footnote{An \textit{enhanced} \lstinline|for|-loop without body does not make that much sense (that mentioned above is a classical \lstinline|for|-loop). It may be possible to write an implementation of \lstinline|java.lang.Iterable| with an iterator that does something as a side effect of \lstinline|hasNext()| or \lstinline|next()|, but this would break the contract of the interface \lstinline|java.lang.Iterator|.}

\begin{lstlisting}
for( <initialization>; <condition>; <update> );
\end{lstlisting}

When using the comma operator in the initialization or update clause of a \lstinline|for| statement, avoid the complexity of using more than three variables. If needed, use separate statements before the \lstinline|for|-loop (for the initialization clause) or at the end of the loop (for the update clause).

\subsection{while Statements}\label{sec:WhileStatements}
A \lstinline|while| statement should have one of the following forms:
\begin{lstlisting}[numbers=left]
while( <condition> ) <singleStatement>

while( <condition> )
{
    <statements>;
}
\end{lstlisting}

Again, the curly braces can only be omitted in case there is only a single statement, written on the same line than the \lstinline|while| statement, that has to be executed in the loop.

An empty \lstinline|while|-loop\footnote{An empty \lstinline|while|-loop usually makes no sense as the compiler optimises it away. Only when the condition causes side effects, it will be executed. But such an implementation is difficult to understand and should be avoided.} should have the following form: 
\begin{lstlisting}
while( <condition> );
\end{lstlisting}

Longer \lstinline|while|-loops should use a label:
\begin{lstlisting}
LoopLabel: while( proceed )
{
    // Lots of code lines here …
}   //  LoopLabel:
\end{lstlisting}

\subsection{do-while Statements}
A \lstinline|do-while| statement should look like below:
\begin{lstlisting}
do
{
    <statements>;
}
while( <condition> );
\end{lstlisting}

\subsection{try-catch Statements}
Basically, there are two different forms of \lstinline|try-catch| statements: the simple one and the \lstinline|try-with-resources| that was introduced with Java~7 (also refer to chapter \tqfullvref{sec:TryWithResources}).

\subsubsection{The simple Form}
A simple \lstinline|try-catch| statement has the following format:
\begin{lstlisting}
try
{
    <statements>;
}
catch( <ExceptionClass> e )
{
    <statements>;
}
\end{lstlisting}

\subsubsection{try-with-resources}
A \lstinline|try-with-resources| allows to allocate resources that will be automatically released when the \lstinline|try| block is left. Something similar could be achieved also by adding a \lstinline|finally| block, but \lstinline|try-with-resources| is easier and more secure.

If looks like this:

\begin{lstlisting}[numbers=left]
try( final var resource = new <ResourceClass>() )
{
    <statements>;
}

final var resource = new <ResourceClass>();
try( final var r = resource )
{
    <statements>;
}
\end{lstlisting}

\lstinline|<ResourceClass>| must implement \lstinline|java.lang.Autocloseable|.

It is possible to allocate more than one resource in a single \lstinline|try| statement:
\begin{lstlisting}
try
( 
    final var resource1 = new <ResourceClass1>(); 
    final var resource2 = new <ResourceClass2>() 
)
{
    <statements>;
}
\end{lstlisting}

A \lstinline|catch| block is optional for \lstinline|try-with-resources|.

\subsubsection{General Rules for try-catch}
In case the \lstinline|try| block can issue more than one exception type, these can be combined into one \lstinline|catch| block, like this:
\begin{lstlisting}
…
catch( <ExceptionClass1> | <ExceptionClass2> e )
{
    <statements>;
}
\end{lstlisting}

if all exceptions are handled by the same set of statements, or like this, when the exceptions are handled by different code blocks:

\begin{lstlisting}
…
catch( <ExceptionClass1> e )
{
    <statements>;
}
catch( <ExceptionClass2> e )
{
    <statements>;
}
\end{lstlisting}

Of course both can be combined:

\begin{lstlisting}
…
catch( <ExceptionClass1> | <ExceptionClass2> e )
{
    <statements>;
}
catch( <ExceptionClass3> e )
{
    <statements>;
}
\end{lstlisting}

Each \lstinline|try-catch| statement can also be followed by a \lstinline|finally| block, which  executes regardless of whether or not the \lstinline|try| block has completed successfully.

\begin{lstlisting}
try
{
    <statements>;
}
catch( <ExceptionClass> e )
{
    <statements>;
}
finally
{
    <statements>;
}
\end{lstlisting}

In case a \lstinline|finally| block is present, the \lstinline|catch| block is optional even for a simple \lstinline|try-catch| statement, meaning that no exception is caught:
\begin{lstlisting}
try
{
    <statements>;
}
finally
{
    <statements>;
}
\end{lstlisting}

An \textit{empty} \lstinline|catch| block is unacceptable under all circumstances! Refer to chapter \tqfullvref{sec:GeneralExceptionHandling} how to handle exceptions. See also chapter \tqfullvref{sec:SingleLineComments} about empty blocks and comments.

An empty \lstinline|finally| block is completely obsolete and must be removed.

\subsection{Labels and break Statements}\label{sec:LabelsAndBreakStatements}
In Java, labels are mainly used in conjunction with \lstinline|break| and \lstinline|continue| statements, but they can be placed anywhere in a code block.

The \lstinline|break| statement is used with the traditional \lstinline|switch| statement (refer to chapter \tqfullref{sec:SwitchStatements}), and – together with the \lstinline|continue| statement – with loops of all kind.\footnote{The use of \lstinline|break| and \lstinline|continue| with loops is usually discouraged, but in many cases it makes the logic of an algorithm easier and more understandable.}

I recommend to always use a meaningful label together with \lstinline|break| and \lstinline|continue|. This would make it more obvious what is intended with the \lstinline|break| or \lstinline|continue|, and it assures that the right block will be terminated. The label can also be used as the end comment for a code block, as described in chapter \tqfullref{sec:TrailingOrEndOfLineComments} and chapter \tqfullref{sec:CommentsWhen}.

Some samples:
\begin{lstlisting}[numbers=left]
// BAD!!!
for( var line = 0; line < maxLines; ++line )
{
    for( var column = 0; column < maxColumns; ++column )
    {
        if( !isValid( field [line] [column] ) break; // What??
        …
    }

    processLine( field [line] );
}

// RECOMMENDED
LineLoop: for( var line = 0; line < maxLines; ++line )
{
    ColumnLoop: for( var column = 0; column < maxColumns; ++column )
    {
        if( !isValid( field [line] [column] ) break ColumnLoop;
        …
    } //  ColumnLoop:
    processLine( field [line] );
} // LineLoop:

// RECOMMENDED
FilterLoop: while( input.hasNext() )
{
    final var value = input.next();
    if( !value.isValid() ) continue FilterLoop; // Skip invalid
    …
} // FilterLoop:

// RECOMMENDED
DirectionSwitch: switch( direction )
{
    case LEFT: goLeft(); break DirectionSwitch;
    case RIGHT: goRight(); break DirectionSwitch;
    default:
        throw new IllegalArgumentException( direction.toString() );
} //  DirectionSwitch:
\end{lstlisting}

The name of the label is repeated in a comment at the end of the code block, as shown in lines~20, 22, 30, and 39. The colon at the end of the label name is mandatory for this kind of comment.

\section{Special Files}
Beside the files that contain the Java source code (with the extension \verb#.java#), a project can contain several other files.

\subsection{The Module Definition}\label{sec:ModuleDefinition}
Modules have been introduced to Java with version 9, as a result of the Jigsaw project. A module will be defined in the file \verb#module-info.java# that is located in the root of the source tree. Details can be found in \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ModuleDeclarations}.

Basically, a \verb#module-info.java# file will look like this:
\begin{lstlisting}[numbers=left, caption={module-info.java},morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield}]
/*
 * ==================================================================
 * Copyright © <Year> <Copyright Notice>
 * ==================================================================
 *
 * <License Notice>
 */
 
/**
 *  <module description>
 */ 
module <modulename> 
{
    requires <name_of_required_module_1>;
    requires <name_of_required_module_2>;

    requires transitive <name_of_required_module_3>;

    exports <name_of_exported_package_1>;
    exports <name_of_exported_package_2> to <name_of_target_module_1>;

    opens <name_of_opened_package_1>;
    opens <name_of_opened_package_1> to <name_of_target_module_1>, <name_of_target_module_2>;

    uses <name_of_provider_interface>;
    provides <name_of_provider_interface> with <name_of_provider_implementation>;
}
//  module <modulename>

/*
 *  End of File
 */
\end{lstlisting}
How to define the name of the module (\lstinline|<modulename>|) is covered in chapter \tqfullvref{sec:Modules}.

The \verb#<module description># will be discussed in chapter \tqfullvref{sec:ModuleComment}.

\subsection{The Package Documentation}\label{sec:PackageDocumentation}
Different from the module, there is no special source file that defines a package in Java. Instead all source files that are located in the same folder on the directory tree for the source code are in the same \lstinline|package|.

Nevertheless there is a need for package-level documentation, and it is even possible to set annotations to packages.

For the documentation of a package, originally a file named \verb#package.html# was used, placed into the package folder. Although this still works, you should use the new \verb#package-info.java# file instead, because only this allows annotations on package level; it looks like this:

\begin{lstlisting}[numbers=left, caption={package-info.java}]
/*
 * ==================================================================
 * Copyright © <Year> <Copyright Notice>
 * ==================================================================
 *
 * <License Notice>
 */
 
/**
 *  <package description>
 */
@<AnAnnotation> 
package <packagename>;

import <AnAnnotation>

/*
 *  End of File
 */
\end{lstlisting}

The \verb#<package description># is a standard JavaDoc comment (refer to the chapter \tqfullvref{sec:DocumentationComments}) and can be as lengthy as necessary. It will be discussed in detail in chapter \ref{sec:PackageComment}.

If the package is annotated\footnote{I recommend to used the \lstinline|@API| annotation even on the package level (refer to chapter \tqfullvref{sec:APIAnnotation} for details).}, the annotations have to be placed directly before the \lstinline|package …| line, and the imports for the annotations follow below.

How to define the name of the package (\lstinline|<packagename>|) is covered in chapter \tqfullvref{sec:Packages}.

\chapter{Naming Conventions}
Naming conventions make programs more understandable by making them easier to read. They can also give information about the function of the identifier – for example, whether it's a constant, package, or class – which can be helpful in understanding the code.

The first rule about the naming of program elements is to use \textit{meaningful names}. But “meaningful” is a relative term, depending from context and experience. So the abbreviation “TSU” for a class name is just a cryptic three-letter-acronym for someone in the banking business while for people from the warehouse \& logistics domain no further explanation is required.\footnote{“TSU” stands for “Transport and Storage Unit” and is something like an abstract container of goods for a Warehouse Management System (WMS).} So we want to enhance this rule as we say that the name of a program element has to be meaningful for as many people as possible – even outside the current problem domain.

Additionally, names provide an implicit contract\footnote{If it is not a binding contract, so it is at least a kind of commitment.} between the original author of a program and its users/maintainers. So we expect that a method named \lstinline|read()| will \textit{read} something from somewhere. When it will perform write operations instead, that means this implicit contract is broken; at least, it requires an elaborate comment explaining why it \textit{writes}.

But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts to this document, together with a list of suffixes for class names. Refer to chapter \tqfullvref{sec:TheNamingDictionary} in the appendices for those lists.

The details on how names and identifiers are composed in Java, and where they are used can be taken from the respective chapter of the Java Language Speficication \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:NamesAndIdentifiers}.

But however, names like \lstinline|MyClass|, \lstinline|mypackage| or \lstinline|myMethod| may look good in some sample code (like in the sample listings in this document), but they are definitely invalid for real code!

\subsection{Language}
The identifier names has to be taken from English language, and with correct spelling.\footnote{I am conscious about the fact that there are differences between British and American English (at least between these two …) and their spelling. “Correct spelling” means “correctly spelled according to at least one variant”. Decide for one spelling scheme and stuck with it. I personally use American English for the names.} Consult a dictionary if in doubt of spelling and/or meaning.

The reason to use English is that this is the common language for most international teams.

But even if you are working in an environment where English is a foreign language, solely with people speaking all the local language, using English still has a big advantage: you can distungiush just by the language if someone talks about the ‘real world’ object or its representation in the program.\footnote{From a specification document: “Ein Konto wird repräsentiert durch ein Objekt der Klasse \lstinline|Account|, der Kontoinhaber entsprechend durch ein Object der Klasse \lstinline|AccountOwner|.” – If you do not understand German, the translation is like this: “An account will be represented through an object of the class \lstinline|Account|, and the account owner by an object of the class \lstinline|AccountOwner|, respectively.” Or short: an account is an \lstinline|Account|; in writing, this looks good, but in oral communications, misunderstandings are easy. }

\subsection{Uppercase, Lowercase, Camelcase}
Use CamelCase, starting with a capital letter, for the identifiers of all kinds of classes. For fields, local variables, and methods, use camelCase (starting with a lowercase character). For packages and modules, all lowercase is preferred, although not mandatory.

The Java coding convention \autocite{SUN_CODE_CONVENTIONS} demands all uppercase for constants and separating words with underscores, and usually this is implicitly expanded to enum values, too\footnote{The “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS} were last updated in 1999, enums had been introduced with Java~5, and that was released at 2004-09-29 …}. I prefer a more relaxed approach for that – see chapters \tqfullvref{sec:Constants} and \tqfullvref{sec:EnumValues}.

Details are again discussed in the chapter about the respective code elements.

\subsection{Length of Names and Use of Abbreviations}\label{sec:LengthOfNamesAndUseOfAbbreviations}
One aspect of abbreviations has been discussed already above. In general, avoid abbreviations and acronyms if those are not \textit{very well known}.

The length of a name has very little to no influence on the size and speed of the compiled code. And with the code completion features provided by modern IDEs, the programmer may not even have to type long names …

This means that you will never sacrifice the meaningfulness of a long name for typing speed – never ever!

If you think you will be more productive when using short names (because you can type them faster …), you are wrong! When you have the feeling that you have to write code faster, learn typewriting\footnote{For my understanding, someone who does not reach at least 100 CPM should look for a job outside of software development (average values for a trained user are around 200 CPM, peak values are at 500 to 900 CPM)}. It will also help you to write all the other stuff you have to deliver in addition to your code (documentation, meeting notes, emails, specification documents, …).

But of course Java programs do have a maximum length for identifiers\footnote{Although the Java Language Specification does not impose such a limit: “An \textit{identifier} is an unlimited-length sequence of \textit{Java letters} and \textit{Java digits}, the first of which must be a \textit{Java letter}.” (\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Identifiers})}, although it is with 64k higher than any practical use case. I think that a name for a module, package, class, method, field, constant, argument, or local variable that is longer than 100 or perhaps 150 characters is definitely too long to be useful.

\subsection{Special Characters}
Avoid special characters and punctuations in identifiers; the only exception are underscores for constants (see chapter \tqfullvref{sec:Constants}) and for the “m\_” prefix for fields (see chapter \tqfullvref{sec:Fields}) and a single dollar symbol (“\$”) in lambdas (see \tqfullvref{sec:Lambdas}). This, too, is a reason for using English for the names and identifiers: usually, you can limit yourself to the ASCII character set.

\subsection{“test” as Part of Names}
Avoid “test” as the part of the name of packages, classes, interfaces and methods that belong to the production code. For testers and for members of the test suite packages, it is allowed or even required, depending on the testing framework used. Also it may be recommended or even required if you write your own testing framework or extensions to an existing one.

\subsection{Names forced by 3\textsuperscript{rd} Party Components}
Most Java programs do not exist in a vacuum, they have links to other components (like databases, messaging systems, or the real world). These components may have different naming conventions, whether due to technical or historical reasons, or just because the names are as they are. In such case, the foreign names should get hidden through aliases, like constants or getter methods, whose names are following these naming conventions. This is even made easier as those external names are usually used as Strings in the program.

\section{Modules}\label{sec:Modules}
A module will be defined in the file \verb#module-info.java# that is located in the root of the source tree; see chapter \tqfullvref{sec:ModuleDefinition} and \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ModuleDeclarations} for the details.

Each module has a main package, and this should be also the name of that module. If the module will export any packages at all\footnote{A module for a program is not required to export anything.}, it has to export at least this main package.

So the names for modules will follow the same rules as those for packages.

\section{Packages}\label{sec:Packages}
According to the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS} the prefix of a unique package name is always written in all-lower-case ASCII letters and should be one of the top-level domain names (TLDs), currently “\verb#biz#”, “\verb#com#”, “\verb#edu#”, “\verb#gov#”, “\verb#int#”, “\verb#mil#”, “\verb#net#”, “\verb#org#”, or one of the two-letter codes identifying countries as specified in ISO Standard 3166, 1981.\footnote{There exist some more TLDs, but these are quite unlikely to be used in a package name. But of course, if you own a domain under this top-level domain, you can use that as well.}

Usually the second component is the company's or organisation's name as it appears in its website address, again in all lower case. This helps to ensure that packages will have a unique name across separate organisations.

Subsequent components of the package name vary according to an organization's own internal naming conventions. Such conventions might specify that certain directory name components be division, department, project, machine, or login names. Here also only lower case should be used.

Valid samples are:
\begin{itemize}[nosep]
\item\verb#org.tquadrat#
\item\verb#com.ibm#
\item\verb#com.sun#
\item\verb#de.jug#
\item\verb#uk.gov.hmrc#
\end{itemize}

Of course you should use your domain name! Those from the samples are already used by the respective companies or organisations (or persons).

Subsequent components of the package name vary according to an organisation's own internal naming conventions. Such conventions might specify that certain directory name components be division, department, project, machine, or login names. Here also only lower case should be used.

Next, a package name is also a folder name: the file with the source code for the class \lstinline|com.foo.bar.internal.MyImpl| is located in the folder \verb#com/foo/bar/internal# in the source code directory tree.

Finally the package name should reflect somehow the function of that package.

\subsection{The Packages “internal” and “spi”}
The modularisation that was introduced with Java~9 allows a much clearer separation of an API from its implementation. Let's assume that your module exports the package \lstinline|com.foobar.library|, then this package contains the interfaces of the API, plus some public helper classes, while the non-public package \lstinline|com.foobar.library.internal| contains the implementation classes and internal helpers.

If the API is extensible, an additional package \lstinline|com.foobar.library.spi| contains the stuff that is needed to extend the API. It can be exported globally or only to some other named modules.

For the details, refer to chapter \tqfullvref{sec:EncapsulationWithModules}.

\section{Classes}\label{sec:Classes}
In Java, classes, interfaces, enums, records and annotations are all “classes”, and the names for a class will be written in mixed case (also known as “camel case”) with the first letter capitalized (\lstinline|MyClass| instead of \lstinline|myClass|). Try to keep your class names simple and descriptive. Use whole words, mainly nouns, and avoid acronyms and abbreviations, unless the abbreviation is much more widely used than the long form, such as URL or HTML.

According to the Java syntax specification, several special characters are allowed also for class names, but this coding convention forbids them – even the underscore (“\_”)!\footnote{Especially the dollar sign (“\$”) can cause serious issues as this is used internally for the names of inner classes and anynomous classes, as well as for the classes that will be generared for lambdas.}

You should also avoid numerical characters in class names.

\subsection{Names for ‘real’ Classes}\label{sec:NamesForClasses}
A ‘real’ class is declared with the keyword \lstinline|class|. 

Some parts of a class name will indicate a special position of that class in the class hierarchy. So the suffix ‘Impl’ for the class name \lstinline|FooImpl| shows that the class is the default implementation of an interface named \lstinline|Foo|, either being the only one, or providing useful default implementations of the interface methods\footnote{Although in the latter case, the name is more likely to be \lstinline|FooBase|}.

‘Adapter’ as the suffix is similar, but here the methods are usually empty, as it is assumed that only a few of the methods of the interface are really required; various samples for this could be found in the Swing packages.

A suffix ‘Base’ indicates that the class has to be extended; usually that class is \lstinline|abstract|.

Other suffixes indicate special usage of the class. Well known and obvious are the suffixes ‘Error’ and ‘Exception’ for error and exception classes. Others are ‘Visitor’, and ‘Listener’ for the implementations of the respective patterns, ‘DAO’, or ‘Entity’. A more complete list can be found in chapter \tqfullvref{sec:SuffixesForClassNames} in the appendices. Most of these suffixes are defined by the design patterns that are implemented by the respective classes.

\subsection{Names for Interfaces}\label{sec:NamesForInterfaces}
An interface declares the public API for an object that represents a \textit{real world entity}, and it should be named according to that entity.

Some coding conventions (particular in the Windows realm) require the prefix ‘I’ for interfaces, but it does not make much sense to mark interfaces in such way. Therefore it is not recommended to use such a prefix for the names of interfaces.

\subsection{Names for enum Classes}\label{sec:NamesForEnumClasses}
An enum is a special class that will be declared with the keyword \lstinline|enum|.

The name of enum class should be somehow the category of the enumerated entities, but plurals should be avoided; so it should read \lstinline|Type| and not \lstinline|Types|, and \lstinline|DayOfWeek| and not \lstinline|DaysOfWeek|.

Although an enum class can implement an interface, this should not be reflected in the name. This means that \lstinline|TypeImpl| would be an invalid name for an enum class.

For the naming of the enum values refer to chapter \tqfullref{sec:EnumValues}.

\subsection{Names for Record Classes}\label{sec:NamesForRecordClasses}
A record class can implement an interface, like a regular class, so that the suffix ‘Impl’ would be valid in such case. But as record classes are implicitly \lstinline|final|, ‘Base’ is not permitted, as well as any other suffix indicating a class that should be extended.

Also a record class should not be named ‘Record’.

\subsection{Names for Annotations}\label{sec:NamesForAnnotations}
Annotations are a special type of an interface, distinguished by the “@” as the first character of their name. The remaining part of the name is determined by the rules for regular interfaces. Samples for valid names are \lstinline|@Text|, \lstinline|@Translation|, \lstinline|@Generated|\footnote{see \autocite{ORACLE_DOC_GENERATED_ANNOTATION}}, or \lstinline|@Deprecated|\footnote{see \autocite{ORACLE_DOC_DEPRECATED_ANNOTATION}}.

\section{Methods}\label{sec:NamesForMethods}
Method names have to be a verb plus one or more nouns indicating the object of the operation performed by the respective method, eventually combined with adjectives or additional verbs. The name will be in mixed or camel case with the first letter in lower case, and with the first letter of each internal word capitalized.

The name of a method has to describe what is does; a name like \lstinline|myMethod()| or \lstinline|doSomething()| are discouraged\footnote{Nevertheless, both are used throughout this document as sample names for methods, but just as a place holder for a meaningful method name, and definitely \textit{not} as an example for the naming of a method.}.

Chapter \tqref{sec:TheNamingDictionary} beginning on page \pageref{sec:TheNamingDictionary} contains the “Naming Directory” for method names; that is a list of verbs together with their implicit contract. It is highly recommended to refer to this list when searching a name for a new method.

Using digits in method names is acceptable were it makes sense; so using the digit '4' as replacement for the word “for”, and '2' for the word “to” is acceptable, but not really recommended. Remember that digits are not allowed as first characters of a method name.

Regarding to “Data Objects” there are two different schools: one supports the JavaBean\footnote{see \autocite{ORACLE_DOC_JAVABEANS}} approach, using explicit getter and setter methods:
\begin{lstlisting}[numbers=left,caption={JavaBean}]
class JavaBeanDO
{
    private Object m_Attribute;

    public final Object getAttribute() { return m_Attribute; }

    public final void setAttribute( final Object value )
    {
        if( isNull( value ) ) 
        {
            throw new NullArgumentException( "value" );
        }
        m_Attribute = value;
    }   //  setAttribute()
}
//  class JavaBeanDO
\end{lstlisting}

The other one is in favour of the Property concept, using two methods with the attribute name, but with different signatures as implicit getter and setter methods (here usually named as 'accessor' and 'mutator'):\footnote{I use the term \textit{POJO} (“Plain Old Java Object”) here only to distinguish this approach from a JavaBean; usually, POJOs do not make any assumption about the naming of their methods. This means that a real POJO can have getters and setters, too.}

\begin{lstlisting}[numbers=left,caption={POJO}]
public class PropertyDO
{
    private Object m_Attribute;

    public final Object attribute() { return m_Attribute; }

    public final void attribute( final Object value )
    {
        if( isNull( value ) ) 
        {
            throw new NullArgumentException( "value" );
        }
        m_Attribute = value;
    }	//	attribute()
}
//  class PropertyDO
\end{lstlisting}

Both approaches do have their merits and pitfalls, and at the end of days both will do the job. Even in the Java API itself you may find samples for both approaches.

In the Java world, the JavaBean concept is more widely accepted, and it is better supported with tools, but if seen over all languages, the property concept is more popular.

\section{Local Variables}\label{sec:NamesForLocalVariables}
The identifier names for local variables are in mixed case, with a lowercase first letter. Internal words start with capital letters. The names should not contain underscore (“\_”) or dollar sign (“\$”) characters, even though both are allowed by the language specification; they also should not start with those characters. Digits are forbidden as first characters already by the language specification, but perfectly allowed as additional characters. But they should be used with care and only were necessary.

Variable names should be short yet meaningful – with a clear priority on being meaningful. The choice of a variable name should be mnemonic – that is, designed to indicate the intent of its use to the casual observer. As for class names, abbreviations and acronyms should be avoided. Using the digit '4' as replacement for the word “for”, and '2' for the word “to” is acceptable, but not really recommended.

In case the first part of the variable name has to be an acronym, it will be written with all lower case:
\begin{lstlisting}
String htmlHeader; // OK
\end{lstlisting}
instead of
\begin{lstlisting}
String hTMLHeader; // AVOID!
\end{lstlisting}

Also one-character variable names should be avoided except for temporary “throwaway” variables. Some of these are widely used and have already a fixed meaning; so is \lstinline|i| very common for the run value of a classical \lstinline|for| loop:
\begin{lstlisting}
for( var i = 0; i < max; ++i )
{
    …
}
\end{lstlisting}

\lstinline|e| is the common name for the exception in a \lstinline|catch| block:
\begin{lstlisting}
try
{
    …
}
catch( final IOException e )
{
    //---* Handle the exception *------------------------------------
    …
}    
\end{lstlisting}

For temporary strings, \lstinline|s| is common, as \lstinline|o| is for (temporary) objects of an unspecified type.

Some names are fixed: the name of the value that is returned from a method has to be \lstinline|retValue| if the method does not return a field or attribute:
\begin{lstlisting}
// OK
public final int getValue() { return m_Value; }

// RECOMMENDED
public final int signum( double d )
{
    var retValue = 0;
    if( d < 0.0 )
    {
        retValue = -1
    }
    else
    {
        retValue = 1;
    }

    return retValue;
}   //  signum()

// ACCEPTABLE
public final int signum( double d )
{
    return (d < 0.0) ? -1 : ((d > 0.0) ? 1 : 0);
}   //  signum()

// AVOID!! Use 'retValue' instead of 'i'!!
public final int signum( double d )
{
    final var i = (d < 0.0) ? -1 : ((d > 0.0) ? 1 : 0);
    return i;
}   //  signum()
\end{lstlisting}

A temporary buffer is named \lstinline|buffer|, no matter if it is a \lstinline|java.lang.StringBuilder| or \lstinline|java.lang.StringBuffer|, an implementation of \lstinline|java.util.List|, another collection type, or any other type that can be used as a buffer.

Do not use the names \lstinline|in|, \lstinline|out|, and \lstinline|err|. Although these are not reserved words, they should be treated as such, as it would allow to statically import the default streams from the class \lstinline|java.lang.System|.

Usually you would use the singular form for a variable name, but for collections or arrays, the plural form can be perfectly correct:
\begin{lstlisting}
final Collection<Component> values = m_Components.values();
for( final Component value : values )
{
    …
}    
\end{lstlisting}

Using the class name (with a lower case first letter, of course) for a variable is completely acceptable in case this is sufficient to explain the function of the variable; but the prefix “my” has to be avoided.
\begin{lstlisting}
// RECOMMENDED
public final String retrieveMessage( final String messageKey, 
    final String... additionalInfo )
{
    final MessageProvider messageProvider = getMessageProvider();
    final String rawMessage = 
        messageProvider.getMessage( messageKey );
    final var retValue = String.format( rawMessage, additionalInfo );
    return retValue;
}   //  retrieveMessage()

// AVOID!!!! Don't use "my..." prefix!!!
public final String retrieveMessage( final String string, 
    final String... strings )
{
    final MessageProvider myMessageProvider = getMessageProvider();
    final String s = myMessageProvider.getMessage( string );
    final var retValue = String.format( s, strings );
    return retValue;
}
\end{lstlisting}

Sometimes it is also a good idea to use the class name of the type as a suffix or prefix for the name, especially if the current block declares more than one variable of that type. In such a case, the rest of the name could be used to indicate how variables belong together.
\begin{lstlisting}
// RECOMMENDED
public final ResultData callSpecialService()
{
    SpecialClientAgent clientAgent = obtainClientAgent();
    …
}   //  callSpecialService()

// AVOID!!!! Don't use "my..." prefix!!! And don't abbreviate!
public final ResultData callSpecialService()
{
    SpecialClientAgent myCA = obtainClientAgent();
    …
}   //  callSpecialService()

// RECOMMENDED
public final ResultData loadData( Connection connection, … )
{
    …
    final Statement customerStatement = …
    final Statement orderStatement = …

    …

    final ResultSet customerResultSet = customerStatement.execute();
    …

    final ResultSet orderResultSet = orderStatement.execute();
    …
}   //  loadData()
\end{lstlisting}

Do not (never!) use a prefix to indicate the type of a variable (Hungarian notation)! Java is a strongly typed language and the compiler will take care that variables are only used according to their types.\footnote{The use of the Hungarian notation for the naming of variables is discouraged for strongly typed languages like Java or C++, because it does not provide any benefit.\newline For languages like C, JavaScript or also Groovy, this may be different: for these languages the type prefix may help the programmers to assign the semantically correct type to a variable when syntactically any (or most) types are correct.\newline The use of the \lstinline|var| keyword in Java programs does not weaken the strong typing of Java in any way.}

Local variables inside lambdas are just like any other local variable and their naming follows the same rules. The only exception is that a lambda does not use \lstinline|retValue| for a return value – refer chapter \tqfullvref{sec:LambdaResults} for the details.

\section{Parameters}
The names for formal parameters of methods and constructors are different from those for lambdas.
\subsection{Names for formal Parameters of Methods and Constructors}\label{sec:NamesForFormalParameters}
The names for the formal parameters of a method or a constructors follow the same rules as for local variables. Especially they do \textit{not} have any prefix.

The parameters that are used to initialise a field should have the same name as that field, but without the “m\_” prefix:
\begin{lstlisting}
public final class MyClass
{
    private String m_Name;
    
    public MyClass( final String name )
    {
        m_Name = name;
    }   // MyClass()
    
    public final void setName( final String name )
    {
        m_Name = name;
    }   //  setName()
}
//  class MyClass
\end{lstlisting}

\subsection{Names for Lambda Parameters}\label{sec:NamesForLambdaParameters}
A typical lambda in Java looks like this:
\begin{lstlisting}
Predicate<String> filter = s -> !s.contains( "invalid" );
\end{lstlisting}
\lstinline|s| is the parameter of that lambda, and that these parameters have just single character names is common practice. As lambdas are usually quite short, this works sufficiently in most cases. In addition the meaning of the parameters is well explained through the documentation of the functional interface that is implemented by the lambda.

But if in doubt, you can use longer names with more meaningful names for the parameters of a lambda. The only constraint is that it should be clear what the parameter is, and what is injected to the lambda from the context:
\begin{lstlisting}
// WILL NOT WORK AT ALL!!
final var s = "invalid";
Predicate<String> filter = s -> !s.contains( s ); // Hä?

// Still not good …
final var s = "invalid";
Predicate<String> filter = p -> !p.contains( s );

// Better …
final var s = "invalid";
Predicate<String> filter = toCheck -> !toCheck.contains( s );

// Recommended
final var criterion = "invalid";
Predicate<String> filter = s -> !s.contains( criterion );
\end{lstlisting}

It does not make much difference if you number the parameters, of if you use different names fo them:
\begin{lstlisting}
BiPredicate<String,String> filter = (s1,s2) -> s1.contains( s2 );
BiPredicate<String,String> filter = (a,b) -> a.contains( b );
\end{lstlisting}

Nevertheless, an accepted rule of thumb is to use different names if the parameters cannot be exchanged by each other (as in the sample above), while numbering the parameters is used when the parameters are interchangeable, like in an implementation of \lstinline|java.util.Comparator|:
\begin{lstlisting}
Comparator<String> comparator = (s1,s2) -> s1.compareToIgnoreCase( s2 );
\end{lstlisting}

\section{Fields}\label{sec:Fields}
The name for fields (also referred to as ‘attributes’ or ‘properties’) are prefixed with “m\_”; the first letter after the underscore has to be a capital letter:
\begin{lstlisting}
private String m_AString;
private boolean m_IsValid;
private String m_HTMLHeader;
private MessageProvider m_MessageProvider;
\end{lstlisting}
This warrants that the names of local variables and formal parameters of methods or constructors will be always distinct from those of fields, and therefore neither local variables nor parameters can collide with or hide fields. Another consequence is that it is not necessary to use \lstinline|this.| when accessing a field.

Aside this, anything else that was said about the naming of local variables in chapter \tqref{sec:NamesForLocalVariables} is also valid for the naming of fields.

Please be aware that a bean property name does not carry the prefix. So the getters for the samples above are
\begin{lstlisting}[numbers=left]
public final String getAString() { return m_AString; }
public final boolean getIsValid() { return m_IsValid; }
/* Alternatively: */ public final boolean isValid() { return m_IsValid; }
public final String getHTMLHeader() { return m_HTMLHeader; }
public final MessageProvider getMessageProvider() { return m_MessageProvider; }
\end{lstlisting}
Regarding the alternative getter in line~3 refer to \autocite{ORACLE_DOC_JAVABEANS:Chapter8_3_2}.

Eclipse knows a configuration setting for this prefix (\verb#Window|Preferences|Java|Code Style#). Setting the prefix list there to “m\_” makes sure that the generation of getters and setters will work as expected.

For IntelliJ~IDEA, a similar setting can be found at \verb#File|Settings#, where you select under \verb#Editor|Code Style|Java# the tab \verb#Code Generation#.

\section{Constants}\label{sec:Constants}
Constants are fields of primitive or immutable types that are declared as \lstinline|public static final|. According to the Sun coding conventions, their names “should be all uppercase with words separated by underscores (‘\_’)”\autocite{SUN_CODE_CONVENTIONS:NamingConventions}.

Our definition for a constant is even more restrictive: that \lstinline|public static final| field has to be initialised with a compile-time constant value. This basically limits constants to “magic numbers”, static configuration values and texts.

Some samples for valid constants:
\begin{lstlisting}
public static final double PI = 3.1415;
public static final int ANSWER_TO_ALL_QUESTIONS = 42;
public static final String ISO_DATE_FORMAT = "yyyyMMdd'T'hhmmss";
public static final String [] EMPTY_STRING_ARRAY = new String [0];
\end{lstlisting}
Real constants go to the part of the class headlined with “Constants” (refer to chapter \tqvref{sec:StructuringComments}).

The field \lstinline|PATTERN| below is not a constant in the sense of this definition:
\begin{lstlisting}[numbers=left]
public static final Pattern PATTERN = Pattern.compile( ".*" );

// Better:
public static final Pattern PATTERN;

static
{
    try
    {
        PATTERN = Pattern.compile( ".*" );
    }
    catch( final PatternSyntaxException e )
    {
        throw new ExceptionInInitializerError( e );
    }    
}

// Even better:
public static final String PATTERN_SOURCE = ".*";
…
private static final Pattern m_Pattern;

static
{
    try
    {
        m_Pattern = Pattern.compile( PATTERN_SOURCE );
    }
    catch( final PatternSyntaxException e )
    {
        throw (ExceptionInInitializerError) new ExceptionInInitializerError( "Compilation of '%s' failed".formatted( PATTERN_SOURCE ).initCause( e );
    }    
}
\end{lstlisting}
No matter which variant you go for, the declaration and initialisation have to go to the part “Static Initialization”.

\lstinline|static final| references to \textit{mutable} objects are no constants (no matter which definition you use), therefore they should never be \lstinline|public| – with the final consequence that they are just fields – so refer to chapter \tqref{sec:Fields} for their naming.

Samples for fields that are not feasible as \lstinline|public| constants are (as the objects are not constant at all):
\begin{lstlisting}[numbers=left]
// AVOID!! Make it private!
public static final Map<String,File> m_Files = new TreeMap<String,File>();

// AVOID!! Make it private!
public static final Date BEGIN_OF_EPOCHE = new Date( 0 );

// AVOID!! Make it private!
public static final SimpleDateFormat ISO_DATE_FORMATTER = new SimpleDateFormat( ISO_DATE_FORMAT );
\end{lstlisting}

If you wonder why the lines~5 and 8 belongs to this group of bad samples, refer to \autocite{ORACLE_DOC_DATE_CLASS,ORACLE_DOC_SIMPLEDATEFORMATTER_CLASS}: instances of \lstinline|java.util.Date| and \lstinline|java.text.SimpleDateFormatter| are not immutable!\footnote{In addition, the class \lstinline|java.util.Date| and the tools around it were superseded by the \lstinline|java.time| package (see \autocite{ORACLE_DOC_TIME_PACKAGE}) and should not be used anymore.}

Sometimes you may have classes or groups of constants (e.g. the tags in an XML document, the column names of a database table, or message texts). It has proved to help with the readability of the code if this is reflected in the names. For the column names of the table \verb#PERSON#, the constants may be defined as shown here:
\begin{lstlisting}
public final static String PERSON_COL_FirstName = "first_name";
public final static String PERSON_COL_LastName = "last_name";
…
\end{lstlisting}
The camelCased suffix is the ‘real’ name, while the part that follows the stronger rules for a constant name is just indicating the “constant category”.

\section{enum Values}\label{sec:EnumValues}
When the Sun coding conventions\autocite{SUN_CODE_CONVENTIONS} had been written in 1999, enums did not yet exist in Java. But enum values are special cases of constants, the usual assumption is that their names have to follow the same rules as for normal constants: the name should be all upper case with words separated by underscores (“\_”).

Basically, this works fine, but when using \lstinline|static| imports, you may get name clashes for common terms that can be used in different contexts. So it will make sense to add a prefix to the name of an enum, similar to what we did with the categories or groups for regular constants. This may look like this:
\begin{lstlisting}
enum Direction
{
    DIR_LEFT,
    DIR_RIGHT;
}   //  enum Direction

enum Alignment
{
    ALIGN_CENTER,
    ALIGN_LEFT,
    ALIGN_RIGHT;
}   //  enum Alignment
\end{lstlisting}
Using the prefix would allow now to use the values with static imports of their classes; otherwise, they have to be used with their class names as prefix.

Alternatively, you can use this:
\begin{lstlisting}
enum Direction
{
    DIR_Left,
    DIR_Right;
}   //  enum Direction

enum Alignment
{
    ALIGN_Center,
    ALIGN_Left,
    ALIGN_Right;
}   //  enum Alignment
\end{lstlisting}
Again the camelCased suffix is the “name” itself, while the “proper” typed prefix is just the category. This is recommended if the suffix consists of multiple words that otherwise require additional underscores.

\section{Type Arguments}\label{sec:TypeVariables}
Type arguments belong to the definition of parameterised types \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ParameterizedTypes} or “generics”. So in
\begin{lstlisting}
public interface Function<T,R> {…}
\end{lstlisting}
\lstinline|T| and \lstinline|R| are the type arguments.

It is commom practice to name a single type argument as \lstinline|T|. If there are more than one type arguments, the name \lstinline|R| is usually used for the return type. Also often used are \lstinline|V| as the name for a value type and \lstinline|K| for the name of the type for a key, \lstinline|E| as the name for the type of an entry to a list or set or for an exception type.

Aside that, no further rules exist. Even more than one character is possible for the name of a type argument: \begin{lstlisting}
public interface Map<Key,Value> {…}
\end{lstlisting}
is absolutely valid, although not common. 

But because the type arguments denotes classes, their names have to start with a capital letter.

\chapter{Writing proper Comments}\label{sec:WritingProperComments}
Comments are crucial for the understanding of source code, in any programming language. Source code without any comments is not maintainable, meaning it is worthless in the long run.

In addition, Java also provides a tool that allows to externalize program comments, so that they can be used as the external documentation; the name of this tool is \textit{JavaDoc}. The “Javadoc Guide”\autocite{ORACLE_DOC_JAVADOC_GUIDE} provides an overview of the tool\footnote{see \autocite{ORACLE_DOC_JAVADOC_MAN} on how to invoke the tool on your source code}, the “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG} explains how to write the comments for a proper documentation generated with the JavaDoc tool.\footnote{JavaDoc is not the only tool for this purpose; another well known tool is Doxygen\autocite{DOXYGEN_HOMEPAGE} that was created primarily to generate the documentation for annotated C++ code, but it works also for Java, C and several other programming languages. But for Java sources, JavaDoc is the preferred tool.}

So Java source code can generally have three kinds of comments:
\begin{itemize}[nosep]
\item{documentation comments}
\item{implementation comments}
\item{maintenance comments}
\end{itemize}
In Java, the \textit{documentation comments} (also known as “doc comments” or “the JavaDoc”) are delimited by “/**…*/” and cannot be placed everywhere; they will be externalised for the generation of the program/library documentation. Obviously, \textit{implementation comment}s are the other comments, that are not externalized and published.

\textit{Maintenance comments} are technically a special form of implementation comments, but as the have a special function, they are covered separately (see chapter \tqfullvref{sec:MaintenanceComments}).

Roughly, the documentation comments describe how to use the code (the API), unrelated to the implementation, while the implementation comments describe what the code is doing and why.

Comments should be used to give overviews of code and provide additional information that is not readily available in the code itself. Comments should contain only information that is relevant to reading and understanding the program. For example, information about how the corresponding package is built or in what directory it resides should not be included as a comment to a class.

Discussion of non-trivial or non-obvious design decisions is appropriate, but avoid duplicating information that is present in (and clear from) the code. It is too easy for redundant comments to get out of date. In general, avoid any comments that are likely to get out of date as the code evolves.

The frequency of comments reflects poor quality of code. Unfortunately, code can be “under-commented” or “over-commented”, meaning there is a “frequency band” for comments that has to be hit for good quality code.

One often heard advice is: “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” But clearer to whom?

With increasing programming experience, things get more and more obvious to the programmers, so they write lesser comments – with the result, that newbies do not have any help to understand the code written by the experts.

Obviously, the advice: “Even if you don't think, a comment might be necessary, add it nevertheless” is the other extrema and equally bad, so writing proper comments remains a complex art, but it follows some rules, and for the rest, we will give some advice. Refer to chapter \tqfullvref{sec:CommentsWhen} where this is discussed further.

In general:
\begin{itemize}
\item{Comments should not be enclosed in large boxes drawn with asterisks or other characters, with the exception of structuring comments as described below.}
\item{Comments should never include special characters such as tabulator, form-feed and backspace or alike. In JavaDoc comments only (see below), most other non-ASCII characters should be escaped with their HTML equivalent.}
\item{While code lines can have any length, comment lines will always end in or before column 80, except when their contents cannot be wrapped (like URLs for references to additional information).}
\item{Comments should be in full sentence and using a clear language.}
\item{Finally: all comments has to be in English language; they should be grammatically correct and without typos.\footnote{… but it is still much more important that there is at least \textit{some} comment than a correctly spelled one.}}
\end{itemize}

\section{Documentation Comments}\label{sec:DocumentationComments}
It is a well known fact that most programmers are poor technical writers. That's the reason why programmers rarely write the public documentation for their product.

But that is no excuse why programmers do not write proper documentation comments into their source code. They are the only people that could write that comments because technical writers usually do not have the time to analyse the code to extract the information from it that is necessary for the documentation.\footnote{In addition, the technical writers usually do not have (write) access to the source code, and me personally, I believe that most technical writers are not good enough programmers to be able to do that code analysis, at least not in a timely manner.}

In general there are (at least) two different target groups for the documentation that is generated from the documentation comments. The first group are the maintenance programmers, the second are programmers writing code interfacing with this one, using the public APIs. This means that each program element that can have a documentation comment must have a documentation comment! No exception! No excuse for missing documentation comments! The programmer must provide a documentation comment wherever it is possible. 

Eclipse can be configured in a way that it will issue warnings or even errors for missing documentation comments: see \verb#Window|Preferences|Java|Compiler|Javadoc#.

To achieve the same for IntelliJ IDEA, you go to \verb#File|Settings#, and there you select \verb#Editor|Inspections>Java>Javadoc#.

Documentation comments describe Java modules, packages, classes\footnote{All types of \textit{classes}, including \textit{interfaces}, \textit{enums}, \textit{records} and \textit{annotations}}, constructors, methods, and fields\footnote{All types of fields: \textit{attributes}, \textit{constants}, but also the \textit{enum values}}. Each documentation comment is set inside the comment delimiters “/**…*/”, with one comment per module, package\footnote{The documentation comment for a Java package is special; refer to chapter \tqfullvref{sec:PackageDocumentation} for the details}, class, or member. This comment has to appear just before the declaration:

\begin{lstlisting}
/**
 *  The Example class provides …
 */
public class Example
{
    /**
     *  The inner class provides …
     */
    private static class InnerClass
    {
        …
    }
    //  class InnerClass
     
    …
    
    /**
     *  This flag …
     */
    private boolean m_Flag;
    …

    /**
     *  Method that performs some action …
     *
     *  @param  arg   The argument.
     */
    public final void method( int arg )
    {
        …
    }   //  main()
}   //  class Example
\end{lstlisting}

The first line of the documentation comments (“/**”) for top level classes is not indented; subsequent lines for the documentation comment have one space of indentation (to vertically align the asterisks). All members, including inner classes, have 4 spaces for the first documentation comment line and 5 spaces thereafter (this is congruent for inner classes).

If you need to give information about a class, interface, variable, or method that isn't appropriate for the public documentation, use an implementation comment immediately after the declaration. For example, internal details about the implementation of a class should go in such an implementation block comment following the class statement, not in the class documentation comment.

Documentation comments should not be positioned inside a method or constructor definition block, because Java associates documentation comments with the first declaration after the comment.

\subsection{Structure and Contents}\label{sec:StructureAndContents}
Latest since the introduction of Java~9, the JavaDoc tool produces (more or less) correct HTML~5 documents from the JavaDoc comments in the source code. Therefore it is strongly recommended to use correct HTML~5 syntax inside the documentation comments itself. This means that tags has to be closed properly, empty tags like \lstinline|<br>| and \lstinline|<img>| are not closed, and so on.

If the comment has more than one single paragraph, use the \lstinline|<p>| tag; do not use the \lstinline|<br>| tag:

\begin{lstlisting}
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The first sentence of each JavaDoc comment is taken to be placed on an overview. Per default, that sentence is defined as everything from the beginning until the first full stop followed by a blank (“. ”) or other whitespace, or the first not-inline HTML tag.

This means that a comment like this

\begin{lstlisting}
// AVOID!!
/**
 *  <b>Returns the status for this operation.</b>
 *
 *  …
 */
\end{lstlisting}

may cause some strange output\footnote{Writing the comment like that (with the \lstinline|<b>…</b>| tag) should be avoided anyway.}. Java~10 introduced the JavaDoc tag \nameref{sec:TagSummary} to address issues like this; it allows the programmer to explicitly specify what portion of the JavaDoc comment appears in the overview rather than relying on JavaDoc's default behaviour to determine the summary portion of the comment. Refer to \autocite{ORACLE_DOC_JAVADOC_TAG,DZONE_JAVADOC_SUMMARY} for the details and additional samples.

The \nameref{sec:TagSummary} tag has to be used always when a documentation comment has more than one sentence:

\begin{lstlisting}
// OK – as single sentence
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
// AVOID!! – Two sentences. 
/**
 *  <p>Returns the status for this operation. The return value will 
 *  never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

// RECOMMENDED
/**
 *  <p>{@summary Returns the status for this operation.} The return 
 *  value will never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>{@summary Returns the status for this operation.}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The documentation comments for modules, packages and classes may get longer, so that you want to structure it by giving headlines to sections. Usually this is done through the HTML tag \lstinline|<h#>|, with \# being a number in the range from 1 to 6. You can use these tags in the documentation comments, too, but the tags \lstinline|<h1>| and \lstinline|<h2>| are already used by JavaDoc itself; that means that you should only use \lstinline|<h3>| to \lstinline|<h6>| in the documentation comments.\footnote{In the overview comment (refer to chapter \ref{sec:OverviewComment}), you can make use of the all the \lstinline|<h#>| tags to structure that comment.}

When a class, method, constant, field is mentioned the first time in a documentation comment, its documentation should be linked, using the \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tags. This is not necessary if the type is used for a formal parameter or the return value. In these cases, JavaDoc generates these links automatically.

Each \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tag has to placed into a line of its own.

Some examples:
\begin{lstlisting}
/**
 *  <p>{@summary Searches the given key in the list and returns the
 *  associated data.} If the key is
 *  {@linkplain String#isBlank() blank},
 *  the method will throw a
 *  {@link BlankArgumentException},
 *  while an empty will just not return a result.</p>
 *
 *  @param  key The key.
 *  @returns An instance of
 *      {@link Optional}
 *      that holds the search result.
 *  @throws IllegalArgumentException    The key is somehow invalid.
 *
public final Optional<Data> searchData( final String key ) { … }
\end{lstlisting}

JavaDoc creates links to the documentation of \lstinline|java.lang.IllegalArgumentException|, \lstinline|java.lang.String| and \lstinline|Data| automatically; it also creates a link to \lstinline|java.util.Optional| but it is recommeded to use the pattern shown here, even when this means that the comment holds two links to the \lstinline|Optional| class documentation.

The names of classes, methods, constant, fields, parameters etc. as well as \lstinline|null|, \lstinline|true|, and \lstinline|false| have to be written in a monotype font. This can be achieved by encapsulating them in \lstinline|<code>…</code>| HTML tags or placing them inside the JavaDoc \nameref{sec:TagCode} tag. The monotype font is used automatically for everything inside a \nameref{sec:TagLink} tag.

Each comment, including each text for a \nameref{sec:TagParam}, \nameref{sec:TagReturn}, and \nameref{sec:TagThrows} tag, ends with a full stop.

The document “How to Write Doc Comments for the Javadoc Tool”\autocite{ORACLE_DOC_JAVADOC_HOWTO} is already a little bit older and therefore outdated in parts, but it still provides some useful hints on how to write proper documentation comments that should be processed by the JavaDoc tool.

\subsubsection{The Overview Comment}\label{sec:OverviewComment}
When the JavaDoc tool is called with the option \verb#-overview <filename># (see \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}), an ‘Overview’ comment is  added to the generated documentation. \verb#<filename># is the (fully-qualified)  filename of a valid HTML~5 document (The recommended name is \verb#overview.html#) containing general information about the project.

You can put nearly everything here, from the project's history to manual on how to use the program or library, but you should not reproduce information that is given in the module, package, or class documentation comments.

Several JavaDoc tags can be also used in the overview comment; for details refer to the chapter "Where Tags Can Be Used" in \autocite{ORACLE_DOC_JAVADOC_TAG}.

\subsubsection{The module Comment}\label{sec:ModuleComment}
The \verb#<module description># (refer to chapter \tqfullref{sec:ModuleDefinition}) describes the current module, its dependencies and what it provides. See the JavaDoc tags \nameref{sec:TagProvides} and \nameref{sec:TagUses} for details.

If the project has just one module, the module comment can replace the overview comment.

\subsubsection{The package Comment}\label{sec:PackageComment}
Each and every Java package has to have a file named \verb#package-info.java#; the structure of that file was already discussed in chapter \tqfullvref{sec:PackageDocumentation}.

The \verb#<package description># provides information about the package. So it describes the purpose of the classes in this package. It lists conventions that are common for all contained classes, it should specify their prerequisites.

If the package defines a single API, it can describe the usage of that API, too. 

The package comment can list the authors of the code, using the \nameref{sec:TagAuthor} tag\footnote{Or the tag \nameref{sec:TagExtAuthor}, refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc})}, the version with the \nameref{sec:TagVersion} tag, when the package was created or with which version it was integrated with the \nameref{sec:TagSince} tag, and other things.

It should not repeat details that are written already in the documentation of a class in that package, instead it should reference that class documentation. If those details are  important for the whole package, it should be considered to move them from the class comment to the package description and place a reference into the class documentation instead.

The package comment for the main package of a project can replace the overview comment (if not the module comment is used for this\footnote{Not all projects will produce modules, so it is possible that your project does not have a module definition file at all.}).

\subsubsection{The class Comment}\label{sec:ClassComment}
The documentation comment for a class, an interface, an enum, a record or an annotation (the ‘class comment’) describes that class, its purpose and its usage. If the class is not \lstinline|final|, the comment should provide some hints what the mount points\footnote{Another term for “mount point” is “extension point”, but I do not like this expression as we do not always “extend” a class on these points. Most often we replace existing behaviour to customise the class to our needs.} are and how to utilise them.

Then the class comment should list the authors of the class, using the \nameref{sec:TagAuthor} tag, the class version (using the \nameref{sec:TagVersion} tag), and when the class was added to the project with the \nameref{sec:TagSince} tag\footnote{Although this can be omitted if this information is already given within the package.}.

In case of a parametrised type (a ‘generic’), it contains a \nameref{sec:TagParam} tag for each formal parameter.

Here a real life sample for an interface:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object). It is based on sample code from the book &quot;Java
 *  Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @author Thomas Thrien - thomas.thrien@pega.com
 *  @version <version information>
 *  @since 1.2.3
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}

The \verb#<version information># should be a reference to the version in the SCCS; if you are using Subversion, that line would look like this:
\begin{lstlisting}
/**
 …
 *  @version $Id:$
 …
 */
\end{lstlisting}

I also recommend to use the custom tags provided by the “Foundation JavaDoc” project\autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC} (see chapter \tqfullvref{sec:CustomTagsForJavaDoc}); then the same class documentation comment would look this:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object).
 * 
 *  @inspired &quot;Java Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @extauthor Thomas Thrien - thomas.thrien@pega.com
 *  @version $Id:$
 *  @since 1.2.3
 *
 *  @UMLGraph.link
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}
The tag \nameref{sec:TagExtAuthor} is an enhanced replacement for the \nameref{sec:TagAuthor} tag, and the tag \nameref{sec:TagUMLGraph} places an UML diagram for the current class to the generated documentation.

\subsubsection{The Field Comment}\label{sec:FieldComment}
Attributes/properties, constants and enum values are all summarised under ‘fields’ here.

Each and every field will have a comment, the ‘field comment‘, describing it. For \lstinline|private| fields it can be sufficient to refer to the related getter method instead of writing a lengthy comment into the field comment itself; do not use the \nameref{sec:TagSee} tag instead of the \nameref{sec:TagLink} tag:
\begin{lstlisting}
/**
 *  Refer to
 *  {@link #getValue()}.
 */
private final Value m_Value;

// AVOID!!
/**
 *  @see #getOtherValue()}.
 */
private final Value m_OtherValue;
\end{lstlisting}

If there is no getter method for a field, or it is not \lstinline|private|, a description is mandatory. Usually one sentence might be sufficient, although \lstinline|public| constants may require a full fledged usage description if that is not given elsewhere (for example, in the class comment or the package comment) and a reference to that description could be placed here.

It is always a good idea to describe the valid values for the field, its default value, and if \lstinline|null| is a possible value for a reference. This is a must for non-\lstinline|final| \lstinline|public| or \lstinline|protected| fields.

For a serialisable class, the fields that will be serialised should be tagged with \nameref{sec:TagSerial} and the appropriate description.

Constants (\lstinline|public static final| fields) that are initialised with a literal have to use the \nameref{sec:TagValue} tag in there description. Also \lstinline|private static final| or \lstinline|protected static final| fields that are initialised with a literal should use the \nameref{sec:TagValue}.

This looks like this:
\begin{lstlisting}
/**
 *  The vested system property for the file encoding used by the JVM:
 *  {@value}.
 */
public static final String PROPERTY_FILE_ENCODING = "file.encoding";
\end{lstlisting}

The comments for enum values are nothing else than field comments for constants – in fact, an enum value is exactly that: a \lstinline|public static final| field initialised with an instance of the enum type.

\subsubsection{The Method Comment}\label{sec:MethodComment}
The documentation comment for a method describes its usage and its function within the class, together with its arguments, the return value, and any exception it may throw.

For each method parameter there have to be a \nameref{sec:TagParam} tag that describes it in detail (if not already described in the main text of the method comment; in that case, a short sentence should be sufficient). The description has to cover the function of the parameter, its value range, and whether the parameter can be \lstinline|null|. Usually, \lstinline|null| is an invalid parameter value per default, so it has to be mentioned in the respective comment if it is allowed.

It is not enough to only give the type of the parameter in the comment; in fact, this is obsolete as it can be easily taken from the method's signature.

Usually, the return value (given the method is not of type \lstinline|void|) will be described in the comment for the \nameref{sec:TagReturn} tag; the tag is mandatory, and with some text, even if the return value is described already in the method description itself. The description for the return value should provide the possible values and there meanings, whether \lstinline|null| is a valid return value, and so on. 

In particular, the comment for the \nameref{sec:TagReturn} tag has to describe which return values indicate special or error conditions.

It is obsolete to give the type of the return value here; it can already be seen from the method's declaration.

Next there has to be a \nameref{sec:TagThrows} tag for each checked exception that may be thrown by the method, describing the condition that may trigger that exception. It is also possible to add \nameref{sec:TagThrows} clauses for unchecked exceptions, but not required. Refer to chapter \tqfullvref{sec:GeneralExceptionHandling} for additional details on exception handling.

A method that implements an interface method or that overrides a method from a base class be commented with the \nameref{sec:TagInheritDoc} tag instead of writing a full comment. The tag can be combined with additional text, too.

The documentation comment for a non-\lstinline|final| \lstinline|public| or \lstinline|protected| method has to provide detailed information when and how it has to be overwritten; especially if the overriding method has to call the super implementation and when:\footnote{Usually you should avoid the requirement for calling the super implementation, but that is not always appropriate or possible; refer to chapter \tqref{sec:NonFinalMethods} about some more details.}.

A comment for that case may look like this:\footnote{The tag @note is a custom tag; refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc}}
\begin{lstlisting}
/**
 *  …
 *
 *  @note Call this implementation {before|after} your code, to make
 *      sure that the initialisations provided here are performed.
 *
 *  …
 */
\end{lstlisting}

For more details on this refer to chapter \tqfullvref{sec:ExtendingClassesOverridingMethods}.

Usually, the documentation comment for a method does not reveal details about the method's implementation, but in case of empty “place holder methods” or mount points, a sentence like below does not harm.
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 */
\end{lstlisting}

If such a method has a dummy or default return value, there has to be an appropriate \nameref{sec:TagReturn} tag, specifying that value:
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 *  @return Always <the default value>.
 */
\end{lstlisting}
 
Finally it is absolutely crucial that the documentation comment provides all information about possible side effects of a call to the method, even more when these side effects are unexpected.

\subsubsection{The Constructor Comment}\label{sec:ConstructorComment}
Basically, a constructor is a special kind of a method, so the same rules are valid for the documentation comment for a constructor than for the documentation comment for a method, as given in chapter \tqref{sec:MethodComment}.

For an empty default constructor, the constructor comment may be as simple as this, no matter if it is \lstinline|public|, \lstinline|private|, or \lstinline|protected|:
\begin{lstlisting}
/**
 *  Creates a new {@code MyClass} instance object.
 */
public MyClass() { /* Does nothing */ }
\end{lstlisting}
or
\begin{lstlisting}
/**
 *  Default constructor for class {@code MyClass}.
 */
private MyClass() { /* Does nothing */ }
\end{lstlisting}
with the first alternative being the preferred one; in fact, this comment can be used for every constructor, not only for the default ones.

Of course, these comments do not say very much, but the constructor is also not doing that much, and what it does is very obvious. But if it has side effects, these should be described properly.

A class that does have only \lstinline|static| methods\footnote{Such a class is called a “Utility Class”; refer to \tqfullvref{sec:UtilityClasses} for more details.} should have a \lstinline|private| constructor like this:\footnote{The \lstinline|Error| class is described in \autocite{TQUADRAT_ORG_FOUNDATION_PRIVATECONSTRUCTORFORSTATICCLASSCALLEDERROR}.}
\begin{lstlisting}
/**
 *  No instance is allowed for class {@code MyUtilityClass}.
 */
private MyUtilityClass() 
{ 
    throw new PrivateConstructorForStaticClassCalledError( MyUtilityClass.class); 
}   // MyUtilityClass()
\end{lstlisting}

If a constructor takes parameters, there has to be a \nameref{sec:TagParam} tag for each of them, exactly like for a method.

Although constructors should not throw (checked) exceptions, sometimes it could not be avoided without overcomplicating the API of a class. In such case, all exceptions has to be listed with the \nameref{sec:TagThrows} tag and a description of the conditions for the particular exception – as far as it is possible or make sense. Refer also to chapter \tqfullvref{sec:GeneralExceptionHandling} for some more details on exception handling.

\subsection{The JavaDoc Tags}\label{sec:JavaDocTags}
The next two chapters describe the tags that should be used in your documentation comments where appropriate.

One general rule for all JavaDoc tags: Do not insert line breaks between the parameters of a tag:
\begin{lstlisting}
// WRONG!!
/*
 *  …
 *  @param args
 *         The command line arguments
 *  @param  otherArg
 *          This parameter needs a very long explanatory comment that
 *          requires a line break.
 *  @throws IOException
 *          Reading the file failed.
 *  …
 */

// CORRECT:
/*
 *  …
 *  @param  args   The command line arguments
 *  @param  otherArg    This parameter needs a very long explanatory
 *      comment that requires a line break.
 *  @throws IOException Reading the file failed.
 *  …
 */
\end{lstlisting}

\subsubsection{The Standard Doclet Tags}
Most of the contents of this chapter was taken from the document “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG}. 

In the context of the JavaDoc tool, the interpretation of the content of a documentation comment is done by the implementation of the interface \lstinline|jdk.javadoc.doclet.Doclet|\footnote{Refer to \autocite{ORACLE_DOC_DOCLET_INTERFACE}.} interface that is used to process the comment. Other implementation may accept the same syntax as the standard doclet (provided through the class \lstinline|jdk.javadoc.doclet.StandardDoclet|\autocite{ORACLE_DOC_STANDARDDOCLET_CLASS}), or they may support an alternate syntax. However, due to the support by many tools, the syntax supported by the standard doclet has become a \textit{de facto} standard.

\paragraph{\lstinline|@author|}\label{sec:TagAuthor} Usage: \lstinline|@author <name-text>|

The tag adds an “Author” entry with the specified name text to the generated documents when the \verb#-author# option is used. A documentation comment can contain multiple \lstinline|@author| tags. Use the \nameref{sec:TagExtAuthor} tag instead.

\paragraph{\lstinline|@code|}\label{sec:TagCode}  Usage: \lstinline|{@code <text>}|

This is equivalent to \lstinline|<code>{@literal text}</code>|.

It displays text in the code font without interpreting the text as HTML markup or nested JavaDoc tags. This enables you to use regular angle brackets (< and >) instead of the HTML entities (\&lt; and \&gt;) in documentation comments, such as in parameter types (<Object>), inequalities (3 < 4), or arrows (->).

If you want the same functionality without the code font, then use the \nameref{sec:TagLiteral} tag. 

\paragraph{\lstinline|@deprecated|}  Usage: \lstinline|{@deprecated <text>}|

This tag is used in conjunction with the \lstinline|@Deprecated|\autocite{ORACLE_DOC_DEPRECATED_ANNOTATION} annotation to indicate that this API should no longer be used (even though it may continue to work).

The first sentence of the text should tell the user when the API was deprecated and what to use as a replacement. Subsequent sentences can also explain why it was deprecated.

A \nameref{sec:TagLink} tag that points to the replacement API should be added where feasible.

\paragraph{\lstinline|@docRoot|}  Usage: \lstinline|{@docRoot}|

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages.

\paragraph{\lstinline|@exception|} This is a synonym for \nameref{sec:TagThrows}; it should not be used.

\paragraph{\lstinline|@hidden|}  Usage: \lstinline|@hidden|

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all.

\paragraph{\lstinline|@index|}  Usage: \lstinline|{@index <word> <description>}| or \lstinline|{@index "<phrase>" <description>}|

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym.

\paragraph{\lstinline|@inheritDoc|}\label{sec:TagInheritDoc}  Usage: \lstinline|{@inheritDoc}|

Inherits (copies) the documentation comment from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text.

\paragraph{\lstinline|@link|}\label{sec:TagLink}  Usage: \lstinline|{@link <module/package.class#member> <label>}|

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. 

This tag is similar to the \nameref{sec:TagSee} tag. Both tags require the same references and accept the same syntax for \verb|<module/package.class#member>| and the label. The main difference is that the \lstinline|{@link}| tag generates an inline link rather than placing the link in the “See Also” section. The \lstinline|{@link}| tag begins and ends with curly braces to separate it from the rest of the inline text. If you need to use the right curly brace (“\}”) inside the label, then use the HTML entity notation \verb|&#125;|.

\paragraph{\lstinline|@linkplain|}\label{sec:TagLinkplain}  Usage: \lstinline|{@linkplain <module/package.class#member> <label>}|

Behaves the same as the \nameref{sec:TagLink} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text.

\paragraph{\lstinline|@literal|}\label{sec:TagLiteral}  Usage: \lstinline|{@literal <text>}| 

Same as the \nameref{sec:TagCode} tag, but the text is shown as plain text and not in the code font.

\paragraph{\lstinline|@param|}\label{sec:TagParam}  Usage: \lstinline|@param <parameter-name> <description>|

Adds a parameter with the specified parameter name followed by the specified description to the “Parameters” section. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets (“<…>”) around such a parameter name to indicate the use of a type parameter.

\paragraph{\lstinline|@provides|}\label{sec:TagProvides}  Usage: \lstinline|@provides <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document an implementation of a service that is provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider itself. 

\paragraph{\lstinline|@return|}\label{sec:TagReturn}  Usage: \lstinline|@return <description>|

Adds a “Returns” section with the description text to the documentation comment of a method.

\paragraph{\lstinline|@see|}\label{sec:TagSee}  Adds a “See Also” heading with a link or text entry that points to a reference. The \lstinline|@see| tag has three variations; see \autocite{ORACLE_DOC_JAVADOC_TAG} for the details.

\paragraph{\lstinline|@serial|}\label{sec:TagSerial} Used in the documentation comment for a default serializable field. See “Documenting Serializable Fields and Data for a Class”\autocite{ORACLE_DOC_OBJECT_SERIALIZATION:DocumentingSerializableFieldsData}. 

\paragraph{\lstinline|@since|}\label{sec:TagSince}  Usage: \lstinline|@since <since-text>|

Adds a “Since” heading with the specified \verb#<since-text># value to the generated documentation. The text has no special internal structure. This tag that this change or feature has existed since the software release specified by the \verb#<since-text># value, for example: \lstinline|@since 1.5|.

Although it would possible to provide a date or something else, it is recommended to always use a version number with the \lstinline|@since| tag.

\paragraph{\lstinline|@summary|}\label{sec:TagSummary}  Usage:  \lstinline|{@summary <text>}|

Identifies  the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content.

The \lstinline|{@summary}| tag has to be used always when a documentation comment has more than one sentence; see also chapter \tqvref{sec:StructureAndContents}.

\paragraph{\lstinline|@throws|}\label{sec:TagThrows}  Usage: \lstinline|@throws <class-name> <description>|

The \lstinline|@throws| tag adds a “Throws” subheading to the generated documentation, with the \verb#<class-name># and the description text. The class name is the name of the exception that might be thrown by the method, and the description provides information about the conditions for that exception to be thrown. 

\paragraph{\lstinline|@uses|}\label{sec:TagUses}  Usage: \lstinline|@uses <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available.

\paragraph{\lstinline|@value|}\label{sec:TagValue}  Usage: \lstinline|{@value}| or \lstinline|{@value <module/package.class#field>}|

This tag is used to display the values of constant in the generated documentation. When the \lstinline|{@value}| tag is used without an argument in the documentation comment of a \lstinline|static final| field, it displays the value of that constant:
\begin{lstlisting}
/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"
\end{lstlisting}

When used with the argument \verb|<module.package.class#field>| in any documentation comment, the \lstinline|{@value}>| tag displays the value of the specified constant:
\begin{lstlisting}
/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public final String evalScript( String script ) { … }
\end{lstlisting}
The argument \verb|<module.package.class#field>| takes a form similar to that of the \nameref{sec:TagLink}, the \nameref{sec:TagLinkplain}, or the \nameref{sec:TagSee} tag argument, except that the member must be a \lstinline|static final| field.

\paragraph{\lstinline|@version|}\label{sec:TagVersion}  Usage: \lstinline|@version <version-text>|

Adds a “Version” subheading with the specified \verb#<version-text># value to the generated documents when the \verb#-version# option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the \nameref{sec:TagSince} tag, which holds the release number where this code was introduced. The \verb#<version-text># value has no special internal structure.

\subsubsection{Custom Tags for JavaDoc}\label{sec:CustomTagsForJavaDoc}
You can define your own JavaDoc tags; simple tags can be defined on the commandline for the JavaDoc tool (see the option \verb#-tag# in \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}) or by implementing the interface \lstinline|jdk.javadoc.doclet.Taglet|\autocite{ORACLE_DOC_TAGLET_INTERFACE}.

I created a set of custom tags that I use regularly, and that I also recommend for your documentation comment. The respective library can be found at \autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC}.

\paragraph{\lstinline|@anchor|}\label{sec:TagAnchor}  Usage: \lstinline|{@anchor #<anchor-name> <text>}|

This tag allows to add an HTML anchor to the generated documentation, where \verb#<anchor-name># is the name of the anchor to the given text. The hash symbol (‘\#’) before the name of the anchor is mandatory!

\paragraph{\lstinline|@extauthor|}\label{sec:TagExtAuthor}  Usage: \lstinline|@extauthor <name-text> - <email-address>|

This is a replacement for the \nameref{sec:TagAuthor} tag that renders the given email address as \verb#mailto:# link in the generated documentation. It does not regard the \verb#-author# option\footnote{This is valid for version 0.1.0 of the library; it may have changed for a later version}. 

\paragraph{\lstinline|@href|}\label{sec:TagHref}  Usage: \lstinline|{@href <url> <text>}| or \lstinline|{@href <url>}|

With this tag, an HTML hyperlink can be added to the generated documentation; if will place inside the description text, but different from the \nameref{sec:TagLink} and \nameref{sec:TagLinkplain} tags, it allows to refer to arbitrary external resources, not only to other documented elements. Obviously, \verb#<url># is the target URL, while \verb#<text># is the clickable text. If the latter is omitted, the URL itself will be used instead.

\paragraph{\lstinline|@inspired|}\label{sec:TagInspired}  Usage: \lstinline|@inspired <text>|

Sometimes a piece of code was inspired by a document of some kind, a description of an algorithm, a product white paper, or whatever. This tag allows you to add a reference to that source of inspiration. 

\paragraph{\lstinline|@modified|}\label{sec:TagModified}  Usage: \lstinline|@modified <name-text> - <email-address>|

This is a variant of the \nameref{sec:TagExtAuthor} tag. It is meant to provide the name of the developer that modified the respective element without claiming to be an author.

\paragraph{\lstinline|@note|}\label{sec:TagNote}  Usage: \lstinline|@note <text>|

With this tag, it is easy to add important notes to the generated documentation for an element. All notes will be added to a bullet list placed immediately beneath the documentation text. The text for the \lstinline|@note| tag is somehow limited as it does not allow other JavaDoc tags.

\paragraph{\lstinline|@thanks|}\label{sec:TagThanks}  Usage: \lstinline|@thanks <name-text> - <email-address>|

Use this tag to mention someone who provided input to the respective element without being an author; that person might have wrote an article about the algorithm that was implemented by this element, or they may have reported a bug.

Same as for the \nameref{sec:TagExtAuthor} and the \nameref{sec:TagModified} tags, the email address will be rendered to a \verb#mailto:# link in the generated documentation.

\paragraph{\lstinline|@UMLGraph.link|}\label{sec:TagUMLGraph}  Usage: \lstinline|@UMLGraph.link|

This adds an UML graph for the current class to the generated documentation.


\section{Implementation Comment Formats}
A source code file can have four styles of implementation comments:
\begin{itemize}[nosep]
\item{structuring comments}
\item{block comments}
\item{single-line comments}
\item{trailing or end-of-line comments}
\end{itemize}

\subsection{Structuring Comments}\label{sec:StructuringComments}
Structuring comments are the most simple comments: they are used to separate the parts of a class (as defined in chapter \tqfullvref{sec:ClassAndInterfaceDeclarations}) from each other. They have the form
\begin{lstlisting}
    /*------------------*\
====** Enum Declaration **===========================================
    \*------------------*/
    /*---------------*\
====** Inner Classes **==============================================
    \*---------------*/
    /*-----------*\
====** Constants **==================================================
    \*-----------*/
    /*------------*\
====** Attributes **=================================================
    \*------------*/
    /*------------------------*\
====** Static Initialisations **=====================================
    \*------------------------*/
    /*--------------*\
====** Constructors **===============================================
    \*--------------*/
    /*---------*\
====** Methods **====================================================
    \*---------*/
\end{lstlisting}

with the lines ending at column 80 (the samples here are too short).

If a class or interface does not have a particular part, the assigned structuring comment must be omitted.

I recommend to create “Building Blocks” with these comments. Eclipse provides the Snippet facility for this purpose\footnote{Storing the comments as code templates is not recommended as a template would be reformatted on insert.}. Refer to chapter \tqfullvref{sec:SnippetStructuringComments} for the snippet code for the structuring comments.

\subsection{Block Comments}\label{sec:BlockComments}
Block comments are used to provide detailed descriptions of files, methods, data structures and algorithms – meaning that the text of the comment is longer than just one line. Block comments may be used at the beginning of each block after the opening brace. They can also be used in other places, such as within methods. Block comments inside a function or method should be indented to the same level as the code they describe. 

A block comment should be preceded by a blank line to set it apart from the rest of the code. If the block comment does not directly refer to the code line immediately after it, it should be followed by another blank line.

Next, the first line of the comment block has to remain empty, and the closing of the comment block has to be placed on a line of its own.

Some samples:
\begin{lstlisting}
{
    /*
     * Here is a sample of a block comment. Block comments are used
     * to provide detailed information about code internals.
     */
    Result value = retrieveResult( parameter );
    …

    /*
     * Here is another sample of block comment, somewhere in the
     * middle of a code block. Please note the blank line above!
     */
    …
}

// AVOID!
/*
 * This block comment is outside the code block it refers to. Block 
 * comments should be placed after the opening curly brace of the
 * block.
 */
{
    Result value = retrieveResult( parameter );
    …
 
/* The first line of the block comment should be left empty and the
 * comment should be indented in the same way as the code in the
 * block.
 */
    processResult( value, parameter );
    /* 
     * Here the empty line above the comment is missing …
     * … and the closing tag should be on a line of its own. */
\end{lstlisting}
 
\subsection{Single-Line Comments}\label{sec:SingleLineComments}
Short comments can appear on a single line; they will be indented also to the level of the code that follows. Usually it should be written in the form of a headline:
\begin{lstlisting}
//---* Handle the condition *----------------------------------------
\end{lstlisting}
with the dashes ending on column 80.\footnote{A quick reminder: the sample code in this document uses a line length of 70, so the dashes in the comment line above ends an column 70.}

If a comment cannot be written in a single line, it should have the block comment format (see chapter \tqref{sec:BlockComments}). A single-line comment should be separated from the preceding code by a blank line. Only when the preceding line contains only the opening curly brace as in the \lstinline|if-then-else| sample below (lines~3 and 8). 

Here are some examples of single-line comments in Java code:
\begin{lstlisting}[numbers=left]
if( cache.contains( key ) )
{
    //---* Take the data from the cache *----------------------------
    …
}
else
{
    //---* Load the data from its original source *------------------
    …
}
…
ResultData resultData = executeService();

//---* Format the output for the UI *--------------------------------
formatResult( resultData );
…
\end{lstlisting}

Another form of the single line comment is the empty block comment:
\begin{lstlisting}
public interface Marker
{ /* No methods */ }

public class Extension extends Base
{ /* No implementation */ }

private Constructor() { /* Does nothing */ }

public void adapterMethod() { /* Does nothing */ }

public final void method()
{
    …

    try
    {
        …
    }
    catch( final MyException e ) { /* Exception deliberately swallowed /* }

    …
}   // method()
\end{lstlisting}

And finally, there are the “class termination comments” that repeats the name of the class after the last curly brace:
\begin{lstlisting}
public final class MyClass
{
    …
}
//  class MyClass

public final interface MyInterface
{
    public record InnerRecord( final int number )
    {
        …
    }
    //  record InnerRecord
    
    …
}
//  interface MyInterface

\end{lstlisting}

\subsection{Trailing or End-Of-Line Comments}\label{sec:TrailingOrEndOfLineComments}
Very short comments can appear on the same line as the code they describe, but should be shifted right far enough to separate them from the statements. If more than one short comment appears in a chunk of code, they should all be indented to the same tab setting.

Here's an example of a trailing comment in Java code:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            /* special case */
}
else
{
    return isPrime( a );    /* works only for odd a */
}
\end{lstlisting}

But it is more common to use “//” instead of “/*…*/” for these trailing comments:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            // special case
}
else
{
    return isPrime( a );    // works only for odd a
}
\end{lstlisting}

You will use trailing comments to provide the documentation for local variables\footnote{Usually, the name of that local variable should be sufficient (refer to chapter \tqvref{sec:Fields}), or the meaning of that variable is obvious from the context, but sometimes it still make sense to provide that kind of additional information.}:
\begin{lstlisting}[numbers=left,caption={Gauss's Easter algorithm\autocite{WIKIPEDIA:DateOfEaster,WIKIPEDIA:Gaussche_Osterformel}}]
/**
 *  <p>{@summary This method calculates the date of Easter Sunday 
 *  for the given year.} The year has to be in the range from 1583 
 *  to 3900 (included).</p>
 *  <p>The resulting date is for the Gregorian calendar.</p>
 *  <p>The algorithm itself is not the original one published by Carl
 *  Friedrich Gauß first in 1800 (corrected version in 1816), but
 *  that one published by Heiner Lichtenberg in 1997.
 *
 *  @thanks Carl Friedrich Gauß
 *  @thanks Heiner Lichtenberg  
 *
 *  @param  year    The year for which the date of Easter Sunday is 
 *      wanted for.
 *  @return The date of Easter Sunday in the given year.
 *  
 *  @see <a href="https://de.wikipedia.org/wiki/Gau%C3%9Fsche_Osterformel">Gaußsche Osterformel</a>
 */
public static final LocalDate calcEasterDate( final Year year )
{
    /*
     * The explanation for the variables was taken from the German
     * Wikipedia article and translated by me. The original terms
     * are given in parenthesis.
     */
    final int x;  // The year
    final int k;  // The secular number (die Säkularzahl)   
    final int m;  // The secular moon shift (die säkulare Mondschaltung)
    final int s;  // The secular moon shift (die säkulare Sonnenschaltung)
    final int a;  // The moon parameter (der Mondparameter)
    final int d;  // The seed for the first full moon in spring (der Keim 
        // für den ersten Vollmond im Frühling)
    final int r:  // The calendar adjustment (die kalendarische
        // Korrekturgröße)
    final int og; // The Easter limit (die Ostergrenze)
    final int sz; // The first Sunday in March (der erste Sonntag im März)
    final int oe; // The distance of Easter Sunday from the Easter limit
        // – Easter distance in days (die Entfernung des Ostersonntags
        // von der Ostergrenze – Osterentfernung in Tagen)
    final int os; // The date of Easter Sunday as a March date with 
        // March 32 as April 1 etc. (das Datum des Ostersonntags als 
        // Märzdatum – 32. März = 1. April usw.)
    
    //---* Check the arguments *-------------------------------------    
    if( requireNonNullArgument( year, "year" ).isBefore( Year.of( 1583 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years greater than or equal to 1583" );
    }
    if( year.isAfter( Year.of( 3900 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years less than or equal to 3900" );
    }

    //---* Lichtenberg's Easter formula *----------------------------
    x = year.getValue();
    k = x / 100;    
    m = 15 + (3 * k + 3) / 4 - (8 * k + 13) / 25;
    s = 2 - (3 * k + 3) % 4;
    a = x % 19;
    d = (19 * a + m) % 30;
    r = (d + a / 11) / 29;
    og = 21 + d - r;
    sz = 7 - (x + x / 4 + s) % 7;
    oe = 7 - (og - sz) % 7;
    os = og + oe;

    /*
     * Initialise the return value with the last day of February and 
     * add the calculated number of days.
     */
    final var retValue = LocalDate.of( y, MARCH, 1 )
        .minusDays( 1 )
        .plusDays( os );

    //---* Done *----------------------------------------------------
    return retValue;
}   //  calcEasterDate()
\end{lstlisting}

As you can see, for this use case it is acceptable to continue a long comment in the following line (see lines~31 and 32, for example) without using a block comment.

Another use case for these kind of comments is to provide information about the arguments of a method call; usually, you should avoid method signatures where this is required (the formal parameter of the method should be sufficient to explain the argument), but sometimes it makes still sense:
\begin{lstlisting}
…
drawCircle(
    x, y, // The center of the circle
    d/2.0 // The radius of the circle, calculated from the diameter
);
…
\end{lstlisting}

The end comment for a method is also of this type:
\begin{lstlisting}
public final void method()
{
    …
} //  method()
\end{lstlisting}

Also a long code block\footnote{But if it seems really necessary to add such a comment to a linear code block, you should consider to re-organise your code.} can be commented like this:
\begin{lstlisting}
{
    //---* Calculate the result *------------------------------------
    // Lots of code comes here ...
    …
} //  End of result calculation
\end{lstlisting}

The end comments for the bodies of \lstinline|for|, \lstinline|while|, \lstinline|switch| and even \lstinline|if-then-else| blocks are a special case, as those blocks should be introduced by a label, and this label should be repeated as the end comment:
\begin{lstlisting}
ScanLoop: for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  ScanLoop:

ForeverLoop: while( true )
{
    // Lots of code comes here ...
    …
}   //  ForeverLoop:

TypeSwitch: switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  TypeSwitch:

SpecialCaseTurnout: if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  SpecialCaseTurnout:
else
{
    // Not so much code here
    …
}    
\end{lstlisting}
Note the colon at the end of each of the comments!

Do not use the introducing code line for the end comment! That code line may change at some point in time and then the end comment does not have a corresponding starting line anymore.\footnote{This also means that you should be careful with removing or changing labels in the code.}

Avoid this:
\begin{lstlisting}
// AVOID!!!
for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  for( final var s : lines )

while( true )
{
    // Lots of code comes here ...
    …
}   //  while( true )

switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  switch( type )

if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  if( isSpecialCase() )
else
{
    // Not so much code here
    …
}    
\end{lstlisting}

\section{Maintenance Comments}\label{sec:MaintenanceComments}
It is very likely that source code will be changed more than once during its lifetime. Bugs will be fixed, functionality is added or removed, refactorings will be applied, or the code will be migrated to other platforms or different versions of the programming language, the underlying libraries, the connected systems and/or the operating system.

There is a practice that all the changes made in the code will be commented in the code. These comments are usually referred to as “Maintenance Comments”.

This may look like this:
\begin{lstlisting}
…
//<<BEGIN FSP-4711 – applied by Micky Mouse
//<Old Code>
//…
//>><<
<New Code>
…
//>>END FSP-4711
\end{lstlisting}

It has proved that this is not a good practice at all, and a really bad practice if dealing with code that is managed by an SCCS.

First, this practice causes problems for the compare tools coming with the SCCS – at least it will make it more difficult to read the comparison results from those tools.\footnote{Most comparison tools will recognise the out-commenting of the old code as a change and the new code as additional code instead of the replacement for the old code. This is at least confusing when a code revisions are made on the fix.} And the main function of those comments – documenting the changes – is much better served by the SCCS tools themselves.

Second, this gets even worse when the fix needs a fix. Just think about overlapping changes, like FSP-4712 changes lines from the new code of FSP-4711, together with lines directly below, or changes that has to be partially reverted, and so on.

And finally, the comments does not help to identify if your are currently running the patched code, or the old one.

On the other hand, nothing can be said against adding a line to the file or class comment that lists the patches that were applied to the code.

Therefore I recommend to introduce an annotation that can be used to mark elements that are affected by a fix.

Such an annotation can provide the BUG number of the fix, together with a short description of the issue. This annotation replaces a comment about the applied patches, with the advantage that it can be retrieved also from the compiled classes, even at runtime.

Chapter \tqfullvref{sec:PatchIdentification} provides an example of such an annotation.

Old code will be removed and not commented out, or just replaced by the new code. One or the other short comment with a hint is not mandatory, but does not harm either.

When using the suggested annotation from chapter \tqref{sec:PatchIdentification}, this could look like this:
\begin{lstlisting}
…
@BUG( id = "BUG-4711", comment = "No end criterion for loop" )
@BUG( id = "BUG-4712", comment = "Exception was swallowed" )
public final void myMethod()
{
    ForeverLoop: while( true )
    {
        try
        {
            …
            
            if( !hasMore() ) break ForeverLoop; // BUG-4711
        }
        catch( final IllegalStateException e )
        {
            log( e );
            break ForeverLoop; // BUG-4712: Added exception handling
        }
    }   //  ForeverLoop:
}   //  myMethod()
…
\end{lstlisting}

\section{Special Comments}
The “Code Conventions for the Java\textsuperscript{TM} Programming Language”\autocite{SUN_CODE_CONVENTIONS:SpecialComments} suggests some special comments: \verb#XXX# in a comment flags something that is bogus but works. \verb#FIXME# flags something that is bogus and broken (and has to be fixed very soon).

Eclipse knows a setting that allows to externalise such comments into a task list: \verb#Window|Preferences|General|Editors|Structured Text Editors|Task Tags#.

It also adds \verb#TODO# to that list, for something that still needs to be implemented.

\section{Commenting out Code}
Use the “//” delimiter to comment out a complete line, only a partial line, or a whole bunch of consecutive lines of code.

Example:
\begin{lstlisting}
if( foo > 1 )
{
    //---* Do a double-flip *----------------------------------------
    …
}
else
{
    return false;          // Explain why here.
}
//if( bar > 1 )
//{
//    //---* Do a triple-flip *--------------------------------------
//    …
//}
//else
//{
//    return false;
//}
\end{lstlisting}

To use a block comment (“/*…*/”) for commenting out sections of code is not a good idea, although you do not have to type that much: you cannot have a block comment inside a block comment.

The easiest way to comment out a selected code block this way in Eclipse is to use \verb#Source|Toggle Comment# from the menu or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “7” instead of “/”.}.

In IntelliJ IDEA, it is the menu command \verb#Code|Comment with Line Comment# or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “÷” on the numeric keypad instead of “/”.}.

\section{Comments when?}\label{sec:CommentsWhen}
To repeat what was already said at the beginning of the chapter \tqfullref{sec:WritingProperComments}: The frequency of comments reflects poor quality of code, but code can be “under-commented” or “over-commented”. This means that there is a “frequency band” for comments that has to be hit for good quality code.

The advice “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” raises the question for whom the code has to made clearer, because the experts and the rookies are completely distinct audiences, with different needs in regard of comments in the source code.

Same with that other advice (“Even if you don't think, a comment might be necessary, add it nevertheless”): it is the other extrema, and equally bad.

That leads us (again) to the conclusion, that writing good comments to source code is a complex art.

This means that this document cannot give you a complete rule set here, just some guidance.

\chapter{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}















As for chapter “4.1 Documentation Comments” on page 46, a doc comment has to be written at all locations where a doc comment is possible, so the hints below are just for implementation comments.
    • No empty blocks are allowed: at least a block contains a comment that describes why it does not hold any code.
    • A short description of the used algorithm is always helpful; even just mentioning its name can make a difference. But if the implementation changes, such a comment has to be adjusted as well.
    • Every location where you hurt one of the rules or recommendations from this document is worth a comment:
value = 7.0 / a; // a != 0.0 was already checked above
o.execute(); // o != null was checked in foo.bar( o )
/*
 * bar.getQ() will never return null, so an explicit check on
 * null for q was omitted
 */
q = bar.getQ();
q.execute();
    • A comment is necessary if exceptions are swallowed, no matter if silently or not, meaning the exception is logged somewhere.
    • As said already in chapter “2.5.6 switch Statements” on page 29, a comment is required on a case fall-through.
    • Non-obvious class casts should be commented, in order to document that the programmer knew what he did:
private void valueProcessor( List<Object> values )
{
    …
    Value value;
    for( Object o : values )
    {
        /*
         * We know that values can only contain Value objects;
         * otherwise this method would not have been called to
         * process the list.
         */
        value = (Value) o;
        …
This makes sense because a check like
if( o instanceof Value ) value = (Value) o;
is relatively expensive – especially if the contract for this private method is, that it is only called with lists containing Value objects so that the check is positive only in very, very, very rare cases. And finally: what else can be done in cases where the object is not of the right type than throwing a ClassCastException? That's the same that is done by the code above in such a case, too.
    • In some sources you will find the recommendation to add a comment at the end of a long compound statement, like this:
// Not recommended
if( <condition1> )
{
    // Lots of code comes here …
    …
} // if( <condition1> )
Although this helps with navigation inside the code, it may cause confusion when the conditional statement will change. Our recommendation is to use a (meaningful) label instead:
// RECOMMENDED
IfWithLargeBlock: if( <condition1> )
{
    // Lots of code comes here …
    …
} // IfWithLargeBlock:
Also refer to chapter 2.5.11 on page 33 about labels and the break statement.
    • tbc
Maintenance comments are discussed in the next chapter.

\chapter{Coding Rules}\label{sec:CodingRules}

\section{The Annotation @API}\label{sec:APIAnnotation}

\section{“Convention over Configuration”}

\section{Exceptions}

\subsection{General Exception Handling}\label{sec:GeneralExceptionHandling}

\section{Extending Classes, Overriding Methods}\label{sec:ExtendingClassesOverridingMethods}

\subsection{Non-Final Methods}\label{sec:NonFinalMethods}

\section{Returning Values}\label{sec:ReturningValues}

\subsection{Lambda Results}\label{sec:LambdaResults}

\section{The Ternary Operator “?”}\label{sec:TheTernaryOperator}

\section{Encapsulation}

\subsection{Encapsulation with Modules}\label{sec:EncapsulationWithModules}

\section{Lambdas}\label{sec:Lambdas}

\section{Utility Classes}\label{sec:UtilityClasses}

\section{try-with-resources}\label{sec:TryWithResources}

The feature \lstinline|try-with-resources| was introduced with Java~7; it can help to make programs more stable and less error prone.

\subsection{Basics}
Basically, \lstinline|try-with-resources| is an extension of the previously existing \lstinline|try-catch-finally| feature.

Instead of writing
\begin{lstlisting}[numbers=left]
InputStream input = null;
try
{
    input = new FileInputStream( file );
    …
}
catch( final IOException e )
{
    // Handle the error
}
finally
{
    try
    {
        if( input != null ) input.close();
    }
    catch( final IOException e )
    {
        // Handle the error
    }
}
\end{lstlisting}

the new feature allows you to write

\begin{lstlisting}[numbers=left]
try( final var input = new FileInputStream( file ); )
{
    …
}
catch( final IOException e )
{
    // Handle the error
}
\end{lstlisting}

It works because the interface \lstinline|java.lang.AutoCloseable|\footnote{In fact, \lstinline|InputStream| will still implement just \lstinline|java.io.Closeable|, as already before Java~7, but this interface will now extend the new interface \lstinline|java.lang.AutoCloseable|.} is implemented by the class \lstinline|java.io.InputStream|. For details refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE}.

This interface defines just one method, \lstinline|close()|, that declares to throw an exception of type \lstinline|java.lang.Exception|.

\lstinline|close()| is called automatically on all instances of \lstinline|AutoClosable| that were declared and defined in the ‘arguments list’ of the new \lstinline|try| when the scope of the \lstinline|try| block is left. If there is more than one resource defined, the sequence is reversed to that of the definition: the last assigned resource will be closed first.

So a code snippet to copy data from an input stream to an output stream may look like this\footnote{This is obviously not a very good implementation, but it illustrates how to use \lstinline|try-with-resources| quite well.}:
\begin{lstlisting}[numbers=left]
try
( 
    InputStream input = new FileInputStream( infile );
    OutputStream output = new FileOutputStream( outfile ) 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
\end{lstlisting}
Both streams will be closed properly in case of a problem or the work is done.

\subsection{Error Handling}
What will happen if the code in the \lstinline|try| block throws an exception and closing the resource will throw one, too?

For the ‘traditional’ pattern this could mean that the first exception would be ‘supplanted’ by the exception from the close. For sure, in a \lstinline|catch| block the original cause could be logged, but usually only checked exceptions (and “expected“ ones) are covered this way.

Together with \lstinline|try-with-resources|, a new feature was introduced to the language: the \textit{suppressed} exception. This deals with the problem described above.

So if the \lstinline|try| block throws an exception (for our example, it would be most probably an \lstinline|IOException|) and the \lstinline|AutoCloseable.close()| will fail with an exception, too, the latter one will be added to the first one as a “suppressed exception” by the JVM.

For this purpose, the API of the class \lstinline|java.lang.Throwable| was extended by the methods \lstinline|addSuppressed()| and \lstinline|getSuppressed()|.\footnote{see \autocite{ORACLE_DOC_THROWABLE_CLASS}}

Using \lstinline|Throwable.printStackTrace()| an output like that below will be produced:
\begin{lstlisting}
java.lang.Error
  at TryWithResources.main(TryWithResources.java:175)
  Suppressed: java.lang.Exception
    at TryWithResources$Resource2.close(TryWithResources.java:103)
    at TryWithResources.main(TryWithResources.java:176)
\end{lstlisting}

\subsection{Execution Sequence}\label{sec:ExecutionSequence}
It is important to know how the execution sequence looks like when using \lstinline|try-with-resources|. For the traditional pattern it is\\
\begin{center}
\verb#try{}->[catch{}]->finally{}#
\end{center} 
for \lstinline|try-with-resources| it will be\\ 
\begin{center}
\verb#try{}->AutoCloseable.close()->[catch{}]->[finally{}]#
\end{center}

This means that the method \lstinline|close()| on the \lstinline|AutoClosable| objects will be called \textit{before} any code in an optional \lstinline|catch| and/or \lstinline|finally| block that is attached to the \lstinline|try| block. For the sample we used above this means that the \lstinline|InputStream input| is already closed when the code in the \lstinline|catch| block that handles the \lstinline|IOException| will be executed.

Therefore the code below will not work as expected in case an exception is thrown in the \lstinline|try| block:
\begin{lstlisting}
// WILL NOT WORK!
final var logStream = new FileOutputStream( logfile )
try
(   
    final var input = new FileInputStream( infile );
    final var output = new FileOutputStream( outfile );
    final var log = logStream 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
catch( final IOException e )
{
    logStream.write( "Copy failed!\n".getBytes( UTF8 ) );
    /* Fails because the log file is already closed! */
}
\end{lstlisting}

\subsection{When to use?}
\lstinline|try-with-resources| is a very powerful feature that should be used whenever possible. Definitively it should be used with all the Java classes that already implement \lstinline|java.lang.AutoCloseable| or \lstinline|java.io.Closeable|:

\begin{itemize}
\item{The \lstinline|java.io| streams}
\item{Sockets}
\item{\lstinline|java.sql.Connection|, \lstinline|java.sql.Statement|, \lstinline|java.sql.ResultSet|}
\item{\lstinline|java.jms.Connection|}
\end{itemize}

\subsubsection{Lifecycle}\label{sec:Lifecycle}
In C++, it is a very common pattern to “wrap” the lifecycle of a resource into the lifecycle of an object:
\begin{lstlisting}[language=C++]
class Resource
{
    //---* Attributes *----------------------------------------------
    private:
        RTYPE m_Res;

    //---* Constructors *--------------------------------------------
    public:
        Resource( RTYPE &r )
        : m_Res( r )
        { m_Res.open(); }

    //---* Destructor *----------------------------------------------
    public:
        ~Resource() { m_Res.close(); }

    //---* Methods *-------------------------------------------------
    // Some methods to access the resource
    …
}
\end{lstlisting}
A use of that class might look like this:
\begin{lstlisting}[language=c++]
…
{
    Resource resource( r );

    // Do something
    …
}
…
\end{lstlisting}
The instance of \lstinline|Resource| will be constructed and \lstinline|open()| is called on \lstinline|r| on the declaration of the variable \lstinline|resource|. On leaving the scope the destructor of \lstinline|Resource| is called implicitly and \lstinline|close()| will be called on \lstinline|r|.

The C++~STL is using a very similar pattern for smart pointers.

Unfortunately, Java does not know destructors\footnote{The deprecated method \lstinline|java.lang.Object.finalizer()| that is part of each Java class is not and was never a replacement for or an alternative to a destructor as it could never be predicted when it is called (just “sometime before the JVM terminates” – if ever).}, so this pattern could not be used.

A workaround is to use a \lstinline|try-finally| block with the cleanup (usually a call to \lstinline|close()|) in the \lstinline|finally| block. But to often we have seen that in the run of modifications and/or corrections (refactorings) suddenly the \lstinline|finally| block and/or its contents had been removed (“optimised away”).

Now, with the \lstinline|try-with-resources| feature, we can have “Lifecycle” classes; they are still not that easy to use that with real destructors, but we can come close.

A sample would be the Class \lstinline|AutoLock|; for the full code, see chapter \tqfullvref{sec:AutoLock}; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

In programs that use \lstinline|java.util.concurrent.locks.Lock| or one of its implementations for thread synchronisation, you will find quite often code like this:
\begin{lstlisting}[numbers=left]
m_Lock.lock();
try
{
    // Do something
    …
}
finally { m_Lock.unlock(); }
\end{lstlisting}

This calls for a lifecycle class. Unfortunately the code below will not work, due to several reasons:
\begin{lstlisting}[numbers=left]
// Does not work!!
try( final var unused = new Lock() )
{
    // Do something
    …
}
\end{lstlisting}

First, \lstinline|java.util.concurrent.locks.Lock| will not implement \lstinline|java.lang.AutoCloseable|, and second – much more important – we cannot create a new instance of \lstinline|Lock| each time we enter the critical section.\footnote{Not to mention that \lstinline|java.util.concurrent.locks.Lock| is an interface so that \lstinline|new Lock()| cannot work at all.}

Fortunately, the \lstinline|try-with-resources| feature will not call \lstinline|close()| on the newly created object, but on the local reference (that is the reason why \lstinline|try-with-resources| will not work with anonymous instances like \lstinline|try( new Lock() )|). If we would now wrap the \lstinline|Lock| instance into a class that implements \lstinline|AutoCloseable|, we can write something like this:
\begin{lstlisting}[numbers=left]
…
AutoLock m_AutoLock = new AutoLock( m_Lock );
…
try( final var unused = m_AutoLock.lock() )
{
    // Do something
    …
}
\end{lstlisting}

\subsubsection{Post-Processing}
Together with lambdas, \lstinline|try-with-resources| can be (ab)used also to enforce a unconditional post-processing when a code block is left. This may look like this:
\begin{lstlisting}[numbers=left]
…
Runnable doAfter = …;
…
try( final var p = new PostProcessor( doAfter ) )
{
    // Do whatever necessary
    …
}
\end{lstlisting}
The \lstinline|PostProcessor| instance will call \lstinline|Runnable::run| in its \lstinline|close()| method when the \lstinline|try| block is left. Chapter \tqfullref{sec:PostProcessor} in the Appendices provides the source for the class.

‘Unconditional’ means here that the post-processing will be executed if the block terminates regularly or by a thrown exception. Other conditions can be injected into the \lstinline|Runnable| implementation.

The difference between this approach and simply calling \lstinline|doAfter.run()| in a \lstinline|finally| block is that the \lstinline|close()| method of \lstinline|PostProcessor| is invoked before any code in a \lstinline|catch| block (refer to chapter \tqfullref{sec:ExecutionSequence}).

The following code snippet could be a real-life example for where this is useful:
\begin{lstlisting}[numbers=left]
final var builder = new StringBuilder();

final Runnable addTrailer = () -> builder.append( "}\n" );

…

try( final var p = new PostProcessor( addTrailer ) )
{
    …
}
\end{lstlisting}
This ensures that the string in \lstinline|builder| always terminates with a closing curly brace followed by a linefeed.

Another sample is this code snippet:
\begin{lstlisting}[numbers=left]
final List<String> list = new LinkedList();

final Runnable forceSorting = () -> list.sort();

…

try( final var p = new PostProcessor( forceSorting ) )
{
    for( final var s : loadStrings() )
    {
        list.add( s );
    }
}
\end{lstlisting}
Here the \lstinline|PostProcessor| forces that the given list is always sorted after the values had been added.

\section{Finalisation}

\section{Deprecation of Elements}\label{sec:DeprecationOfElements}

\chapter{Summary}
Several rules and recommendation in this document, in particular regarding how to apply comments and how to write comments, but also those about to write a method, do require significant additional typing. Java in general has the reputation to be too verbose, and this coding conventions will even add to that.

But from my experience I found that verbosity is your friend!

And if you are afraid of the typing work: as I said already earlier (see chapter \tqref{sec:LengthOfNamesAndUseOfAbbreviations}), you should learn typewriting! For my understanding, someone who does not reach at least 100~CPM\footnote{CPM = “Characters per minute”, or, in German: „Anschläge pro Minute“} should look for a job outside of software development!

Writing code is not the only area where you would benefit from mastering that important skill; it will also help you to write all the other stuff you have to deliver in addition to your code (documentation, meeting notes, emails, specification documents, …).

\section{How to use this Document?}
First, you can use this document as is! It should work for you, as its predecessors worked for a bunch of project teams.

But you can also shape it to your needs, if you want! Replace the examples and the references to my libraries by some that fits better to your project or your company.

This document was compiled using \TeX/\LaTeX, and its source can be found on GitHub at \href{https://github.com/tquadrat/documents}{https://github.com/tquadrat/documents}. Clone the repository and startover!

\chapter{Appendices}

\section{The Naming Dictionary}\label{sec:TheNamingDictionary}
The names of program elements provide an implicit contract (or at least a kind of commitment) between the original author of the program and its users/maintainers. But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts here, together with a list of suffixes for class names.

\subsection{Verbs}
This chapter provides a list of verbs\footnote{Ok, some names or prefixes are not verbs, like ‘main’, ‘from’ or ‘to’ …} to be used with method names and a description of their implicit contract. These verbs are usually prefixes to a method name, although some of them could be used as standalone names, too. The form that used more often is mentioned first.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{Verbs.tbl.tex}

That a method name is built using one of the verbs above does not free you from providing a proper JavaDoc comment that describes the purpose of the method in detail, together with the arguments, return values and exceptions.

\subsection{Suffixes for Class Names}\label{sec:SuffixesForClassNames}
This chapter lists defined suffixes for class names and their function.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{ClassNameSuffixes.tbl.tex}

\section{IDE Configuration}\label{sec:IDEConfiguration}
This chapter provides samples of configuration files for some IDEs.

\subsection{Eclipse}\label{sec:EclipseConfiguration}
tbd

\subsubsection{Snippets}
This chapter provides the XML code for Eclipse snippets.

\paragraph{Structuring Comments}\label{sec:SnippetStructuringComments}
The snippets for the structuring comments as defined in chapter \tqfullvref{sec:StructuringComments}.
\begin{lstlisting}[language=XML,basicstyle=\ttfamily\footnotesize]
<?xml version="1.0"
      encoding="UTF-16" 
      standalone="no"?>
<snippets>
    <category filters="*"
              id="category_1145179107125"
              initial_state="0"
              label="Structuring Comments"
              largeicon=""
              smallicon="">
        <description><![CDATA[Structuring Comments as defined by the Code Conventions]]></description>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145232938375"
              label="Enum Declaration"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the enum definition part]]></description>
            <content><![CDATA[        /*------------------*\
    ====** Enum Definitions **=================================================
        \*------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179869843"
              label="Inner Classes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the inner classes part]]></description>
            <content><![CDATA[        /*---------------*\
    ====** Inner Classes **====================================================
        \*---------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251889697104"
              label="Constants"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for constants.]]></description>
            <content><![CDATA[      /*-----------*\
    ====** Constants **========================================================
        \*-----------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251888677777"
              label="Attributes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for attributes.]]></description>
            <content><![CDATA[      /*------------*\
    ====** Attributes **=======================================================
        \*------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179436656"
              label="Static Initialisations"
              largeicon="" smallicon="">
            <description><![CDATA[The header comment for the static initialisations part]]></description>
            <content><![CDATA[        /*------------------------*\
    ====** Static Initialisations **===========================================
        \*------------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180117906"
              label="Constructors"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the constructors part]]></description>
            <content><![CDATA[    	/*--------------*\
    ====** Constructors **=====================================================
        \*--------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180168796"
              label="Methods"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the methods part]]></description>
            <content><![CDATA[    	/*---------*\
    ====** Methods **==========================================================
        \*---------*/
]]></content>
        </item>
    </category>
</snippets>
\end{lstlisting}

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJConfiguration}
tbd

\section{Embedded Code}
Sometimes, it is necessary to embed code inside the Java source code. Most often, these are SQL statements, but sometimes it could be also fragments of HTML or XML documents.

\subsection{Formatting SQL inside Java}\label{sec:FormattingSQLInsideJava}

\subsection{Formatting XML inside Java}\label{sec:FormattingXMLInsideJava}
You should embed only small fragments of an XML document into the Java source; larger fragments and full documents can be handled better when provided as resources.

\subsection{Formatting HTML inside Java}\label{sec:FormattingHTMLInsideJava}
Same as for XML, also only small HTML fragments should be embedded into the Java source code. Anything else should go into a resource file.

\section{Examples}\label{sec:Examples}

\subsection{AutoLock}\label{sec:AutoLock}
This class is a sample implementation of the idea described in chapter \tqfullvref{sec:Lifecycle}, like a PoC; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={AutoLock.java}]
package org.tquadrat.util.concurrent;

import static java.util.Objects.requireNonNull;
import java.util.concurrent.locks.Lock;

/**
 *  A wrapper for locks that supports the {@code try-with-resources}
 *  feature of Java 7.
 *  The creation of the local reference to the wrapper object means
 *  some overhead but in very most scenarios this is negligible.
 *
 *  {@code AutoLock} will only expose the methods
 *  {@link #lock()}
 *  and
 *  {@link #lockInterruptibly()}
 *  of the interface
 *  {@link java.util.concurrent.locks.Lock Lock},
 *  but with a return value. Exposing other methods is not
 *  reasonable.
 *  Calling
 *  {@link #close()}
 *  on the {@code AutoLock} instance or
 *  {@link Lock#unlock()}
 *  on the wrapped {@code Lock} object inside the {@code try} block
 *  may cause unpredictable effects.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 *
 *  @see java.util.concurrent.locks.Lock
 */
public class AutoLock implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The wrapped lock.
     */
    private final Lock m_Lock;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code AutoLock} object.
     *
     *  @param  lock    The wrapped lock.
     */
    public AutoLock( final Lock lock )
    {
        m_Lock = requireNonNull( lock );
    }   //  AutoLock()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  {@inheritDoc}
     */
    @Override
    public final void close() { m_Lock.unlock(); }

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lock() lock()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     */
    public final AutoLock lock()
    {
        m_Lock.lock();

        //---* Done *------------------------------------------------
        return this;
    }   //  lock()

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lockInterruptibly()
     *  lockInterruptibly()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     *  @throws InterruptedException The current thread was
     *      interrupted while acquiring the lock (and interruption
     *      of lock acquisition is supported).
     */
    public final AutoLock lockInterruptibly() 
        throws InterruptedException
    {
        m_Lock.lockInterruptibly();
        
        //---* Done *------------------------------------------------
        return this;
    }   //  lock()
}
//  class AutoLock
\end{lstlisting}

\subsection{Patch Identification}\label{sec:PatchIdentification}

\chapter{-------------------------------------------- Proceed from here!}
The annotations \lstinline|@BUG| and \lstinline|@FixList| are part of the Foundation Base project\autocite{TQUADRAT_ORG_FOUNDATION_BASE}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={FixList.java}]
package org.tquadrat.foundation.annotation;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.MODULE;
import static java.lang.annotation.ElementType.PACKAGE;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.RECORD_COMPONENT;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.TYPE_PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 *  The annotation container for
 *  {@link BUG &#64;BUG}
 *  annotations.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
@Documented
@Retention( RUNTIME )
@Target( {ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, MODULE, PACKAGE, PARAMETER, RECORD_COMPONENT, TYPE, TYPE_PARAMETER, TYPE_USE} )
public @interface FixList
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  Provides the list of
     *  {@link BUG &#64;BUG}
     *  annotations.
     *
     *  @return The annotations.
     */
    public BUG [] value();
}
//  @interface FixList
\end{lstlisting}

\begin{lstlisting}[numbers=left,caption={BUG.java}]
package org.tquadrat.foundation.annotation;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.MODULE;
import static java.lang.annotation.ElementType.PACKAGE;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.RECORD_COMPONENT;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.TYPE_PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 *  This annotation allows to add information about applied fixes to 
 *  a program element.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
@API( status = STABLE, since = "0.1.0" )
@Documented
@Retention( RUNTIME )
@Target( {ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, MODULE, PACKAGE, PARAMETER, RECORD_COMPONENT, TYPE, TYPE_PARAMETER, TYPE_USE} )
@Repeatable( FixList.class )
public @interface BUG
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  An optional comment regarding the bug fix.
     *
     *  @return The comment.
     */
    String comment() default "";

    /**
     *  The BUG id as provided by the bug tracking system.
     *
     *  @return The BUG id.
     */
    String id();
}
//  @interface BUG
\end{lstlisting}

\subsection{PostProcessor}\label{sec:PostProcessor}
This implementation is basically a PoC; currently it is not part of any library.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={PostProcessor.java}]
package util;

import static java.util.Objects.requireNonNull;

/**
 *  Use this class to implement an uncoditional post-processing
 *  feature utilising try-with-resources.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public class PostProcessor implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The action.
     */
    private final Runnable m_Action;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code PostProcessor} object.
     *
     *  @param  action  The action that has to executed.
     */
    public PostProcessor( final Runnable action )
    {
        m_Action = requireNonNull( action );
    }   //  PostProcessor()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  Calls the
     *  {@link Runnable#run() run()}
     *  method of the
     *  {@linkplain #m_Action action}.
     *
     *  @see java.lang.AutoCloseable#close()
     */
    @Override
    public void close() throws Exception { m_Action.run(); }
}
//  class PostProcessor
\end{lstlisting}

\subsection{UnsupportedEnumError}\label{sec:UnsupportedEnumError}
This implemenation of \lstinline|java.lang.Error| is meant to be used in the \lstinline|default| branch of a \lstinline|switch| statement (refer to \tqfullvref{sec:SwitchStatements}), in cases where the selector is an enum.

It will be used like this:
\begin{lstlisting}[numbers=left]
enum Color
{
    RED, BLUE, GREEN, YELLOW
}

Color color = …    

// Traditional switch statement
switch( color )
{
    case RED: …; break;
    case BLUE: …; break;
    case GREEN: …; break;
    case YELLOW: …; break;

    default: throw new UnsupportedEnumError( color );
}

// New switch statement
switch( color )
{
    case RED -> …;
    case BLUE -> …;
    case GREEN -> …;
    case YELLOW -> …;

    default: throw new UnsupportedEnumError( color );
}

// switch expression
var result = switch( color )
{
    case RED -> "Rot";
    case BLUE ->"Blau";
    case GREEN -> "Grün";
    case YELLOW -> "Gelb";

    default: throw new UnsupportedEnumError( color );
}
\end{lstlisting}

Also refer to \autocite{TQUADRAT_ORG_FOUNDATION_UNSUPPORTEDENUMERROR}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={UnsupportedEnumError.java}]
package org.tquadrat.foundation.exception;

import static org.tquadrat.foundation.lang.Objects.requireNonNullArgument;
import static org.tquadrat.foundation.lang.Objects.requireNotEmptyArgument;
import static org.tquadrat.foundation.lang.internal.SharedFormatter.format;

import java.io.Serial;

/**
 *  This is a specialized implementation for
 *  {@link Error}
 *  that is to be thrown especially from the {@code default} branch
 *  of a {@code switch} statement that uses an {@code enum} type as
 *  selector.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public final class UnsupportedEnumError extends Error
{
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    /**
     *  The message text.
     */
    private static final String MSG_UnsupportedEnum = "The value '%2$s' of enum class '%1$s' is not supported";

        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The serial version UID for objects of this class: {@value}.
     *
     *  @hidden
     */
    @Serial
    private static final long serialVersionUID = 1174360235354917591L;

        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new instance of this class.
     *
     *  @param  <T> The type of the enum.
     *  @param  value   The unsupported value.
     */
    public <T extends Enum<T>> UnsupportedEnumError( final T value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( value, "value" ).getClass().getName(), value.name() ) );
    }   //  UnsupportedEnumError()

    /**
     *  Creates a new instance of this class.
     *
     *  @param  type    The class of the enum.
     *  @param  value   The unsupported value.
     */
    public UnsupportedEnumError( final Class<? extends Enum<?>> type, final String value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( type, "type" ).getName(), requireNotEmptyArgument( value, "value" ) ) );
    }   //  UnsupportedEnumError()
}
//  class UnsupportedEnumError

/*
 *  End of File
 */
 \end{lstlisting}

\listoftables

\lstlistoflistings

\printbibliography
\end{document}
