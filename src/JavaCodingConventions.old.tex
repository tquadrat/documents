%\RequirePackage{lmodern}
\documentclass[11pt,a4paper, titlepage, parskip=half, headsepline, footsepline, cleardoublepage=current, headheight=1cm]{scrbook}
%\usepackage{DejaVuSansMono}
\usepackage{dejavu}
%\usepackage[T1]{fontenc}
\usepackage{scrhack}
\usepackage{graphicx} 
\usepackage[manualmark]{scrlayer-scrpage}
%\usepackage[utf8]{inputenc}
\usepackage{tocbasic}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{eurosym}
\usepackage{ragged2e}
\usepackage{textcomp}
\usepackage{framed}
\usepackage{ltxtable}
\usepackage{filecontents}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,gray]{xcolor}
\usepackage{listings}
\usepackage[inline]{enumitem}
\usepackage{varioref}
\usepackage[iso,english]{isodate}
\usepackage{makecell}
\usepackage[english]{babel}
\usepackage[babel]{csquotes}

\usepackage{lipsum}

\usepackage[style=numeric, urldate=iso, date=iso, seconds=true, backend=biber]{biblatex}
\usepackage{nameref}
\usepackage[colorlinks=true]{hyperref}

\addbibresource{JavaCodingConventions.bib}

\automark[section]{chapter}
\lehead*[]{\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}~~\headmark}
\rohead*[\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}]{\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}}

\lstset{
language=Java,
%morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield},
morekeywords={var,yield},
backgroundcolor=\color[gray]{.9},
frame=single,
framerule=0.2pt,
basicstyle=\ttfamily\footnotesize,
commentstyle=\color[gray]{.2}\itshape,
keywordstyle=\color[gray]{.4}\bfseries,
identifierstyle=\bfseries,
stringstyle=\itshape,
xleftmargin=.2cm,
xrightmargin=.2cm,
breaklines=true,
breakatwhitespace=true,
inputencoding=utf8,
extendedchars=true,
literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
  {©}{{\copyright}}1
  {…}{{\dots }}2
  {–}{{--}}1
}

\colorlet{shadecolor}{gray!10}
\makeindex

%---* New Commands *-----------------------------------------------------------
\newcommand*{\tqfullref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”}}
\newcommand*{\tqfullvref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”} on page \pageref{#1}}
\newcommand*{\tqref}[1]{\hyperref[{#1}]{\ref*{#1}}}
\newcommand*{\tqvref}[1]{\hyperref[{#1}]{\ref*{#1}} on page \pageref{#1}}

\dedication{For Rasa Kuodienė: She deserved better~… in life and in death \newline\newline\includegraphics[height=14cm]{Rasa} \newline*1969-07-13 †2022-12-21}

\begin{document}
\isodate
\titlehead{\includegraphics[height=4cm]{Logo_gross}}
\author{Thomas Thrien\\(thomas.thrien@tquadrat.org)}
\title{Extended Coding Conventions for Java}
\subtitle{Coding and Formatting Guidelines, Recommendations and Best Practices}
\date{\today}
\maketitle
\tableofcontents

\chapter{Introduction}
\begin{quotation}
“Everybody can write code that can be read by a computer,
but only good developers will write code that can be read by humans.”
Martin G. Fowler: \textit{Refactoring: Improving the Design of Existing Code}\autocite{Fowler:Refactoring}
\end{quotation}

From a magazine dealing with software development tools, I found the following statement\footnote{I noted down the statement, but forgot to note the source – so if you know it, I would appreciate if you would share it with me.}

\begin{quotation}
“If you compare software development with the Apollo program, most programmers would be very successful bringing man to the moon, but never will get them back alive because of their common incapability to deliver software that can be maintained over a longer period of time with reasonable costs.”
\end{quotation}

Coding conventions are primarily guidelines that should help making code better to maintain. Usually, this starts with making it more readable: Reading code is more important than writing code.

Code is read much more often than it is written. Whether and how particular language features are used ought to be determined by their impact on future readers of the program, not its original author. Shorter programs can be preferable to longer ones, but shortening a program too much can omit information that is useful for understanding the program. The central issue here is to find the right size for the program such that understandability is maximized.

I am specifically unconcerned here with the amount of keyboarding that is necessary to input or to edit a program. While concision may be a nice bonus for the author, focusing on it misses the main goal, which is to improve the understandability of the resulting program. 

But code readability should not depend on IDEs. Code is often written and read within an IDE, so it’s tempting to rely heavily on code analysis features of IDEs. For type declarations, why not just use \lstinline|var| everywhere, since one can always point at a variable to determine its type?

There are two reasons. The first is that code is often read outside an IDE. Code appears in many places where IDE facilities aren’t available, such as snippets within a document, browsing a repository on the internet, or in a patch file. It is counterproductive to have to import code into an IDE simply to understand what the code does.

The second reason is that even when one is reading code within an IDE, explicit actions are often necessary to query the IDE for further information about a variable. For instance, to query the type of a variable declared using \lstinline|var|, one might have to hover the pointer over the variable and wait for a popup. This might take only a moment, but it disrupts the flow of reading.

Code should be self-revealing. It should be understandable on its face, without the need for assistance from tools.

Obviously, “readability” is a relative term, depending from one's habit. So some people are more familiar with the Kernighan-Ritchie (K\&R) style

\begin{lstlisting}
public void method (){
    if (flag) {
        …
    }
}
\end{lstlisting}

as it is also shown in the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS}, other prefer to have the curly braces on a line of their own (sometimes referred to as GNU or BSD style\footnote{All, BSD, GNU and K\&R styles, will define more than just how to place the curly braces. In addition, all three are originally code conventions for programming in C and/or C++ that cannot applied to Java without modifications. See chapter \tqfullvref{sec:OtherProgrammingLanguages} on this topic.}):

\begin{lstlisting}
public void method()
{
    if( flag )
    {
    	…
    }
}
\end{lstlisting}

Both styles will work, but they look different. So as a lot of other guardrails from a code conventions document, too, this is a matter of taste (but refer to chapter \tqfullvref{sec:IndentationStyle}).

But as conformity suppports readability, a main purpose of those guidelines is to ensure that all source code looks familiar to all members of the team. As a side effect, such a look identifies source code as written by the team, as its trademark.

So the practical reasons to enforce these guidelines as \textit{rules} – more or less strict – on the source are: they make it easier …
\begin{itemize}[nosep]
\item … to understand the code
\item … to navigate inside the code
\item … to detect bugs
\item … to fix these bugs
\item … and to amend and enhance the code.
\end{itemize}

It can make it also easier to use automated tools on the source code.

All this is important because most of the lifetime cost of a piece of software is going into maintenance – some sources say 80 to 90\% – and nearly no source is maintained by its original author or even a single programmer for its whole lifetime.

The base of the coding conventions presented in this document are the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS} we have already mentioned above, but with some changes and enhancements that seemed necessary or at least useful to me.

Another source was “Local Variable Type Inference – \textit{Style Guidelines}” \autocite{Marks:LocalVariableTypeInference}.

\section{About this Document}
The document itself consists of four major parts: first we want to talk about proper formatting of the source files, next it covers the naming of the program elements before I discuss some guidelines for writing proper comments. The final chapter before the appendices will cover general coding guidelines.

The code samples in this document should underline some particular aspect or demonstrate a single rule or recommendation; to stay focused on that purpose, and to keep the samples at a reasonable length, they may often hurt other rules or ignore other recommendations. For instance, in most cases, methods are lacking the required comments, or the names are not really meaningful. In addition, some rules, guidelines or recommendations are first used in the samples \textit{after} being introduced.

For source code samples that obey all rules, follow all guardrails and implements all recommendations, refer to chapter \tqfullvref{sec:Examples}.

All the rules, guidelines and recommendations in this document assume, that at least Java~17\footnote{see the language specification in \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION}} is used to write the code. I used that version also for the samples.

If you have questions or comments regarding this document, please send me an email to \href{mailto:thomas.thrien@tquadrat.org}{thomas.thrien@tquadrat.org}. Or leave it at \url{https://tquadrat.github.io/}.

\section{History and Implementation}
I compiled a first version of this document around the year 2000, based on the way I wrote Java code at that time. I was asked to do so for a team of developers that had been new to Java (and to programming …).

Later versions were created for other developer teams, and several software products had been created successfully following these coding conventions – proving my initial statement that coding conventions help to create maintainable software. Some of the code written by the various teams is still running, after 20~years now, another code is live since 12~years now.

I wrote some libraries that supports some of the rules, guardrails and recommendations, in particalur those mentioned in chapter \tqfullref{sec:CodingRules}, starting on page~\pageref{sec:CodingRules}. If interested, have a look to \autocite{TQUADRAT_ORG}.

\section{Other Programming Languages}\label{sec:OtherProgrammingLanguages}
Of course coding conventions like those described with this document are not only useful for Java programs, but for code in any other programming language also.\footnote{Even for descriptive languages like XML and HTML they make sense, also for documents written in \TeX/\LaTeX.} But each language has its unique features and specialities, meaning that coding conventions written for one programming language do not necessarily match the requirements for another.
	
Obviously there are some common rules that are valid for every programming language\footnote{E.g. the request to use meaningful names.}, but usually the differences will outweigh the similarities. So it is not a good idea to do something in language \verb#A# just and only it is done that way in language \verb#B#. On the other side, it should always be proved whether something that worked fine for one language would not be a great idea to be applied to code in another language, too.

In this sense, I would like to steal the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython,PYTHON_ORG_MAILING_LIST:ThePythonWay}\footnote{The numbering was added by me; I also added the ellipsis.} for this document:
\begin{enumerate}[nosep]
\item Beautiful is better than ugly.
\item Explicit is better than implicit.
\item Simple is better than complex.
\item Complex is better than complicated.
\item Flat is better than nested.
\item Sparse is better than dense.
\item Readability counts.
\item Special cases aren't special enough to break the rules …
\item … although practicality beats purity.
\item Errors should never pass silently …
\item … unless explicitly silenced.
\item In the face of ambiguity, refuse the temptation to guess.
\item There should be one – and preferably only one – obvious way to do\\ it …
\item … although that way may not be obvious at first unless you're Dutch.
\item Now is better than never …
\item … although never is often better than \textit{right now}.
\item If the implementation is hard to explain, it's a bad idea.
\item If the implementation is easy to explain, it may be a good idea.
\item Namespaces are one honking great idea – let's do more of those!\label{lst:ZoP:Namespaces}
\end{enumerate}
Only number~\ref{lst:ZoP:Namespaces} does not work for code written in Java, unless you translate “Namespace” to “Package” (or “Module” …).

A good example for the other way round – other programming languages adopting a feature from Java – is the idea to add documentation comments to the source code and to use a tool like JavaDoc to externalise them and publish them as the API documentation. It was adopted for various other languages, including so different specimen as C/C++, JavaScript and PL/SQL.\footnote{Although we have to confess that the commenting style is not part of the specification of these languages but only supported by external tools.} Obviously, if you want to benefit from that adopted feature, you have to write your C++ (JavaScript, PL/SQL, …) code (more precise, your comments) according to coding conventions similar to those defined here.

But no matter what programming language is used: The \textit{Basic Rule} as defined in chapter \tqfullref{sec:TheBasicRule} below will be applicable to each!

A sample for code conventions for JavaScript can be found in the web at \autocite{Crockford:JAVASCRIPT_CODE_CONVENTIONS}.

In chapter \tqfullvref{sec:FormattingSQLInsideJava} we have added some suggestions on how to format SQL statements when added as literals into a Java program.

\section{Code Generators}
Java code that is automatically generated by another piece of software should implement this coding conventions in the same way as “hand crafted” code. Most generators are highly configurable and/or allow to use code templates that are customisable.\footnote{Perhaps you want to have a look to \autocite{TQUADRAT_ORG_FOUNDATION_JAVACOMPOSER}.}

Especially if base classes will be generated it is important that proper comments are generated at least for all API elements; this means all \lstinline|public| and \lstinline|protected| elements, and in some cases all package-local elements, too.

Since Java~6 there is an annotation \lstinline|javax.annotation.Generated| (\lstinline|@Generated|) that should be used to mark generated code. Refer to \autocite{ORACLE_DOC_GENERATED_ANNOTATION} for the details.\footnote{In case still Java~5 is used as the source code version, it should be considered to create an own \lstinline|@Generated| annotation along the lines given by that existing in Java~6 and later.}

\section{Programming for Sustaining}
And what to do with “legacy” code that has to be fixed?

Most probably that code will not follow these coding conventions (if any at all …), and it is rarely a good idea to reformat or rewrite it completely just to align it with the conventions. Instead a fix should be limited to the area that is broken.

But if possible, the fix should incorporate the standards defined by this document. Be creative how to implement the these standards. So if a method has to be reimplemented completely, format it as described here and add the appropriate JavaDoc comments, if missing. Or if a new field has to be added to a class, add the “\verb#m_#” prefix to its name (see chapter \tqfullref{sec:Fields}).

Obviously, completely new interfaces and classes should be implemented fully compliant to this conventions.

In this context, see also chapter \tqfullvref{sec:MaintenanceComments}.

\section{Tool Support}
Several of the rules, guardrails and recommendations in this document can be implemented through the configuration of the programming enviroment that is used, especially those from chapter \tqfullref{sec:FormattingTheSourceCode} that deals with the formatting of the source code.

The chapter \tqfullref{sec:IDEConfiguration} provides some configuration samples for Eclipse and JetBrains IntelliJ IDEA.

\section{The Basic Rule}\label{sec:TheBasicRule}
In the chapter \tqfullref{sec:OtherProgrammingLanguages}, I quoted the “Zen of Python” and I refer to that set of rules several times in this document.

I did this because the “Zen of Python” is a \textit{nearly} generic coding guideline in a nutshell, valid for most, if not all programming languages.

Ok, some of the statements may need an explanation and/or some samples, and I hope that this document will give it to you.

But to get your “Coding Guardrails for Java” in a nutshell, you can take them from below:\footnote{obviously stolen from the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython,PYTHON_ORG_MAILING_LIST:ThePythonWay} and slightly amended~…).}
\begin{enumerate}[nosep]
\item Beautiful is better than ugly.
\item Explicit is better than implicit, and verbosity is your friend.\label{lst:ZoP:ExplicitVsImplicit}
\item Simple is better than complex.\label{lst:ZoP:SimpleVsComplex}
\item Complex is better than complicated.\label{lst:ZoP:ComplexVsComplicated}
\item Flat is better than nested.
\item Sparse is better than dense.
\item Readability counts.\label{lst:ZoP:Readablity}
\item Special cases aren't special enough to break the rules~…\label{lst:ZoP:SpecialCases}
\item …~although practicality beats purity.\label{lst:ZoP:Practicality}
\item Errors should never pass silently and Exceptions may never be swallowed~…
\item …~unless explicitly silenced.
\item In the face of ambiguity, refuse the temptation to guess.
\item There should be one – and preferably only one – obvious way to do\\ it~…
\item …~although that way may not be obvious at first.
\item Now is better than never~…\label{lst:ZoP:Now}
\item …~although never is often better than \textit{right now}.\label{lst:ZoP:RightNow}
\item If the implementation is hard to explain, it's a bad idea.
\item If the implementation is easy to explain, it may be a good idea.
\item Think about your future self and add a comment.
\item Always do it right in the first place!\label{lst:BR:BasicRule}
\item Have Fun!
\end{enumerate}

One rule should be followed before any other rule or recommendation given in this document, that one listed as number \ref{lst:BR:BasicRule} above:\footnote{And that does not contradict with numbers~\ref{lst:ZoP:Now} and \ref{lst:ZoP:RightNow}!}

\begin{center}
\begin{huge}
\fbox{\textbf{Always do it right in the first place!}}
\end{huge}
\end{center}

Experiences with lots of programming projects has shown that programmers seldom touch their code again, once it is written.\footnote{Usually, they will return to the code only when it is broken – and then they want to fix the bug, not adding missing comments~…} As a result, missing comments will never be added, shady programming patterns would not be fixed – with the consequence that in case of a bug the maintainer is lost in a poorly documented chaos of badly formatted source code.

\textit{And this is exactly what we want to avoid!} 

This means there is never ever any excuse for omitting comments, using ‘temporary’ names or doing other ‘funny’ things. And we all know about all the quick and dirty PoCs that made it into a product without significant changes to the code~…

Of course you can interpret it also as “Don't make mistakes”, but we all now that humans make mistakes, and that it is unavoidable that our code will contain one or the other bug. So it means that you should \textit{do your best} to avoid mistakes, and the rules, guidelines and recommendation from this document will help you with that.

So again:

\begin{center}
\begin{huge}
\fbox{\textbf{Always do it right in the first place!}}
\end{huge}
\end{center}

\chapter{Formatting the Source Code}\label{sec:FormattingTheSourceCode}
This chapter deals with the proper formatting of Java source code. The formatting of comments is covered in chapter \tqfullvref{sec:WritingProperComments}.

I start the chapter with a description of the general structure of a source file, then I give some general conventions before I cover the formatting of single elements of the code.

\section{Java Source File Structure}
A file with Java source code consists of sections that should be separated by blank lines and a comment identifying each section.

Files longer than 2000~lines are cumbersome and should be avoided.\footnote{There are some well known scenarios where it is difficult to adhere with this limit. The first is with generated code, the other one is with classes having lots of attributes: the formatting style and coding guidelines proposed in this document require a least 5~lines for each attribute, 6~lines for each getter method and 11~lines for each setter method, always including all comments and blank lines. This is about 22~lines for each attribute. Nearly one hundred attributes seems to be a lot, but we have seen more than one real life application where database tables had more than that number of columns. I do not think that this is a good design anyway, but if our new Java class has to reflect the legacy data model, it has to have that number of attributes.}

Each Java source file contains a single \lstinline|public| class or interface. When \lstinline|private| top-level classes and interfaces are associated with a \lstinline|public| class, they can be put into the same source file as the \lstinline|public| class, although this is not recommended.\footnote{Usually, it should be considered to have these classes or interfaces as \textit{inner} classes/interfaces} In such a case, the \lstinline|public| class should be the first class or interface in the file.

The sections of a Java source file have the following ordering:

\begin{enumerate}[nosep]
\item{Beginning comments}
\item{Package and import statements}
\item{Class and interface declarations}
\item{Closing comment}
\end{enumerate}

\subsection{Beginning Comments}\label{sec:BeginningComments}
All source files have to start with a c-style comment that gives the copyright notice and the license information:\footnote{This is different from \autocite{SUN_CODE_CONVENTIONS:BeginningComments}; the Sun coding conventions recommend to put also the class name and the date into the beginning comment. I omitted the name of the class because this is obvious from the file name in case of a \lstinline|public| class, and it would confuse the reader if the file contains more than one class. The date is considered obsolete.}
\begin{lstlisting}[numbers=left,caption={Beginning Comment}]
/*
 * ==================================================================
 * Copyright © <Year> <Copyright Notice>
 * ==================================================================
 *
 * <License Notice>
 */
\end{lstlisting}
 
\verb#<Year>#, \verb#<Copyright Notice># and \verb#<License Notice># has to be replaced by the appropriate texts.\footnote{The special character \copyright is used not only because is looks better; it tells you immediately whether your environment is capable to deal with UTF-8 encoded files.}

The lines with the equals signs (“===”) will end at column 80; refer to chapter \tqfullvref{sec:LineLength}.

No other information should be added to this comment block.

\subsection{Package and Import Statements}

The first non-comment line of a Java source file is the \lstinline|package| statement\footnote{Production code will never use the default package, so there will be always a \lstinline|package| statement in every source file.}.

After that, usually several \lstinline|import| statements will follow. For example:

\begin{lstlisting}
package java.awt;

import static java.lang.String.format;
import static java.lang.System.out;
…

import java.awt.peer.CanvasPeer;
import java.io.InputStream;
…
\end{lstlisting}

Static imports has to be placed before imports for classes. Inside these blocks, the imports should be ordered alphabetically. Wildcard imports like

\begin{lstlisting}
import static java.lang.String.*;
…

import java.util.*;
…
\end{lstlisting}

are not allowed.

For the names of packages, see chapter \tqfullvref{sec:Packages}.

Eclipse users can use the function \verb#Source|Organize Imports# from the menu, or the short-key \verb#Shift+Ctrl+O#. This will reorder the import statements, explode the wildcards and remove unused imports; it will even add currently missing imports – given that this properly configured in the \verb#preferences# at \verb#Java|Code Style|Organize Imports#.

At IntelliJ~IDEA, the function \verb#Code|Optimize Imports# from the menu does something similar; the short key would be \verb#Ctrl+Alt+O#.

\subsection{Class and Interface Declarations}\label{sec:ClassAndInterfaceDeclarations}
At least since Java~5, there are not only classes and interfaces that are declared in a Java source file. We have

\begin{itemize}[nosep]
\item{classes (keyword \lstinline|class|)}
\item{interfaces (keyword \lstinline|interface|)}
\item{enums (keyword \lstinline|enum|)}
\item{records (keyword \lstinline|record|)}
\item{annotations (keyword \lstinline|@interface|)}
\end{itemize}

Each of these allows different parts in their declaration; the following tables describe the various parts and the order that they should appear in the files. Each part has a header comment, and inside each part, the elements are ordered alphabetically.

\subsubsection{Class}
A skeleton for a Java class may look like this:

\begin{lstlisting}[numbers=left,caption={Class Skeleton}]
public class MyClass 
{
        /*---------------*\
    ====** Inner Classes **==========================================
        \*---------------*/
    …    
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
            
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …            
}
//  class MyClass
\end{lstlisting}
 
\begin{filecontents}{ClassParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of a class declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Inner Classes (optional) & Given the class defines inner classes or interfaces, either \lstinline|private| or \lstinline|public|, they will come first. Internally, they will follow the same rules as their containing classes. \\ 
  \hline 
  Constants (optional) & This part takes all constants defined by this class (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here go the attributes for the class; technically, this part is in fact optional for a class, but usually a class without any attributes does not make much sense. Attributes are \lstinline|private| (under some exceptional circumstances, they can be \lstinline|protected|) and usually, they are not \lstinline|static|. \\ 
  \hline 
  Static Initialisations (optional) & If a class declares \lstinline|static| fields that are not mere constants or their initialisation is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block.
  
  This is also the right place for the serialVersionUID of a seria­lisable class. \\ 
  \hline 
  Constructors (optional) & All the constructors for the class go into this part. It is optional in case the class will have only an empty \lstinline|public| default constructor, but usually this will be coded, too. \\ 
  \hline 
  Methods (optional) & All methods of the class are in this part. Again, this part is technically optional, but classes without methods are barely useful.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{ClassParts.tbl}

\subsubsection{Interface}
A skeleton for an interface may look like this:

\begin{lstlisting}[numbers=left,caption={Interface Skeleton}]
public interface MyInterface 
{
        /*---------------*\
    ====** Inner Classes **==========================================
        \*---------------*/
    …
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  interface MyInterface
\end{lstlisting}
 
\begin{filecontents}{InterfaceParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an interface declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Inner Classes (optional) & Defining inner classes for an interface is discouraged, although there are some valid use cases for this. If the interface defines inner classes or interfaces, they have to be \lstinline|public| – classes have to be \lstinline|static|, too, and they will be the first part. Internally, they will follow the same rules as for top-level classes. \\ 
  \hline 
  Constants (optional) & This part takes all constants defined by this class (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time. \\ 
  \hline 
  Methods (optional) & All methods of the interface are in this part. Again, this part is technically optional, it can be omitted for so-called \textit{marker interfaces}.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{InterfaceParts.tbl}

\subsubsection{enum}
An \lstinline|enum| is a special case of a Java class. Usually it only contains the enumeration values, but it can have more components. A skeleton for a enum class may look like this:

\begin{lstlisting}[numbers=left,caption={enum Skeleton}]
public enum MyEnum 
{
        /*------------------*\
    ====** Enum Definitions **=======================================
        \*------------------*/
    …
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
        
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  enum MyEnum
\end{lstlisting}
 
\begin{filecontents}{EnumParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an enum declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Enum Definitions & This part is mandatory. Each \lstinline|enum| is an instance of the enum class. \\ 
  \hline 
  Constants (optional) & This part takes all additional constants defined by this enum (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here goes the attributes for the enum, if any. Each attribute has to be \lstinline|private final| and will be initialised by the constructor. \\ 
  \hline 
  Static Initialisations (optional) & If an enum declares \lstinline|static final| fields with an initialisation that is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block. \\
  \hline 
  Constructors (optional) & All the constructors for the enum (rarely there is more than one) go into this part, if any. A constructor has to \lstinline|private|. \\ 
  \hline 
  Methods (optional) & All methods of the class are in this part.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{EnumParts.tbl}

\subsubsection{Record}
Records had been introduced to Java with version~14. Like an enum, a record is a restricted form of a Java class. It’s ideal for “plain data carriers” classes that contain data not meant to be altered and has only the most fundamental methods such as constructors and accessors.\autocite{ORACLE_DOC_RECORD,ORACLE_DOC_LANGUAGE_SPECIFICATION:RecordClasses}

A skeleton for a Java record class may look like this, with all parts being optional:
\begin{lstlisting}[numbers=left,caption={Record Skeleton}]
public record MyRecord( ... ) 
{
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
        
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  record MyRecord
\end{lstlisting}
 
\begin{filecontents}{RecordParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of a record declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Constants (optional) & This part takes all constants defined by this record (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here go the attributes for the class; this part is optional, because usually, all attributes are defined as arguments to the \lstinline|record| definition. \\ 
  \hline 
  Static Initialisations (optional) & If a record declares \lstinline|static| fields that are not mere constants or their initialisation is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block. \\ 
  \hline 
  Constructors (optional) & If the record needs additional constructors, these go into this part. It is optional, because in most cases no additional constructor is need. \\ 
  \hline 
  Methods (optional) & All additional methods of the record are in this part. \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{RecordParts.tbl}

\subsubsection{Annotation}
Annotations had been introduced with Java~5.\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:AnnotationInterfaces} A skeleton for an annotation interface may look like this:

\begin{lstlisting}[numbers=left,caption={Annotation Skeleton}]
public @interface MyAnnotation 
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
                
}
//  @interface MyAnnotation
\end{lstlisting}
 
\begin{filecontents}{AnnotationParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an annotation declaration} \\
  \hline 
  Part & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{2}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  Part & Description \\ 
  \hline
  \endhead
  \multicolumn{2}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  Attributes (optional) & Here go the attributes for the annotation, if any. \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{AnnotationParts.tbl}

\subsection{Closing Comment}
A closing comment like
\begin{lstlisting}[numbers=left, caption={Closing Comment}]
/*
 *  End of File
 */
\end{lstlisting}
at the end of the source file is helpful to detect whether a source file was corrupted: if missing, there is a good chance that the file is incomplete.

I confess that this kind of error has got very unlikely with modern hard-drives, but it can still happen when sending around sources over the net.

\section{Indentation}
Indentation, together with empty lines, is the most important tool to structure any source code.

\subsection{Indentation Style}\label{sec:IndentationStyle}
I prefer the so-called GNU or BSD style and recommend it to you as well, because it makes it easier to detect the begin and the end of a code block. It demands to have the opening and closing curly braces on a line of their own, like this:

\begin{lstlisting}
public class MyClass
{
    public void method()
    {
        if( flag )
        {
            /* do something */
        }
        
        for( final var i = 0; i < max; ++i )
        {
            /* do something else */
        } 
    }   //  method()
}   //  class MyClass
\end{lstlisting}

\subsection{Indentation Size}
Four (4) spaces should be used as the unit of indentation. Tabs are \textit{not} allowed.\footnote{This is different from \autocite{SUN_CODE_CONVENTIONS}; the Sun Coding Convention do not explicitly specify whether to use blanks or tabs.} Usually this can be configured in your IDE; in Eclipse this is part of the \textit{Formatter} definition (\verb#Window|Preferences|Java|Code Style|Formatter#).

\subsection{Line Length}\label{sec:LineLength}
Some sources (including the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS}) recommend to avoid lines longer than 80 characters, because they were not handled well by many terminals and tools.

This had been true at the time those documents were written, but today's  graphical screens are much wider (sometimes even 200 characters can be put into one line), and modern tools do not even care about line length, so we do not want to recommend a fixed line length for source code.

\textbf{Note:} Sample code for use in documentation should have a limited line length – generally not more than 70 characters.

Different to that, comment lines are limited to 80 characters – or more precise, they have to end at column 80. All lines with “ASCII graphics” are extended to that column. This is pertaining to the beginning comments (chapter \tqfullvref{sec:BeginningComments}), the structuring comments (chapter \tqfullvref{sec:StructuringComments}) and most single-line comments (chapter \tqfullref{sec:SingleLineComments}).

\subsubsection{Wrapping Lines}\label{sec:WrappingLines}
When an expression does not fit on a single line, break it according to these general principles:
\begin{itemize}[nosep]
\item{Break after a comma.}
\item{Break before an operator.}
\item{Prefer higher-level breaks to lower-level breaks.}
\item{Align the new line with the beginning of the expression at the same level on the previous line.}
\item{If the above rules lead to confusing code or to code that's squished up against the right margin, just indent 8 (eight) spaces instead.}
\end{itemize}

Here are some examples of breaking method calls:
\begin{lstlisting}[numbers=left]
// USUAL
someMethod( longExpression1, longExpression2, longExpression3,
    longExpression4, longExpression5 );
        
// SINGLE LINE FOR EACH ARGUMENT
someMethod
( 
    longExpression1,
    longExpression2,
    longExpression3,
    longExpression4, // some comment
    longExpression5
);

// LONG EXPRESSIONS
var = someMethod1( longExpression1,
        someMethod2( longExpression2,
                longExpression3 ) );
\end{lstlisting}

Using a single line for each argument makes especially sense in cases where one or more expressions are really long, or if a comment should be added to the argument.

Next there are two examples of breaking an arithmetic expression. The first is preferred, since the break occurs outside the parenthesized expression, which is at a higher level.
\begin{lstlisting}[numbers=left]
// PREFER
longName1 = longName2 * (longName3 + longName4 - longName5)
           + 4 * longname6;
           
// AVOID!!!           
longName1 = longName2 * (longName3 + longName4
                       - longName5) + 4 * longname6;
\end{lstlisting}

Then we have three examples of indenting method declarations. The first is the conventional case. The second would shift the second and third lines to the far right if it uses conventional indentation, so instead it indents only 8 spaces. The final one uses a single line for each argument.

A throws clause will be either appended on the same line as the closing parentheses, or it can be on its own line with an indentation of four blanks.
\begin{lstlisting}[numbers=left]
// CONVENTIONAL INDENTATION
public void someMethod( int anArg, Object anotherArg,
    String yetAnotherArg, Object andStillAnother )
{
    …
}

public void otherMethod( int anArg, Object anotherArg,
    	String yetAnotherArg, Object andStillAnother )
    throws IllegalArgumentException, IOException
{
    …
}

// INDENT 8 SPACES TO AVOID VERY DEEP INDENTS
private static synchronized void horkingLongMethodName( int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother )
{
    …
}

private static synchronized void horkingLongMethodThrows( int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother ) throws IllegalArgumentException
{
    …
}

// SINGLE LINE FOR EACH ARGUMENT
private static synchronized anotherHorkingLongMethodLine
(
    int anArg,
    Object anotherArg,
    String yetAnotherArg,
    Object andStillAnother
)
{
    …
}

private static synchronized anotherHorkingLongMethodLineThrows
(
    int anArg,
    Object anotherArg,
    String yetAnotherArg,
    Object andStillAnother
) throws IllegalArgumentException, IOException
{
    …
}
\end{lstlisting}

Here are three acceptable ways to format ternary expressions\footnote{Read more about the ternary operator \lstinline|?| in chapter \tqfullvref{sec:TheTernaryOperator}.}:
\begin{lstlisting}[numbers=left]
alpha = (aLongBooleanExpression) ? beta : gamma;
alpha = (aLongBooleanExpression) ? beta
                                 : gamma;
alpha = (aLongBooleanExpression)
        ? beta
        : gamma;
\end{lstlisting}

\section{Declarations}
This chapter deals with the formatting of declarations. See also chapter \tqfullvref{sec:WrappingLines} for informations on how to wrap long declarations.

\subsection{Multiple Declarations per Line}
It is strongly encouraged to have only one declaration per line, as it is also comforting to add comments to the declaration. In other words, 
\begin{lstlisting}
int level; // indentation level
int size;  // size of table
\end{lstlisting}

is preferred over

\begin{lstlisting}
// AVOID!!!
int level, size;
\end{lstlisting}

Do not put different types on the same line, despite the compiler does not complain about it. Example:
\begin{lstlisting}
// WRONG!!!!
int foo, fooarray [];
\end{lstlisting}

\subsection{Array Declarations}
The brackets for an array declaration always have to be put to the type, not to the name. So it should read
\begin{lstlisting}
int [] foo;
String [] bar;
java.awt.Button [] buttons;
\end{lstlisting}
and not
\begin{lstlisting}
// AVOID!!!
int foo [];
// AVOID!!!
String bar [];
// AVOID!!!
java.awt.Button buttons [];
\end{lstlisting}
This is the same way as an array would be declared as the return value for a method:
\begin{lstlisting}
public final static String [] getTexts()
{
    return m_Texts;
}	//	getTexts()
\end{lstlisting}

\subsection{Placement of Declarations}
You should put declarations where there are needed; usually this means that it should be waited with the declaration of variables until their first use.\footnote{In this aspect, my point of view is completely contradicting to that of the authors of \autocite{SUN_CODE_CONVENTIONS}.}

This is true even for variables inside a loop:
\begin{lstlisting}
for( var i = 0; i < limit; ++i )
{
    final var a = getValue( i );
    …
}
\end{lstlisting}

Only the repeated initialisation of a variable inside a loop should be avoided, when possible:
\begin{lstlisting}[numbers=left]
// AVOID!
for( var i = 0; i < limit; ++i )
{
    final var a = new VeryComplexType();
    …
}
\end{lstlisting}
In this case, line~4 should be moved before the loop header (line~2).

Absolutely avoid local declarations that hide declarations at higher levels. For example, do not declare a variable with the same name as a field:
\begin{lstlisting}
public class MyClass
{
    int count;

    public void method()
    {
        if( condition )
        {
            int count = 0; // AVOID!
            // more code
        }
        // more code
    }
}   //  class MyClass
\end{lstlisting}
There are a settings for both Eclipse preferences and IntelliJ~IDEA that triggers a warning or even an error in such cases. In addition, the rules for the naming of fields (refer to chapter \tqfullvref{sec:Fields}) would make such a situation unlikely.

\subsection{Class and Interface Declarations}
When coding Java classes and interfaces, the following formatting rules has to be followed:
\begin{itemize}
\item{No space between a method or constructor name and the parenthesis “(” starting its formal parameters list.}
\item{If using generics, no space between the name of the class or interface and the opening “<”.}
\item{An open curly brace “{” appears at a line by itself with the same indentation as the declaration statement.}
\item{A closing curly brace “}” starts a new line, indented to match its corresponding opening statement; in case of a method or constructor declaration, it is followed by a comment with the name of the method. For classes or interfaces, the name of the class or interface is repeated in a new line after the closing brace.}
\item{Inner classes, constants, attributes, constructors, methods, they all are separated by a blank line (see chapter \tqfullref{sec:BlankLines}.}
\item{Short methods may be written in one single line. In this case, “one single line” means exactly that: \textit{one single} line! Any line break requires the full form as for the sample “composeCorrectKey()” below (line 28).}
\end{itemize}
An example:
\begin{lstlisting}[numbers=left]
class Sample extends Object implements Comparable<Sample>
{
    int ivar1;
    
    int ivar2;
    
    Sample( int i, int j ) 
    {
        ivar1 = i;
        ivar2 = j;
        …
    }  //  Sample()
    
    void method()
    {
        …
    }  //  method()
    
    // SHORT METHOD
    int getIVar1() { return ivar1; }
    
    // AVOID!!! Not a short method!
    String composeWrongKey( String component1, String component2,
                            String component3 ) { return component1
        + component2 + component3; }
        
    // Correct
    String composeCorrectKey( String component1, String component2,
                              String component3 )
    {
        return component1 + component2 + component3;
    }   //  composeCorrectKey()
}
//  class Sample
\end{lstlisting}

The comments at the end of the methods make it easier to navigate inside long source files, especially when scrolling upwards.

\section{White Space}
This chapter deals with the white space other than the indentation blanks.

\subsection{Blank Lines}\label{sec:BlankLines}
Blank lines improve readability by setting off sections of code that are logically related.
If not separated by an explicit comment, two blank lines should always be used in the following circumstances:
\begin{itemize}
\item{Between sections of a source file\footnote{Although this would hurt the rules for commenting as set in chapter \tqfullref{sec:StructuringComments}}}
\item{Between class and interface definitions}
\end{itemize}

One blank line should always be used in the following circumstances:
\begin{itemize}
\item{Between methods}
\item{Before a block or single-line comment}
\item{Between logical sections inside a method to improve readability}
\item{To group some code lines logically}
\end{itemize}
More than one blank line should be avoided, except for the case mentioned above.

\subsection{Parenthesis}\label{sec:Parenthesis}
We distinguish between arithmetical parenthesis and parameter parenthesis; the first is used in expressions to order the terms, the latter is used with method or constructor calls or in lambdas.

\paragraph{Arithmetical Parenthesis}–
An opening arithmetical parenthesis is always preceded by a blank or another opening parenthesis and never followed by a blank, a closing one is never preceded by a blank, but always followed either by another closing parenthesis, a blank, or a newline (or a semicolon, in case the statement ends).

\paragraph{Parameter Parenthesis}\label{sec:ParameterParenthesis}–
An opening parameter parenthesis is never preceded by a blank and ever followed by one, while a closing one is always preceded by one. The only exception is for empty arguments lists where the opening parenthesis is immediately followed by the closing parenthesis.

Regarding to this rule, \lstinline|if|, \lstinline|for|, \lstinline|while|, \lstinline|try| and \lstinline|switch| are treated like functions (see also chapter \tqfullref{sec:BlankLines}).\footnote{And also the keywords \lstinline|catch| and \lstinline|synchronized|, but they do not allow complex terms inside there 'argument list'.}

This rule can improve the readability of complex terms drastically, as the examples below will illustrate.

\begin{lstlisting}[numbers=left]
int v = (a + b) * 5;
double d = sin( (a + b) / c );
System.out.println( "Finished!" );
set( get() );
System.out.println( sin( ((a + b) * (c + 4) + c)) / d ) );
if( a < b ) c = (d + e) / sin( f );
while( ((line = reader.readLine()) != null) && (++i < capacity) )
    processLine( line );
\end{lstlisting}

\subsection{Blank Spaces}\label{sec:BlankSpaces}
Additionally, blank spaces should be used in the following circumstances:
\begin{itemize}
\item{With a keyword followed by a parenthesis, like \lstinline|if|, \lstinline|while|, \lstinline|for| etc. There is no blank space between the keyword and the opening parenthesis, but  between that parenthesis and the argument. Another blank space is between the (last) argument and the closing parenthesis. As a short it can be said that parenthesis for these keywords will be treated like parameter parenthesis, as already stated in \tqfullref{sec:ParameterParenthesis}.\footnote{This is in opposite to the sun codeing conventions \autocite{SUN_CODE_CONVENTIONS}; there it is recommended to have a blank between the keyword and the opening parenthesis while not using it between the method name and the opening parenthesis here, just to distinguish between keywords and methods calls. We think that it is more important to distinguish between parenthesis in arithmetical expressions and those in method calls.}

Examples:
\begin{lstlisting}[numbers=left]
while( true )
{
    …
}

for( int i = 0; i < 10; ++i ) { … }

try
{
    …
}
catch( Exception e )
{
    e.printStackTrace();
}

if( list.isEmpty() ) { … }
\end{lstlisting}}
\item{A blank space has to appear after commas in argument lists. The exception are generics where the comma is not followed by a blank space in case there is more than one type.

Examples:
\begin{lstlisting}[numbers=left]
Map<String,String> map = new HashMap<String,String>();
Map<String,String> map = new HashMap<>(); // using the diamond operator
map.put( key, value );
\end{lstlisting}}
\item{All binary operators except “.” has to be separated from their operands by spaces. Blank spaces should never separate unary operators such as unary minus, increment (“++”), and decrement (“--”) from their operands.

Example:
\begin{lstlisting}[numbers=left]
a += c + d;
a = (a + b) / (c * d);

while( d-- > s++ )
{
    ++n;
}

printSize( "size is " + foo + "\n" );
\end{lstlisting}}
\item{The expressions in a \lstinline|for| statement has to be separated by blank spaces after the semicolon.

Example:
\begin{lstlisting}
for( expr1; expr2; expr3 )
{
    …
}
\end{lstlisting}

For an extended for loop, blank spaces has to be placed around the colon, too:
\begin{lstlisting}[numbers=left]
for( String s : stringArray ) System.out.println( s );
\end{lstlisting}}
\item{For ternary statements, the question mark (“?”) and the colon (“:”) has to be surrounded by blank spaces:

Example:
\begin{lstlisting}
int signum = d < 0 ? -1 : d > 0 ? 1 : 0;
\end{lstlisting}

In this sample, some parentheses would be helpful, too.}
\item{Casts should be followed by a blank space. 

Examples:
\begin{lstlisting}
method( (byte) aNum, (Object) x);
method( (int) (cp + 5), ((int) (i + 3)) + 1 );
\end{lstlisting}}
\end{itemize}

\section{Statements}
Now we will have a look on how to format statements.

\subsection{Simple Statements}
Each line should contain at most one statement. Or, the other way round, each (simple) statement has to be written to its own line.

Example:
\begin{lstlisting}
// CORRECT
++argv;
--argc;

// AVOID!!!
--argv; --argc;
\end{lstlisting}

\subsection{Compound Statements}\label{sec:CompoundStatements}
Compound statements are statements that contain lists of statements enclosed in curly braces “{ statements }”. See the following sections for examples.

Here some general rules first:
\begin{itemize}
\item{The enclosed statements has be indented one more level than the compound statement.}
\item{The opening brace should be at a line of itself, indented to the same level as the compound statement.
Accordingly, the closing brace should begin a line and be indented to the beginning of the compound statement. The exception are short methods where all is one line (refer to chapter \tqfullvref{sec:ClassAndInterfaceDeclarations})}.
\item{Braces are used around all statements (meaning even if there is just one) when they are part of a control structure, such as a \lstinline|if-else| or \lstinline|for| statement. This makes it easier to add statements without accidentally introducing bugs due to forgetting to add braces.

The only exception from this rule is when a single statement is written on the same line as the compound statement itself.

Examples:

\begin{lstlisting}[numbers=left]
// Ok
if( a < b ) c = d;

// AVOID!!!
if( a < b ) c = d; else e = f;
if( a < b )
    c = d;
if( a < b )
    c = d;
else
    e = f;

// RECOMMENDED
if( a < b )
{
    c = d;
}
else
{
    e = f;
}

// Ok
for( String s : strings ) ++i;

// AVOID!!!!
for( String s : strings )
    ++i;

// RECOMMENDED
for( String s : strings )
{
    ++i;
}

// DISCOURAGED!!!
for( String s : strings ) if( a < b ) c = d;
\end{lstlisting}

See also the chapters \tqfullref{sec:IfStatements}, \tqfullref{sec:SwitchStatements}, and \tqfullref{sec:WhileStatements}.}

\item{Long compound statements (long code blocks) should get an end comment. See chapters \tqfullref{sec:LabelsAndBreakStatements}, \tqfullref{sec:TrailingOrEndOfLineComments}, and \tqfullref{sec:CommentsWhen}.} 
\end{itemize}

\subsection{“Chaining”}
The interface for some classes allow to chain methods. If it is especially designed to allow this, it is referred to as the “Builder pattern”. Examples for this are \lstinline|java.lang.StringBuffer|, \lstinline|java.lang.StringBuilder|, and since Java~5, also \lstinline|java.io.Writer| and the classes derived from that class.

“Chaining” would allow to write

\begin{lstlisting}
writer.append( "Caption\t: " ).append( value );
\end{lstlisting}

instead of

\begin{lstlisting}
writer.append( "Caption\t: " );
writer.append( value );
\end{lstlisting}

The formatting rules are as follows:
\begin{itemize}
\item{If the “chain” does not fit completely into a single line, each method call has to be written into a single line of its own (as in line 4 below}
\item{The dot has to be written in front of the method's name}
\item{The methods will be indented regularly}
\end{itemize}

Some samples:
\begin{lstlisting}[numbers=left]
// Acceptable
writer.append( "Caption\t: " ).append( value );

// RECOMMENDED
writer.append( "Caption\t: " )
    .append( value );
    
// WRONG: The dot is trailing!
writer.append( "Caption\t: " ).
    append( value );
\end{lstlisting}

Java~8 introduced Streams and those will be formatted in the same way.

Example:
\begin{lstlisting}[numbers=left]
final var names = customers.stream()
    .filter( c -> c.getCountry().equals( GERMANY )
    .filter( c -> c.getTurnover() > limit )
    .map( Customer::getName )
    .sorted()
    .toArray( String []::new );
\end{lstlisting}

\subsection{“return” Statements}
A \lstinline|return| statement with a value should not use parentheses unless they make the return value more obvious in some way. Please see also chapter \tqfullvref{sec:ReturningValues}!

Example:
\begin{lstlisting}[numbers=left]
// Usually obsolete
return;

// NOT RECOMMENDED
return myDisk.size();

// MAY BE OK
return (m_Size > 0) ? m_Size : m_DefaultSize; 

// BETTER
final var retValue = (m_Size > 0) ? m_Size : m_DefaultSize;
return retValue;

// AVOID!!!
return( retValue );

// RECOMMENDED; usually the only valid form 
return retValue; 
\end{lstlisting}

\subsection{“if”, “if-else”, “if-else~if-else” Statements}\label{sec:IfStatements}
The chapters \tqfullref{sec:Parenthesis}, \tqfullref{sec:BlankSpaces}, and \tqfullref{sec:CompoundStatements} covered already some aspects of the \lstinline|if-else| class of statements that may be repeated here again.

The base forms for this class of statements are the following ones:
\begin{lstlisting}[numbers=left]
if( <condition> )
{
    <statements>;
}

if( <condition>)
{
    <statements>;
}
else
{
    <statements>;
}

if( <condition1>)
{
    <statements>;
}
else if( <condition2>)
{
    <statements>;
}
else
{
    <statements>;
}
\end{lstlisting}

In case there are more conditions to check, but a \lstinline|switch| statement cannot be used due to the data types involved or the logic for the conditions, use the form in line 15.

The only occasion where an \lstinline|if| statement does not need the curly braces (“{}”) is when there is a single statement on the same line as the \lstinline|if| clause and there is no \lstinline|else| clause:

\begin{lstlisting}
if( <condition> ) <singleStatement>;
\end{lstlisting}

In any other case the curly braces are mandatory, to avoid the following error-prone forms:

\begin{lstlisting}[numbers=left]
// AVOID! MISSING CURLY BRACES {}!
if( <condition> )
    <statement>;

// AVOID!!! EVEN WORSE THAN ABOVE!!    
if( <condition> )
    <statement>;
else
    <statement>;
\end{lstlisting}

Please refer also to chapter \tqfullvref{sec:TheTernaryOperator} that discusses the ternary “?” operator.


\subsection{“switch” Statements}\label{sec:SwitchStatements}
Beginning with the first preview in Java~12, an alternative syntax for \lstinline|switch| was introduced, so that we have now two (in fact, three) different forms of that construct.

\subsubsection{The traditional Form of “switch”}
Originally, a \lstinline|switch| statement in Java looked like this:
\begin{lstlisting}[numbers=left]
switch( <selector> )
{
    case <switchlabel1>:
        <statements>;
        // Falls through!

    case <switchlabel2>:
        <statements>;
        break;

    case <switchlabel3>: <singleStatement>; break;

    case <switchlabel4>:
    {
        <statements>;
        break;
    }

    case <switchlabel5>: // Also a fall-through
    case <switchlabel6>:
    {
        <statements>;
        break;
    }

    default:
       <statements>;
       break;
}
\end{lstlisting}

If a \lstinline|case| falls through, as in line~4, a comment “\lstinline|// Falls through!|” as in the sample is mandatory! In fact, this construct should be avoided when possible, because it also forces a special sequence of the \lstinline|case| clauses – requiring an additional comment to the \lstinline|switch| itself.

Different to that, no comment is required in the case shown in the lines~19 and 20: here we have two case that triggers the \textit{exactly the same} action.

For longer \lstinline|switch| statements it is highly recommended to use a label with the \lstinline|break| statement\footnote{In fact, I recommend to use always a label with \lstinline|break|; see chapter \tqfullref{sec:LabelsAndBreakStatements} on this topic.}; this can look like this:
\begin{lstlisting}
final Color color;
ColorSelector: switch( colorIndex )
{
    case 1: color = RED; break ColorSelector;
    case 2: color = BLUE; break ColorSelector;
    case 3: color = YELLOW; break ColorSelector;
    case 4: color = GREEN; break ColorSelector;
    default: color = NONE; break ColorSelector;
}   //  ColorSelector:
\end{lstlisting}

The break in the default case is redundant, but it prevents a fall-through error if later another case is added – although it should be assured that the default case is always the last case in the switch statement. Of course no \lstinline|break| is required when the branch is left by throwing an exception.

\subsubsection{The new Form of “switch”}
The alternative syntax for \lstinline|switch| comes in two flavours and looks like this:

\begin{lstlisting}[numbers=left]
// switch statement
switch( <selector> )
{
    case <switchlabel1> -> <singleStatement>;

    case <switchlabel2>, <switchlabel3> -> <singleStatement>;

    case <switchlabel4> ->
    {
        <statements>;
    }

    case <switchlabel4>, <switchlabel5> ->
    {
        <statements>;
    }

    default -> <singleStatement>;
}

// switch expression
var result = switch( <selector> )
{
    case <switchlabel1> -> <expression>;

    case <switchlabel2>, <switchlabel3> -> <expression>;

    case <switchlabel4> ->
    {
        <expressions>;
        yield <value>;
    }

    case <switchlabel4>, <switchlabel5> ->
    {
        <expressions>;
        yield <value>;
    }

    default -> <expression>;
}
\end{lstlisting}

Of course the \lstinline|default| in line~18 can be followed by a statement block as the \lstinline|case| in line~8, and the \lstinline|default| in line~40 can have a complex expression like the \lstinline|case| in line~28.

If used with pattern matching (refer to \autocite{ORACLE_DOC_PATTERNMATCHING}), it looks like this:

\begin{lstlisting}[numbers=left]
var selector = <anObject>
// switch statement
switch( selector )
{
    case null -> <singleStatement>;
    case <class1> <name1> -> <singleStatement>;

    case <class2> <name2> ->
    {
        <statements>;
    }

    default -> <singleStatement>;
}

// switch statement
var result = switch( selector )
{
    case null -> <expression>;
    case <class1> <name1> -> <expression>;

    case <class2> <name2> ->
    {
        <expressions>;
        yield <value>;
    }

    default -> <expression>;
}
\end{lstlisting}

Same as for \lstinline|default|, \lstinline|case null| can be followed by a statement block or a complex expression.

And an expression can also be always a \lstinline|throw|.

\subsubsection{General Rules for “switch”}
Every \lstinline|switch| statement should include a \lstinline|default| case, even when the cases are exhaustive.

If really all values are covered, the \lstinline|default| should throw an exception about an unknown value.\footnote{Refer to chapter \tqfullref{sec:UnsupportedEnumError} for a sample.}

Syntactically, the use of curly braces in the cases is optional, even for multi-line statements, but here it is set as mandatory. One reason is that it allows to declare additional variables for a given branch that are local to the given branch.

\subsection{“for” Statements}
A \lstinline|for| statement should have one of the following forms:

\begin{lstlisting}[numbers=left]
// Classic for loop:
for( <initialization>; <condition>; <update> )
{
    <statements>;
}
for( <initialization>; <condition>; <update> ) <singleStatement>;

// Enhanced for loop:
for( <declaration> : <iterable> )
{
    <statements>;
}
for( <declaration> : <iterable> ) <singleStatement>;
\end{lstlisting}

This means that curly braces have to be used in any case when more than one statement has to be executed in the loop. In addition, this single statement has to be written completely into the same line as the \lstinline|for| itself. 

Examples:
\begin{lstlisting}[numbers=left]
// Ok
for( var i = 0; i < max; ++i ) sum += i;
for( final var s : texts ) System.out.println( s );

// DISCOURAGED
for( var i = 0; i < max; ++i ) if( v [i] > 0 ) sum += v [i];
for( final var s : texts ) if( !s.empty() ) out.println( s );

// AVOID!!!
for( var i = 0; i < max; ++i ) if( v [i] > 0 )
{
    sum += v [i];
}
else
{
    sum -= v [i];
}

for( final var s : texts ) if( !s.empty() )
{
    System.out.print( "Value: " );
    System.out.println( s );
}
\end{lstlisting}
The samples in lines~6 and 7 are correct according to this rule, but as said in the comment above them, their use is discouraged and therefore it should be avoided, too.

An empty \lstinline|for|-loop (one in which all the work is done in the initialization, condition, and update clauses) should have the following form:\footnote{An \textit{enhanced} \lstinline|for|-loop without body does not make that much sense (that mentioned above is a classical \lstinline|for|-loop). It may be possible to write an implementation of \lstinline|java.lang.Iterable| with an iterator that does something as a side effect of \lstinline|hasNext()| or \lstinline|next()|, but this would break the contract of the interface \lstinline|java.lang.Iterator|.}

\begin{lstlisting}
for( <initialization>; <condition>; <update> );
\end{lstlisting}

When using the comma operator in the initialization or update clause of a \lstinline|for| statement, avoid the complexity of using more than three variables. If needed, use separate statements before the \lstinline|for|-loop (for the initialization clause) or at the end of the loop (for the update clause).

\subsection{“while” Statements}\label{sec:WhileStatements}
A \lstinline|while| statement should have one of the following forms:
\begin{lstlisting}[numbers=left]
while( <condition> ) <singleStatement>

while( <condition> )
{
    <statements>;
}
\end{lstlisting}

Again, the curly braces can only be omitted in case there is only a single statement, written on the same line than the \lstinline|while| statement, that has to be executed in the loop.

An empty \lstinline|while|-loop\footnote{An empty \lstinline|while|-loop usually makes no sense as the compiler optimises it away. Only when the condition causes side effects, it will be executed. But such an implementation is difficult to understand and should be avoided.} should have the following form: 
\begin{lstlisting}
while( <condition> );
\end{lstlisting}

Longer \lstinline|while|-loops should use a label:
\begin{lstlisting}
LoopLabel: while( proceed )
{
    // Lots of code lines here …
}   //  LoopLabel:
\end{lstlisting}

\subsection{“do-while” Statements}
A \lstinline|do-while| statement should look like below:
\begin{lstlisting}
do
{
    <statements>;
}
while( <condition> );
\end{lstlisting}

\subsection{“try-catch” Statements}
Basically, there are two different forms of \lstinline|try-catch| statements: the simple one and the \lstinline|try-with-resources| that was introduced with Java~7 (also refer to chapter \tqfullvref{sec:TryWithResources}).

\subsubsection{The simple Form}
A simple \lstinline|try-catch| statement has the following format:
\begin{lstlisting}
try
{
    <statements>;
}
catch( <ExceptionClass> e )
{
    <statements>;
}
\end{lstlisting}

\subsubsection{“try-with-resources”}
A \lstinline|try-with-resources| allows to allocate resources that will be automatically released when the \lstinline|try| block is left. Something similar could be achieved also by adding a \lstinline|finally| block, but \lstinline|try-with-resources| is easier and more secure.

If looks like this:

\begin{lstlisting}[numbers=left]
try( final var resource = new <ResourceClass>() )
{
    <statements>;
}

final var resource = new <ResourceClass>();
try( final var r = resource )
{
    <statements>;
}
\end{lstlisting}

\lstinline|<ResourceClass>| must implement \lstinline|java.lang.Autocloseable|.

It is possible to allocate more than one resource in a single \lstinline|try| statement:
\begin{lstlisting}
try
( 
    final var resource1 = new <ResourceClass1>(); 
    final var resource2 = new <ResourceClass2>() 
)
{
    <statements>;
}
\end{lstlisting}

A \lstinline|catch| block is optional for \lstinline|try-with-resources|.

\subsubsection{General Rules for “try-catch”}
In case the \lstinline|try| block can issue more than one exception type, these can be combined into one \lstinline|catch| block, like this:
\begin{lstlisting}
…
catch( <ExceptionClass1> | <ExceptionClass2> e )
{
    <statements>;
}
\end{lstlisting}

if all exceptions are handled by the same set of statements, or like this, when the exceptions are handled by different code blocks:

\begin{lstlisting}
…
catch( <ExceptionClass1> e )
{
    <statements>;
}
catch( <ExceptionClass2> e )
{
    <statements>;
}
\end{lstlisting}

Of course both can be combined:

\begin{lstlisting}
…
catch( <ExceptionClass1> | <ExceptionClass2> e )
{
    <statements>;
}
catch( <ExceptionClass3> e )
{
    <statements>;
}
\end{lstlisting}

Each \lstinline|try-catch| statement can also be followed by a \lstinline|finally| block, which  executes regardless of whether or not the \lstinline|try| block has completed successfully.

\begin{lstlisting}
try
{
    <statements>;
}
catch( <ExceptionClass> e )
{
    <statements>;
}
finally
{
    <statements>;
}
\end{lstlisting}

In case a \lstinline|finally| block is present, the \lstinline|catch| block is optional even for a simple \lstinline|try-catch| statement, meaning that no exception is caught:
\begin{lstlisting}
try
{
    <statements>;
}
finally
{
    <statements>;
}
\end{lstlisting}

An \textit{empty} \lstinline|catch| block is unacceptable under all circumstances! Refer to chapter \tqfullvref{sec:GeneralExceptionHandling} how to handle exceptions. See also chapter \tqfullvref{sec:SingleLineComments} about empty blocks and comments.

An empty \lstinline|finally| block is completely obsolete and must be removed.

\subsection{Labels and “break” Statements}\label{sec:LabelsAndBreakStatements}
In Java, labels are mainly used in conjunction with \lstinline|break| and \lstinline|continue| statements, but they can be placed anywhere in a code block.

The \lstinline|break| statement is used with the traditional \lstinline|switch| statement (refer to chapter \tqfullref{sec:SwitchStatements}), and – together with the \lstinline|continue| statement – with loops of all kind.\footnote{The use of \lstinline|break| and \lstinline|continue| with loops is usually discouraged, but in many cases it makes the logic of an algorithm easier and more understandable.}

I recommend to always use a meaningful label together with \lstinline|break| and \lstinline|continue|. This would make it more obvious what is intended with the \lstinline|break| or \lstinline|continue|, and it assures that the right block will be terminated. The label can also be used as the end comment for a code block, as described in chapter \tqfullref{sec:TrailingOrEndOfLineComments} and chapter \tqfullref{sec:CommentsWhen}.

Some samples:
\begin{lstlisting}[numbers=left]
// BAD!!!
for( var line = 0; line < maxLines; ++line )
{
    for( var column = 0; column < maxColumns; ++column )
    {
        if( !isValid( field [line] [column] ) break; // What??
        …
    }

    processLine( field [line] );
}

// RECOMMENDED
LineLoop: for( var line = 0; line < maxLines; ++line )
{
    ColumnLoop: for( var column = 0; column < maxColumns; ++column )
    {
        if( !isValid( field [line] [column] ) break ColumnLoop;
        …
    } //  ColumnLoop:
    processLine( field [line] );
} // LineLoop:

// RECOMMENDED
FilterLoop: while( input.hasNext() )
{
    final var value = input.next();
    if( !value.isValid() ) continue FilterLoop; // Skip invalid
    …
} // FilterLoop:

// RECOMMENDED
DirectionSwitch: switch( direction )
{
    case LEFT: goLeft(); break DirectionSwitch;
    case RIGHT: goRight(); break DirectionSwitch;
    default:
        throw new IllegalArgumentException( direction.toString() );
} //  DirectionSwitch:
\end{lstlisting}

The name of the label is repeated in a comment at the end of the code block, as shown in lines~20, 22, 30, and 39. The colon at the end of the label name is mandatory for this kind of comment.

\section{Special Files}
Beside the files that contain the Java source code (with the extension \verb#.java#), a project can contain several other files.

\subsection{The Module Definition}\label{sec:ModuleDefinition}
Modules have been introduced to Java with version 9, as a result of the Jigsaw project. A module will be defined in the file \verb#module-info.java# that is located in the root of the source tree. Details can be found in \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ModuleDeclarations}.

Basically, a \verb#module-info.java# file will look like this:
\begin{lstlisting}[numbers=left, caption={module-info.java},morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield}]
/*
 * ==================================================================
 * Copyright © <Year> <Copyright Notice>
 * ==================================================================
 *
 * <License Notice>
 */
 
/**
 *  <module description>
 */ 
module <modulename> 
{
    requires <name_of_required_module_1>;
    requires <name_of_required_module_2>;

    requires transitive <name_of_required_module_3>;

    exports <name_of_exported_package_1>;
    exports <name_of_exported_package_2> to <name_of_target_module_1>;

    opens <name_of_opened_package_1>;
    opens <name_of_opened_package_1> to <name_of_target_module_1>, <name_of_target_module_2>;

    uses <name_of_provider_interface>;
    provides <name_of_provider_interface> with <name_of_provider_implementation>;
}
//  module <modulename>

/*
 *  End of File
 */
\end{lstlisting}
How to define the name of the module (\lstinline|<modulename>|) is covered in chapter \tqfullvref{sec:Modules}.

The \verb#<module description># will be discussed in chapter \tqfullvref{sec:ModuleComment}.

\subsection{The Package Documentation}\label{sec:PackageDocumentation}
Different from the module, there is no special source file that defines a package in Java. Instead all source files that are located in the same folder on the directory tree for the source code are in the same \lstinline|package|.

Nevertheless there is a need for package-level documentation, and it is even possible to set annotations to packages.

For the documentation of a package, originally a file named \verb#package.html# was used, placed into the package folder. Although this still works, you should use the new \verb#package-info.java# file instead, because only this allows annotations on package level; it looks like this:

\begin{lstlisting}[numbers=left, caption={package-info.java}]
/*
 * ==================================================================
 * Copyright © <Year> <Copyright Notice>
 * ==================================================================
 *
 * <License Notice>
 */
 
/**
 *  <package description>
 */
@<AnAnnotation> 
package <packagename>;

import <AnAnnotation>

/*
 *  End of File
 */
\end{lstlisting}

The \verb#<package description># is a standard JavaDoc comment (refer to the chapter \tqfullvref{sec:DocumentationComments}) and can be as lengthy as necessary. It will be discussed in detail in chapter \ref{sec:PackageComment}.

If the package is annotated\footnote{I recommend to used the \lstinline|@API| annotation even on the package level (refer to chapter \tqfullvref{sec:APIAnnotation} for details).}, the annotations have to be placed directly before the \lstinline|package …| line, and the imports for the annotations follow below.

How to define the name of the package (\lstinline|<packagename>|) is covered in chapter \tqfullvref{sec:Packages}.

\chapter{Naming Conventions}
Naming conventions make programs more understandable by making them easier to read. They can also give information about the function of the identifier – for example, whether it's a constant, package, or class – which can be helpful in understanding the code.

\section{General Accords}
The first rule about the naming of program elements is to use \textit{meaningful names}. But “meaningful” is a relative term, depending from context and experience. So the abbreviation “TSU” for a class name is just a cryptic three-letter-acronym for someone in the banking business while for people from the warehouse \& logistics domain no further explanation is required.\footnote{“TSU” stands for “Transport and Storage Unit” and is something like an abstract container of goods for a Warehouse Management System (WMS).} So we want to enhance this rule as we say that the name of a program element has to be meaningful for as many people as possible – even outside the current problem domain.

Additionally, names provide an implicit contract\footnote{If it is not a binding contract, so it is at least a kind of commitment.} between the original author of a program and its users/maintainers. So we expect that a method named \lstinline|read()| will \textit{read} something from somewhere. When it will perform write operations instead, that means this implicit contract is broken; at least, it requires an elaborate comment explaining why it \textit{writes}.

But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts to this document, together with a list of suffixes for class names. Refer to chapter \tqfullvref{sec:TheNamingDictionary} in the appendices for those lists.

The details on how names and identifiers are composed in Java, and where they are used can be taken from the respective chapter of the Java Language Speficication \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:NamesAndIdentifiers}.

But however, names like \lstinline|MyClass|, \lstinline|mypackage| or \lstinline|myMethod| may look good in some sample code (like in the sample listings in this document), but they are definitely invalid for real code!

\subsection{Language}
The identifier names has to be taken from English language, and with correct spelling.\footnote{I am conscious about the fact that there are differences between British and American English (at least between these two~…) and their spelling. “Correct spelling” means “correctly spelled according to at least one variant”. Decide for one spelling scheme and stuck with it. I personally use American English for the names.} Consult a dictionary if in doubt of spelling and/or meaning.

The reason to use English is that this is the common language for most international teams.

But even if you are working in an environment where English is a foreign language, solely with people speaking all the local language, using English still has a big advantage: you can distungiush just by the language if someone talks about the ‘real world’ object or its representation in the program.\footnote{From a specification document: “Ein Konto wird repräsentiert durch ein Objekt der Klasse \lstinline|Account|, der Kontoinhaber entsprechend durch ein Object der Klasse \lstinline|AccountOwner|.” – If you do not understand German, the translation is like this: “An account will be represented through an object of the class \lstinline|Account|, and the account owner by an object of the class \lstinline|AccountOwner|, respectively.” Or short: an account is an \lstinline|Account|; in writing, this looks good, but in oral communications, misunderstandings are easy. }

\subsection{UPPERCASE, lowercase, CamelCase}
Use CamelCase, starting with a capital letter, for the identifiers of all kinds of classes. For fields, local variables, and methods, use camelCase (starting with a lowercase character). For packages and modules, all lowercase is preferred, although not mandatory.

The Java coding convention \autocite{SUN_CODE_CONVENTIONS} demands all uppercase for constants and separating words with underscores, and usually this is implicitly expanded to enum values, too\footnote{The “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS} were last updated in 1999, enums had been introduced with Java~5, and that was released at 2004-09-29~…}. I prefer a more relaxed approach for that – see chapters \tqfullvref{sec:Constants} and \tqfullvref{sec:EnumValues}.

Details are again discussed in the chapter about the respective code elements.

\subsection{Length of Names and Use of Abbreviations}\label{sec:LengthOfNamesAndUseOfAbbreviations}
One aspect of abbreviations has been discussed already above. In general, avoid abbreviations and acronyms if those are not \textit{very well known}.

The length of a name has very little to no influence on the size and speed of the compiled code. And with the code completion features provided by modern IDEs, the programmer may not even have to type long names~…

This means that you will never sacrifice the meaningfulness of a long name for typing speed – never ever!

If you think you will be more productive when using short names (because you can type them faster~…), you are wrong! When you have the feeling that you have to write code faster, learn typewriting\footnote{For my understanding, someone who does not reach at least 100 CPM should look for a job outside of software development (average values for a trained user are around 200 CPM, peak values are at 500 to 900 CPM)}. It will also help you to write all the other stuff you have to deliver in addition to your code (documentation, meeting notes, emails, specification documents,~…).

But of course Java programs do have a maximum length for identifiers\footnote{Although the Java Language Specification does not impose such a limit: “An \textit{identifier} is an unlimited-length sequence of \textit{Java letters} and \textit{Java digits}, the first of which must be a \textit{Java letter}.” (\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Identifiers})}, although it is with 64k higher than any practical use case. I think that a name for a module, package, class, method, field, constant, argument, or local variable that is longer than 100 or perhaps 150 characters is definitely too long to be useful.

\subsection{Special Characters}
Avoid special characters and punctuations in identifiers; the only exception are underscores for constants (see chapter \tqfullvref{sec:Constants}) and for the “m\_” prefix for fields (see chapter \tqfullvref{sec:Fields}) and a single dollar symbol (“\$”) in lambdas (see \tqfullvref{sec:Lambdas}). This, too, is a reason for using English for the names and identifiers: usually, you can limit yourself to the ASCII character set.

\subsection{“test” as Part of Names}
Avoid “test” as the part of the name of packages, classes, interfaces and methods that belong to the production code. For testers and for members of the test suite packages, it is allowed or even required, depending on the testing framework used. Also it may be recommended or even required if you write your own testing framework or extensions to an existing one.

\subsection{Names forced by 3\textsuperscript{rd} Party Components}
Most Java programs do not exist in a vacuum, they have links to other components (like databases, messaging systems, or the real world). These components may have different naming conventions, whether due to technical or historical reasons, or just because the names are as they are. In such case, the foreign names should get hidden through aliases, like constants or getter methods, whose names are following these naming conventions. This is even made easier as those external names are usually used as Strings in the program.

\section{Modules}\label{sec:Modules}
A module will be defined in the file \verb#module-info.java# that is located in the root of the source tree; see chapter \tqfullvref{sec:ModuleDefinition} and \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ModuleDeclarations} for the details.

Each module has a main package, and this should be also the name of that module. If the module will export any packages at all\footnote{A module for a program is not required to export anything.}, it has to export at least this main package.

So the names for modules will follow basically the same rules as those for packages.

\section{Packages}\label{sec:Packages}
According to the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS} the prefix of a unique package name is always written in all-lower-case ASCII letters and should be one of the top-level domain names (TLDs), currently “\verb#biz#”, “\verb#com#”, “\verb#edu#”, “\verb#gov#”, “\verb#int#”, “\verb#mil#”, “\verb#net#”, “\verb#org#”, or one of the two-letter codes identifying countries as specified in ISO Standard 3166, 1981.\footnote{There exist some more TLDs, but these are quite unlikely to be used in a package name. But of course, if you own a domain under this top-level domain, you can use that as well.}

Usually the second component is the company's or organisation's name as it appears in its website address, again in all lower case. This helps to ensure that packages will have a unique name across separate organisations.

Subsequent components of the package name vary according to an organization's own internal naming conventions. Such conventions might specify that certain directory name components be division, department, project, machine, or login names. Here also only lower case should be used.

Valid samples are:
\begin{itemize}[nosep]
\item\verb#org.tquadrat#
\item\verb#com.ibm#
\item\verb#com.sun#
\item\verb#de.jug#
\item\verb#uk.gov.hmrc#
\end{itemize}

Of course you should use your domain name! Those from the samples are already used by the respective companies or organisations (or persons).

Subsequent components of the package name vary according to an organisation's own internal naming conventions. Such conventions might specify that certain directory name components be division, department, project, machine, or login names. Here also only lower case should be used.

Next, a package name is also a folder name: the file with the source code for the class \lstinline|com.foo.bar.internal.MyImpl| is located in the folder \verb#com/foo/bar/internal# in the source code directory tree.

Finally the package name should reflect somehow the function of that package.

\subsection{The Packages “internal” and “spi”}
The modularisation that was introduced with Java~9 allows a much clearer separation of an API from its implementation. Let's assume that your module exports the package \lstinline|com.foobar.library|, then this package contains the interfaces of the API, plus some public helper classes, while the non-public package \lstinline|com.foobar.library.internal| contains the implementation classes and internal helpers.

If the API is extensible, an additional package \lstinline|com.foobar.library.spi| contains the stuff that is needed to extend the API. It can be exported globally or only to some other named modules.

For the details, refer to chapter \tqfullvref{sec:EncapsulationWithModules}.

\section{Classes}\label{sec:Classes}
In Java, classes, interfaces, enums, records and annotations are all “classes”, and the names for a class will be written in mixed case (also known as “camel case”) with the first letter capitalized (\lstinline|MyClass| instead of \lstinline|myClass|). Try to keep your class names simple and descriptive. Use whole words, mainly nouns, and avoid acronyms and abbreviations, unless the abbreviation is much more widely used than the long form, such as URL or HTML.

According to the Java syntax specification, several special characters are allowed also for class names, but this coding convention forbids them – even the underscore (“\_”)!\footnote{Especially the dollar sign (“\$”) can cause serious issues as this is used internally for the names of inner classes and anynomous classes, as well as for the classes that will be generared for lambdas.}

You should also avoid numerical characters in class names.

\subsection{Names for ‘real’ Classes}\label{sec:NamesForClasses}
The term ‘real’ class means that this class is declared with the keyword \lstinline|class|. Record and enum classes are also Java classes, to some extent even interfaces and annotations, but you use a different keyword when you declare them.

Some parts of a class name will indicate a special position of that class in the class hierarchy. So the suffix ‘Impl’ for the class name \lstinline|FooImpl| shows that the class is the default implementation of an interface named \lstinline|Foo|, either being the only one, or providing useful default implementations of the interface methods\footnote{Although in the latter case, the name is more likely to be \lstinline|FooBase|.}.

‘Adapter’ as the suffix is similar, but here the methods are usually empty, as it is assumed that only a few of the methods of the interface are really required; various samples for this could be found in the Swing packages.

A suffix ‘Base’ indicates that the class has to be extended; usually that class is \lstinline|abstract|.

Other suffixes indicate special usage of the class. Well known and obvious are the suffixes ‘Error’ and ‘Exception’ for error and exception classes. Others are ‘Visitor’, and ‘Listener’ for the implementations of the respective patterns, ‘DAO’, or ‘Entity’. A more complete list can be found in chapter \tqfullvref{sec:SuffixesForClassNames} in the appendices. Most of these suffixes are defined by the design patterns that are implemented by the respective classes.

\subsection{Names for Interfaces}\label{sec:NamesForInterfaces}
An interface declares the public API for an object that represents a \textit{real world entity}, and it should be named according to that entity.

According to the Java Language Specification\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Declarations}, the name of an interface should be basically a descriptive noun or noun phrase, which is appropriate when an interface is used as if it is an abstract superclass, such as the interfaces \lstinline|java.io.DataInput| and \lstinline|java.io.DataOutput|; or it may be an adjective describing a behavior, as for the interfaces \lstinline|java.lang.Runnable|\autocite{ORACLE_DOC_RUNNABLE_INTERFACE} and \lstinline|java.lang.Cloneable|\autocite{ORACLE_DOC_CLONEABLE_INTERFACE}.

Some coding conventions (particularly in the Windows realm) require the prefix ‘I’ for interfaces, but it does not make much sense to mark interfaces in such way. Therefore it is not recommended to use such a prefix for the names of interfaces.

\subsection{Names for enum Classes}\label{sec:NamesForEnumClasses}
An enum is a special class that will be declared with the keyword \lstinline|enum|.

The name of enum class should be somehow the category of the enumerated entities, but plurals should be avoided; so it should read \lstinline|Type| and not \lstinline|Types|, and \lstinline|DayOfWeek| and not \lstinline|DaysOfWeek|.

Although an enum class can implement an interface, this should not be reflected in the name. This means that \lstinline|TypeImpl| would be an invalid name for an enum class.

For the naming of the enum values refer to chapter \tqfullref{sec:EnumValues}.

\subsection{Names for Record Classes}\label{sec:NamesForRecordClasses}
A record class can implement an interface, like a regular class, so that the suffix ‘Impl’ would be valid in such case. But as record classes are implicitly \lstinline|final|, ‘Base’ is not permitted, as well as any other suffix indicating a class that should be extended.

Also a record class should not be named ‘Record’.

\subsection{Names for Annotations}\label{sec:NamesForAnnotations}
Annotations are a special type of an interface, distinguished by the “@” as the first character of their name. The remaining part of the name is determined by the rules for regular interfaces. Samples for valid names are \lstinline|@Text|, \lstinline|@Translation|, \lstinline|@Generated|\footnote{see \autocite{ORACLE_DOC_GENERATED_ANNOTATION}}, or \lstinline|@Deprecated|\footnote{see \autocite{ORACLE_DOC_DEPRECATED_ANNOTATION}}.

\section{Methods}\label{sec:NamesForMethods}
Method names have to be a verb plus one or more nouns indicating the object of the operation performed by the respective method, eventually combined with adjectives or additional verbs. The name will be in mixed or camel case with the first letter in lower case, and with the first letter of each internal word capitalized.

The name of a method has to describe what is does; a name like \lstinline|myMethod()| or \lstinline|doSomething()| are discouraged\footnote{Nevertheless, both are used throughout this document as sample names for methods, but just as a place holder for a meaningful method name, and definitely \textit{not} as an example for the naming of a method.}.

Chapter \tqref{sec:TheNamingDictionary} beginning on page \pageref{sec:TheNamingDictionary} contains the “Naming Directory” for method names; that is a list of verbs together with their implicit contract. It is highly recommended to refer to this list when searching a name for a new method.

Using digits in method names is acceptable were it makes sense; so using the digit '4' as replacement for the word “for”, and '2' for the word “to” is acceptable, but not really recommended. Remember that digits are not allowed as first characters of a method name.

Regarding to “Data Objects” there are two different schools: one supports the JavaBean\footnote{see \autocite{ORACLE_DOC_JAVABEANS}} approach, using explicit getter and setter methods:
\begin{lstlisting}[numbers=left,caption={JavaBean}]
class JavaBeanDO
{
    private Object m_Attribute;

    public final Object getAttribute() { return m_Attribute; }

    public final void setAttribute( final Object value )
    {
        if( isNull( value ) ) 
        {
            throw new NullArgumentException( "value" );
        }
        m_Attribute = value;
    }   //  setAttribute()
}
//  class JavaBeanDO
\end{lstlisting}

The other one is in favour of the Property concept, using two methods with the attribute name, but with different signatures as implicit getter and setter methods (here usually named as 'accessor' and 'mutator'):\footnote{I use the term \textit{POJO} (“Plain Old Java Object”) here only to distinguish this approach from a JavaBean; usually, POJOs do not make any assumption about the naming of their methods. This means that a real POJO can have getters and setters, too.}

\begin{lstlisting}[numbers=left,caption={POJO}]
public class PropertyDO
{
    private Object m_Attribute;

    public final Object attribute() { return m_Attribute; }

    public final void attribute( final Object value )
    {
        if( isNull( value ) ) 
        {
            throw new NullArgumentException( "value" );
        }
        m_Attribute = value;
    }	//	attribute()
}
//  class PropertyDO
\end{lstlisting}

Both approaches do have their merits and pitfalls, and at the end of days both will do the job. Even in the Java API itself you may find samples for both approaches.

In the Java world, the JavaBean concept is more widely accepted, and it is better supported with tools, but if seen over all languages, the property concept is more popular.

\section{Local Variables}\label{sec:NamesForLocalVariables}
The identifier names for local variables are in mixed case, with a lowercase first letter. Internal words start with capital letters. The names should not contain underscore (“\_”) or dollar sign (“\$”) characters, even though both are allowed by the language specification; they also should not start with those characters. Digits are forbidden as first characters already by the language specification, but perfectly allowed as additional characters. But they should be used with care and only were necessary.

Variable names should be short yet meaningful – with a clear priority on being meaningful. The choice of a variable name should be mnemonic – that is, designed to indicate the intent of its use to the casual observer. As for class names, abbreviations and acronyms should be avoided. Using the digit '4' as replacement for the word “for”, and '2' for the word “to” is acceptable, but not really recommended.

In case the first part of the variable name has to be an acronym, it will be written with all lower case:
\begin{lstlisting}
String htmlHeader; // OK
\end{lstlisting}
instead of
\begin{lstlisting}
String hTMLHeader; // AVOID!
\end{lstlisting}

Also one-character variable names should be avoided except for temporary “throwaway” variables. Some of these are widely used and have already a fixed meaning; so is \lstinline|i| very common for the run value of a classical \lstinline|for| loop:
\begin{lstlisting}
for( var i = 0; i < max; ++i )
{
    …
}
\end{lstlisting}

\lstinline|e| is the common name for the exception in a \lstinline|catch| block:
\begin{lstlisting}
try
{
    …
}
catch( final IOException e )
{
    //---* Handle the exception *------------------------------------
    …
}    
\end{lstlisting}

For temporary strings, \lstinline|s| is common, as \lstinline|o| is for (temporary) objects of an unspecified type.

Some names are fixed: the name of the value that is returned from a method has to be \lstinline|retValue| if the method does not return a field or attribute, or \lstinline|this|:
\begin{lstlisting}
// OK
public final int getValue() { return m_Value; }

// AVOID!! Use 'retValue' instead of 'i'!!
public final int signum( double d )
{
    final var i = (d < 0.0) ? -1 : ((d > 0.0) ? 1 : 0);
    return i;
}   //  signum()

// ACCEPTABLE (BARELY)
public final int signum( double d )
{
    return (d < 0.0) ? -1 : ((d > 0.0) ? 1 : 0);
}   //  signum()

// RECOMMENDED
public final int signum( double d )
{
    final var retValue = 0;
    if( d < 0.0 )
    {
        retValue = -1
    }
    else
    {
        retValue = 1;
    }

    return retValue;
}   //  signum()

public final int signum( double d )
{
    final var retValue = (d < 0.0) ? -1 : ((d > 0.0) ? 1 : 0);

    return retValue;
}   //  signum()
\end{lstlisting}

In the same way, \lstinline|result| is reserved as the return value for lambdas (see chapter \tqfullvref{sec:LambdaResults}) and for the results of \lstinline|case| blocks (see chapter \tqfullvref{sec:CaseResults}). \lstinline|result| should not be used in any other context.

A temporary buffer is named \lstinline|buffer|, no matter if it is a \lstinline|java.lang.StringBuilder| or \lstinline|java.lang.StringBuffer|, an implementation of \lstinline|java.util.List|, another collection type, or any other type that can be used as a buffer.

Do not use the names \lstinline|in|, \lstinline|out|, and \lstinline|err|. Although these are not reserved words, they should be treated as such, as it would allow to statically import the default streams from the class \lstinline|java.lang.System|.

Usually you would use the singular form for a variable name, but for collections or arrays, the plural form can be perfectly correct:
\begin{lstlisting}
final Collection<Component> values = m_Components.values();
for( final Component value : values )
{
    …
}    
\end{lstlisting}

Using the class name (with a lower case first letter, of course) for a variable is completely acceptable in case this is sufficient to explain the function of the variable; but the prefix “my” has to be avoided.
\begin{lstlisting}
// RECOMMENDED
public final String retrieveMessage( final String messageKey, 
    final String... additionalInfo )
{
    final MessageProvider messageProvider = getMessageProvider();
    final String rawMessage = 
        messageProvider.getMessage( messageKey );
    final var retValue = String.format( rawMessage, additionalInfo );
    return retValue;
}   //  retrieveMessage()

// AVOID!!!! Don't use "my..." prefix!!!
public final String retrieveMessage( final String string, 
    final String... strings )
{
    final MessageProvider myMessageProvider = getMessageProvider();
    final String myString = myMessageProvider.getMessage( string );
    final var retValue = String.format( myString, strings );
    return retValue;
}
\end{lstlisting}

Sometimes it is also a good idea to use the class name of the type as a suffix or prefix for the name, especially if the current block declares more than one variable of that type. In such a case, the rest of the name could be used to indicate how variables belong together.
\begin{lstlisting}
// RECOMMENDED
public final ResultData callSpecialService()
{
    SpecialClientAgent clientAgent = obtainClientAgent();
    …
}   //  callSpecialService()

// AVOID!!!! Don't use "my..." prefix!!! And don't abbreviate!
public final ResultData callSpecialService()
{
    SpecialClientAgent myCA = obtainClientAgent();
    …
}   //  callSpecialService()

// RECOMMENDED
public final ResultData loadData( Connection connection, … )
{
    …
    final Statement customerStatement = …
    final Statement orderStatement = …

    …

    final ResultSet customerResultSet = customerStatement.execute();
    …

    final ResultSet orderResultSet = orderStatement.execute();
    …
}   //  loadData()
\end{lstlisting}

Do not (never!) use a prefix to indicate the type of a variable (Hungarian notation)! Java is a strongly typed language and the compiler will take care that variables are only used according to their types.\footnote{The use of the Hungarian notation for the naming of variables is discouraged for strongly typed languages like Java or C++, because it does not provide any benefit.\newline For languages like C, JavaScript or also Groovy, this may be different: for these languages the type prefix may help the programmers to assign the semantically correct type to a variable when syntactically any (or most) types are correct.\newline The use of the \lstinline|var| keyword in Java programs does not weaken the strong typing of Java in any way.}

Local variables inside lambdas are just like any other local variable and their naming follows the same rules. The only exception is that a lambda does not use \lstinline|retValue| for a return value, but \lstinline|result| – refer chapter \tqfullvref{sec:LambdaResults} for the details.

\section{Parameters}
The names for formal parameters of methods and constructors are different from those for lambdas.

\subsection{Names for formal Parameters of Methods and Constructors}\label{sec:NamesForFormalParameters}
The names for the formal parameters of a method or a constructors follow the same rules as for local variables. Especially they do \textit{not} have any prefix.

The parameters that are used to initialise a field should have the same name as that field, but without the “m\_” prefix:
\begin{lstlisting}
public final class MyClass
{
    private String m_Name;
    
    public MyClass( final String name )
    {
        m_Name = name;
    }   // MyClass()
    
    public final void setName( final String name )
    {
        m_Name = name;
    }   //  setName()
}
//  class MyClass
\end{lstlisting}

\subsection{Names for Lambda Parameters}\label{sec:NamesForLambdaParameters}
A typical lambda in Java looks like this:
\begin{lstlisting}
Predicate<String> filter = s -> !s.contains( "invalid" );
\end{lstlisting}
\lstinline|s| is the parameter of that lambda, and that these parameters have just single character names is common practice. As lambdas are usually quite short, this works sufficiently in most cases. In addition the meaning of the parameters is well explained through the documentation of the functional interface that is implemented by the lambda.

But if in doubt, you can use longer names with more meaningful names for the parameters of a lambda. The only constraint is that it should be clear what the parameter is, and what is injected to the lambda from the context:
\begin{lstlisting}
// WILL NOT WORK AT ALL!!
final var s = "invalid";
Predicate<String> filter = s -> !s.contains( s ); // Hä?

// Still not good …
final var s = "invalid";
Predicate<String> filter = p -> !p.contains( s );

// Better …
final var s = "invalid";
Predicate<String> filter = toCheck -> !toCheck.contains( s );

// Recommended
final var criterion = "invalid";
Predicate<String> filter = s -> !s.contains( criterion );
\end{lstlisting}

It does not make much difference if you number the parameters, of if you use different names fo them:
\begin{lstlisting}
BiPredicate<String,String> filter = (s1,s2) -> s1.contains( s2 );
BiPredicate<String,String> filter = (a,b) -> a.contains( b );
\end{lstlisting}

Nevertheless, an accepted rule of thumb is to use different names if the parameters cannot be exchanged by each other (as in the sample above), while numbering the parameters is used when the parameters are interchangeable, like in an implementation of \lstinline|java.util.Comparator|:
\begin{lstlisting}
Comparator<String> comparator = (s1,s2) -> s1.compareToIgnoreCase( s2 );
\end{lstlisting}

\section{Fields}\label{sec:Fields}
The name for fields (also referred to as ‘attributes’ or ‘properties’) are prefixed with “m\_”; the first letter after the underscore has to be a capital letter:
\begin{lstlisting}
private String m_AString;
private boolean m_IsValid;
private String m_HTMLHeader;
private MessageProvider m_MessageProvider;
\end{lstlisting}
This warrants that the names of local variables and formal parameters of methods or constructors will be always distinct from those of fields, and therefore neither local variables nor parameters can collide with or hide fields. Another consequence is that it is not necessary to use \lstinline|this.| when accessing a field.

Aside this, anything else that was said about the naming of local variables in chapter \tqref{sec:NamesForLocalVariables} is also valid for the naming of fields.

Please be aware that a bean property name does not carry the prefix. So the getters for the samples above are
\begin{lstlisting}[numbers=left]
public final String getAString() { return m_AString; }
public final boolean getIsValid() { return m_IsValid; }
/* Alternatively: */ public final boolean isValid() { return m_IsValid; }
public final String getHTMLHeader() { return m_HTMLHeader; }
public final MessageProvider getMessageProvider() { return m_MessageProvider; }
\end{lstlisting}
Regarding the alternative getter in line~3 refer to \autocite{ORACLE_DOC_JAVABEANS:Chapter8_3_2}.

Eclipse knows a configuration setting for this prefix (\verb#Window|Preferences|Java|Code Style#). Setting the prefix list there to “m\_” makes sure that the generation of getters and setters will work as expected.

For IntelliJ~IDEA, a similar setting can be found at \verb#File|Settings#, where you select under \verb#Editor|Code Style|Java# the tab \verb#Code Generation#.

\section{Constants}\label{sec:Constants}
Constants are fields of primitive or immutable types that are declared as \lstinline|public static final|. According to the Sun coding conventions, their names “should be all uppercase with words separated by underscores (‘\_’)”\autocite{SUN_CODE_CONVENTIONS:NamingConventions}.

Our definition for a constant is even more restrictive: that \lstinline|public static final| field has to be initialised with a compile-time constant value. This basically limits constants to “magic numbers”, static configuration values and texts.

Some samples for valid constants:
\begin{lstlisting}
public static final double PI = 3.1415;
public static final int ANSWER_TO_ALL_QUESTIONS = 42;
public static final String ISO_DATE_FORMAT = "yyyyMMdd'T'hhmmss";
public static final String [] EMPTY_STRING_ARRAY = new String [0];
\end{lstlisting}
Real constants go to the part of the class headlined with “Constants” (refer to chapter \tqvref{sec:StructuringComments}).

The field \lstinline|PATTERN| below is not a constant in the sense of this definition:
\begin{lstlisting}[numbers=left]
public static final Pattern PATTERN = Pattern.compile( ".*" );

// Better:
public static final Pattern PATTERN;

static
{
    try
    {
        PATTERN = Pattern.compile( ".*" );
    }
    catch( final PatternSyntaxException e )
    {
        throw new ExceptionInInitializerError( e );
    }    
}

// Even better:
public static final String PATTERN_SOURCE = ".*";
…
private static final Pattern m_Pattern;

static
{
    try
    {
        m_Pattern = Pattern.compile( PATTERN_SOURCE );
    }
    catch( final PatternSyntaxException e )
    {
        throw (ExceptionInInitializerError) new ExceptionInInitializerError( "Compilation of '%s' failed".formatted( PATTERN_SOURCE ).initCause( e );
    }    
}
\end{lstlisting}
No matter which variant you go for, the declaration and initialisation have to go to the part “Static Initialization”.

\lstinline|static final| references to \textit{mutable} objects are no constants (no matter which definition you use), therefore they should never be \lstinline|public| – with the final consequence that they are just fields – so refer to chapter \tqref{sec:Fields} for their naming.

Samples for fields that are not feasible as \lstinline|public| constants are (as the objects are not constant at all):
\begin{lstlisting}[numbers=left]
// AVOID!! Make it private!
public static final Map<String,File> m_Files = new TreeMap<String,File>();

// AVOID!! Make it private!
public static final Date BEGIN_OF_EPOCHE = new Date( 0 );

// AVOID!! Make it private!
public static final SimpleDateFormat ISO_DATE_FORMATTER = new SimpleDateFormat( ISO_DATE_FORMAT );
\end{lstlisting}

If you wonder why the lines~5 and 8 belongs to this group of bad samples, refer to \autocite{ORACLE_DOC_DATE_CLASS,ORACLE_DOC_SIMPLEDATEFORMATTER_CLASS}: instances of \lstinline|java.util.Date| and \lstinline|java.text.SimpleDateFormatter| are not immutable!\footnote{In addition, the class \lstinline|java.util.Date| and the tools around it were superseded by the \lstinline|java.time| package (see \autocite{ORACLE_DOC_TIME_PACKAGE}) and should not be used anymore.}

Sometimes you may have classes or groups of constants (e.g. the tags in an XML document, the column names of a database table, or message texts). It has proved to help with the readability of the code if this is reflected in the names. For the column names of the table \verb#PERSON#, the constants may be defined as shown here:
\begin{lstlisting}
public final static String PERSON_COL_FirstName = "first_name";
public final static String PERSON_COL_LastName = "last_name";
…
\end{lstlisting}
The camelCased suffix is the ‘real’ name, while the part that follows the stronger rules for a constant name is just indicating the “constant category”.

\section{enum Values}\label{sec:EnumValues}
When the Sun coding conventions\autocite{SUN_CODE_CONVENTIONS} had been written in 1999, enums did not yet exist in Java. But enum values are special cases of constants, the usual assumption is that their names have to follow the same rules as for normal constants: the name should be all upper case with words separated by underscores (“\_”).

Basically, this works fine, but when using \lstinline|static| imports, you may get name clashes for common terms that can be used in different contexts. So it will make sense to add a prefix to the name of an enum, similar to what we did with the categories or groups for regular constants. This may look like this:
\begin{lstlisting}
enum Direction
{
    DIR_LEFT,
    DIR_RIGHT;
}   //  enum Direction

enum Alignment
{
    ALIGN_CENTER,
    ALIGN_LEFT,
    ALIGN_RIGHT;
}   //  enum Alignment
\end{lstlisting}
Using the prefix would allow now to use the values with static imports of their classes; otherwise, they have to be used with their class names as prefix.

Alternatively, you can use this:
\begin{lstlisting}
enum Direction
{
    DIR_Left,
    DIR_Right;
}   //  enum Direction

enum Alignment
{
    ALIGN_Center,
    ALIGN_Left,
    ALIGN_Right;
}   //  enum Alignment
\end{lstlisting}
Again the camelCased suffix is the “name” itself, while the “proper” typed prefix is just the category. This is recommended if the suffix consists of multiple words that otherwise require additional underscores.

\section{Type Arguments}\label{sec:TypeVariables}
Type arguments belong to the definition of parameterised types \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ParameterizedTypes} or “generics”. So in
\begin{lstlisting}
public interface Function<T,R> {…}
\end{lstlisting}
\lstinline|T| and \lstinline|R| are the type arguments.

It is commom practice to name a single type argument as \lstinline|T|. If there are more than one type arguments, the name \lstinline|R| is usually used for the return type. Also often used are \lstinline|V| as the name for a value type and \lstinline|K| for the name of the type for a key, \lstinline|E| as the name for the type of an entry to a list or set or for an exception type.

Aside that, no further rules exist. Even more than one character is possible for the name of a type argument: \begin{lstlisting}
public interface Map<Key,Value> {…}
\end{lstlisting}
is absolutely valid, although not common. 

But because the type arguments denotes classes, their names have to start with a capital letter.

\section{Projects}\label{sec:Projects}
You can name your project however you want, although some IDEs have some constraints about the exact format.

I recommend to name the project after the module.

\section{Library Files}\label{sec:LibraryFiles}
Usually, the library files of a project are named after the project, appended by a version number and/or a release date. They have to be valid file names.

\chapter{Writing proper Comments}\label{sec:WritingProperComments}
Comments are crucial for the understanding of source code, in any programming language. Source code without any comments is not maintainable, meaning it is worthless in the long run.

In addition, Java also provides a tool that allows to externalize program comments, so that they can be used as the external documentation; the name of this tool is \textit{JavaDoc}. The “Javadoc Guide”\autocite{ORACLE_DOC_JAVADOC_GUIDE} provides an overview of the tool\footnote{see \autocite{ORACLE_DOC_JAVADOC_MAN} on how to invoke the tool on your source code}, the “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG} explains how to write the comments for a proper documentation generated with the JavaDoc tool.\footnote{JavaDoc is not the only tool for this purpose; another well known tool is Doxygen\autocite{DOXYGEN_HOMEPAGE} that was created primarily to generate the documentation for annotated C++ code, but it works also for Java, C and several other programming languages. But for Java sources, JavaDoc is the preferred tool.}

So Java source code can generally have three kinds of comments:
\begin{itemize}[nosep]
\item{documentation comments}
\item{implementation comments}
\item{maintenance comments}
\end{itemize}
In Java, the \textit{documentation comments} (also known as “doc comments” or “the JavaDoc”) are delimited by “\verb#/**…*/#” and cannot be placed everywhere; they will be externalised for the generation of the program/library documentation. Obviously, \textit{implementation comment}s are the other comments, that are not externalized and published.

\textit{Maintenance comments} are technically a special form of implementation comments, but as the have a special function, they are covered separately (see chapter \tqfullvref{sec:MaintenanceComments}).

Roughly, the documentation comments describe how to use the code (the API), unrelated to the implementation, while the implementation comments describe what the code is doing and why.

Comments should be used to give overviews of code and provide additional information that is not readily available in the code itself. Comments should contain only information that is relevant to reading and understanding the program. For example, information about how the corresponding package is built or in what directory it resides should not be included as a comment to a class.

Discussion of non-trivial or non-obvious design decisions is appropriate, but avoid duplicating information that is present in (and clear from) the code. It is too easy for redundant comments to get out of date. In general, avoid any comments that are likely to get out of date as the code evolves.

The frequency of comments reflects poor quality of code. Unfortunately, code can be “under-commented” or “over-commented”, meaning there is a “frequency band” for comments that has to be hit for good quality code.

One often heard advice is: “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” But clearer to whom?

With increasing programming experience, things get more and more obvious to the programmers, so they write lesser comments – with the result, that newbies do not have any help to understand the code written by the experts.

Obviously, the advice: “Even if you don't think, a comment might be necessary, add it nevertheless” is the other extrema and equally bad, so writing proper comments remains a complex art, but it follows some rules, and for the rest, we will give some advice. Refer to chapter \tqfullvref{sec:CommentsWhen} where this is discussed further.

In general:
\begin{itemize}
\item{Comments should not be enclosed in large boxes drawn with asterisks or other characters, with the exception of structuring comments as described below.}
\item{Comments should never include special characters such as tabulator, form-feed and backspace or alike. In JavaDoc comments only (see below), most other non-ASCII characters should be escaped with their HTML equivalent.}
\item{While code lines can have any length, comment lines will always end in or before column 80, except when their contents cannot be wrapped (like URLs for references to additional information).}
\item{Comments should be in full sentence and using a clear language.}
\item{Finally: all comments has to be in English language; they should be grammatically correct and without typos.\footnote{…~but it is still much more important that there is at least \textit{some} comment than a correctly spelled one.}}
\end{itemize}

\section{Documentation Comments}\label{sec:DocumentationComments}
It is a well known fact that most programmers are poor technical writers. That's the reason why programmers rarely write the public documentation for their product.

But that is no excuse why programmers do not write proper documentation comments into their source code. They are the only people that could write these comments because technical writers usually do neither have the time nor the required skills to analyse the code to extract the information from it that is necessary for the documentation.\footnote{In addition, the technical writers often do not have (write) access to the source code and are therefore not able to add the documentation comments.}

In general there are (at least) two different target groups for the documentation that is generated from the documentation comments. The first group are the maintenance programmers, the second are programmers writing code interfacing with this one, using the public APIs. This means that each program element that can have a documentation comment must have a documentation comment! No exception! No excuse for missing documentation comments! The programmer must provide a documentation comment wherever it is possible. 

Eclipse can be configured in a way that it will issue warnings or even errors for missing documentation comments: see \verb#Window|Preferences|Java|Compiler|Javadoc#.

To achieve the same for IntelliJ IDEA, you go to \verb#File|Settings#, and there you select \verb#Editor|Inspections>Java>Javadoc#.

Documentation comments describe Java modules, packages, classes\footnote{All types of \textit{classes}, including \textit{interfaces}, \textit{enums}, \textit{records} and \textit{annotations}}, constructors, methods, and fields\footnote{All types of fields: \textit{attributes}, \textit{constants}, but also the \textit{enum values}}. Each documentation comment is set inside the comment delimiters “\verb#/**…*/#”, with one comment per module, package\footnote{The documentation comment for a Java package is special; refer to chapter \tqfullvref{sec:PackageDocumentation} for the details}, class, or member. This comment has to appear just before the declaration:

\begin{lstlisting}
/**
 *  The Example class provides …
 */
public class Example
{
    /**
     *  The inner class provides …
     */
    private static class InnerClass
    {
        …
    }
    //  class InnerClass
     
    …
    
    /**
     *  This flag …
     */
    private boolean m_Flag;
    …

    /**
     *  Method that performs some action …
     *
     *  @param  arg   The argument.
     */
    public final void method( int arg )
    {
        …
    }   //  main()
}   //  class Example
\end{lstlisting}

The first line of the documentation comments (“/**”) for top level classes is not indented; subsequent lines for the documentation comment have one space of indentation (to vertically align the asterisks). All members, including inner classes, have 4 spaces for the first documentation comment line and 5 spaces thereafter (this is congruent for inner classes).

If you need to give information about a class, interface, variable, or method that isn't appropriate for the public documentation, use an implementation comment immediately after the declaration. For example, internal details about the implementation of a class should go in such an implementation block comment following the class statement, not in the class documentation comment.

Documentation comments should not be positioned inside a method or constructor definition block, because Java associates documentation comments with the first declaration after the comment.

\subsection{Structure and Contents}\label{sec:StructureAndContents}
Latest since the introduction of Java~9, the JavaDoc tool produces (more or less) correct HTML~5 documents from the JavaDoc comments in the source code. Therefore it is strongly recommended to use correct HTML~5 syntax inside the documentation comments itself. This means that tags has to be closed properly, empty tags like \lstinline|<br>| and \lstinline|<img>| are not closed, and so on.

If the comment has more than one single paragraph, use the \lstinline|<p>| tag; do not use the \lstinline|<br>| tag:

\begin{lstlisting}
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The first sentence of each JavaDoc comment is taken to be placed on an overview. Per default, that sentence is defined as everything from the beginning until the first full stop followed by a blank (“. ”) or other whitespace, or the first not-inline HTML tag.

This means that a comment like this

\begin{lstlisting}
// AVOID!!
/**
 *  <b>Returns the status for this operation.</b>
 *
 *  …
 */
\end{lstlisting}

may cause some strange output\footnote{Writing the comment like that (with the \lstinline|<b>…</b>| tag) should be avoided anyway.}. Java~10 introduced the JavaDoc tag \nameref{sec:TagSummary} to address issues like this; it allows the programmer to explicitly specify what portion of the JavaDoc comment appears in the overview rather than relying on JavaDoc's default behaviour to determine the summary portion of the comment. Refer to \autocite{ORACLE_DOC_JAVADOC_TAG,DZONE_JAVADOC_SUMMARY} for the details and additional samples.

The \nameref{sec:TagSummary} tag has to be used always when a documentation comment has more than one sentence:

\begin{lstlisting}
// OK – as single sentence
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
// AVOID!! – Two sentences. 
/**
 *  <p>Returns the status for this operation. The return value will 
 *  never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

// RECOMMENDED
/**
 *  <p>{@summary Returns the status for this operation.} The return 
 *  value will never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>{@summary Returns the status for this operation.}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The documentation comments for modules, packages and classes may get longer, so that you want to structure it by giving headlines to sections. Usually this is done through the HTML tag \lstinline|<h#>|, with \# being a number in the range from 1 to 6. You can use these tags in the documentation comments, too, but the tags \lstinline|<h1>| and \lstinline|<h2>| are already used by JavaDoc itself; that means that you should only use \lstinline|<h3>| to \lstinline|<h6>| in the documentation comments.\footnote{In the overview comment (refer to chapter \ref{sec:OverviewComment}), you can make use of the all the \lstinline|<h#>| tags to structure that comment.}

When a class, method, constant, field is mentioned the first time in a documentation comment, its documentation should be linked, using the \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tags. This is not necessary if the type is used for a formal parameter or the return value. In these cases, JavaDoc generates these links automatically.

Each \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tag has to placed into a line of its own.

Some examples:
\begin{lstlisting}
/**
 *  <p>{@summary Searches the given key in the list and returns the
 *  associated data.} If the key is
 *  {@linkplain String#isBlank() blank},
 *  the method will throw a
 *  {@link BlankArgumentException},
 *  while an empty will just not return a result.</p>
 *
 *  @param  key The key.
 *  @returns An instance of
 *      {@link Optional}
 *      that holds the search result.
 *  @throws IllegalArgumentException    The key is somehow invalid.
 *
public final Optional<Data> searchData( final String key ) { … }
\end{lstlisting}

JavaDoc creates links to the documentation of \lstinline|java.lang.IllegalArgumentException|, \lstinline|java.lang.String| and \lstinline|Data| automatically; it also creates a link to \lstinline|java.util.Optional| but it is recommeded to use the pattern shown here, even when this means that the comment holds two links to the \lstinline|Optional| class documentation.

The names of classes, methods, constant, fields, parameters etc. as well as \lstinline|null|, \lstinline|true|, and \lstinline|false| have to be written in a monotype font. This can be achieved by encapsulating them in \lstinline|<code>…</code>| HTML tags or placing them inside the JavaDoc \nameref{sec:TagCode} tag. The monotype font is used automatically for everything inside a \nameref{sec:TagLink} tag.

Each comment, including each text for a \nameref{sec:TagParam}, \nameref{sec:TagReturn}, and \nameref{sec:TagThrows} tag, ends with a full stop.

The document “How to Write Doc Comments for the Javadoc Tool”\autocite{ORACLE_DOC_JAVADOC_HOWTO} is already a little bit older and therefore outdated in parts, but it still provides some useful hints on how to write proper documentation comments that should be processed by the JavaDoc tool.

\subsubsection{The Overview Comment}\label{sec:OverviewComment}
When the JavaDoc tool is called with the option \verb#-overview <filename># (see \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}), an ‘Overview’ comment is  added to the generated documentation. \verb#<filename># is the (fully-qualified)  filename of a valid HTML~5 document (The recommended name is \verb#overview.html#) containing general information about the project.

You can put nearly everything here, from the project's history to manual on how to use the program or library, but you should not reproduce information that is given in the module, package, or class documentation comments.

Several JavaDoc tags can be also used in the overview comment; for details refer to the chapter "Where Tags Can Be Used" in \autocite{ORACLE_DOC_JAVADOC_TAG}.

\subsubsection{The module Comment}\label{sec:ModuleComment}
The \verb#<module description># (refer to chapter \tqfullref{sec:ModuleDefinition}) describes the current module, its dependencies and what it provides. See the JavaDoc tags \nameref{sec:TagProvides} and \nameref{sec:TagUses} for details.

If the project has just one module, the module comment can replace the overview comment.

\subsubsection{The package Comment}\label{sec:PackageComment}
Each and every Java package has to have a file named \verb#package-info.java#; the structure of that file was already discussed in chapter \tqfullvref{sec:PackageDocumentation}.

The \verb#<package description># provides information about the package. So it describes the purpose of the classes in this package. It lists conventions that are common for all contained classes, it should specify their prerequisites.

If the package defines a single API, it can describe the usage of that API, too. 

The package comment can list the authors of the code, using the \nameref{sec:TagAuthor} tag\footnote{Or the tag \nameref{sec:TagExtAuthor}, refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc})}, the version with the \nameref{sec:TagVersion} tag, when the package was created or with which version it was integrated with the \nameref{sec:TagSince} tag, and other things.

It should not repeat details that are written already in the documentation of a class in that package, instead it should reference that class documentation. If those details are  important for the whole package, it should be considered to move them from the class comment to the package description and place a reference into the class documentation instead.

The package comment for the main package of a project can replace the overview comment (if not the module comment is used for this\footnote{Not all projects will produce modules, so it is possible that your project does not have a module definition file at all.}).

\subsubsection{The class Comment}\label{sec:ClassComment}
The documentation comment for a class, an interface, an enum, a record or an annotation (the ‘class comment’) describes that class, its purpose and its usage. If the class is not \lstinline|final|, the comment should provide some hints what the mount points\footnote{Another term for “mount point” is “extension point”, but I do not like this expression as we do not always “extend” a class on these points. Most often we replace existing behaviour to customise the class to our needs.} are and how to utilise them.

Then the class comment should list the authors of the class, using the \nameref{sec:TagAuthor} tag, the class version (using the \nameref{sec:TagVersion} tag), and when the class was added to the project with the \nameref{sec:TagSince} tag\footnote{Although this can be omitted if this information is already given within the package.}.

In case of a parametrised type (a ‘generic’), it contains a \nameref{sec:TagParam} tag for each formal parameter.

Here a real life sample for an interface:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object). It is based on sample code from the book &quot;Java
 *  Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @author Thomas Thrien - thomas.thrien@pega.com
 *  @version <version information>
 *  @since 1.2.3
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}

The \verb#<version information># should be a reference to the version in the SCCS; if you are using Subversion, that line would look like this:
\begin{lstlisting}
/**
 …
 *  @version $Id:$
 …
 */
\end{lstlisting}

I also recommend to use the custom tags provided by the “Foundation JavaDoc” project\autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC} (see chapter \tqfullvref{sec:CustomTagsForJavaDoc}); then the same class documentation comment would look this:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object).
 * 
 *  @inspired &quot;Java Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @extauthor Thomas Thrien - thomas.thrien@pega.com
 *  @version $Id:$
 *  @since 1.2.3
 *
 *  @UMLGraph.link
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}
The tag \nameref{sec:TagExtAuthor} is an enhanced replacement for the \nameref{sec:TagAuthor} tag, and the tag \nameref{sec:TagUMLGraph} places an UML diagram for the current class to the generated documentation.

\subsubsection{The Field Comment}\label{sec:FieldComment}
Attributes/properties, constants and enum values are all summarised under ‘fields’ here.

Each and every field will have a comment, the ‘field comment‘, describing it. For \lstinline|private| fields it can be sufficient to refer to the related getter method instead of writing a lengthy comment into the field comment itself; do not use the \nameref{sec:TagSee} tag instead of the \nameref{sec:TagLink} tag:
\begin{lstlisting}
/**
 *  Refer to
 *  {@link #getValue()}.
 */
private final Value m_Value;

// AVOID!!
/**
 *  @see #getOtherValue()}.
 */
private final Value m_OtherValue;
\end{lstlisting}

If there is no getter method for a field, or it is not \lstinline|private|, a description is mandatory. Usually one sentence might be sufficient, although \lstinline|public| constants may require a full fledged usage description if that is not given elsewhere (for example, in the class comment or the package comment) and a reference to that description could be placed here.

It is always a good idea to describe the valid values for the field, its default value, and if \lstinline|null| is a possible value for a reference. This is a must for non-\lstinline|final| \lstinline|public| or \lstinline|protected| fields.

For a serialisable class, the fields that will be serialised should be tagged with \nameref{sec:TagSerial} and the appropriate description.

Constants (\lstinline|public static final| fields) that are initialised with a literal have to use the \nameref{sec:TagValue} tag in there description. Also \lstinline|private static final| or \lstinline|protected static final| fields that are initialised with a literal should use the \nameref{sec:TagValue}.

This looks like this:
\begin{lstlisting}
/**
 *  The vested system property for the file encoding used by the JVM:
 *  {@value}.
 */
public static final String PROPERTY_FILE_ENCODING = "file.encoding";
\end{lstlisting}

The comments for enum values are nothing else than field comments for constants – in fact, an enum value is exactly that: a \lstinline|public static final| field initialised with an instance of the enum type.

\subsubsection{The Method Comment}\label{sec:MethodComment}
The documentation comment for a method describes its usage and its function within the class, together with its arguments, the return value, and any exception it may throw.

For each method parameter there have to be a \nameref{sec:TagParam} tag that describes it in detail (if not already described in the main text of the method comment; in that case, a short sentence should be sufficient). The description has to cover the function of the parameter, its value range, and whether the parameter can be \lstinline|null|. Usually, \lstinline|null| is an invalid parameter value per default, so it has to be mentioned in the respective comment if it is allowed.

It is not enough to only give the type of the parameter in the comment; in fact, this is obsolete as it can be easily taken from the method's signature.

Usually, the return value (given the method is not of type \lstinline|void|) will be described in the comment for the \nameref{sec:TagReturn} tag; the tag is mandatory, and with some text, even if the return value is described already in the method description itself. The description for the return value should provide the possible values and there meanings, whether \lstinline|null| is a valid return value, and so on. 

In particular, the comment for the \nameref{sec:TagReturn} tag has to describe which return values indicate special or error conditions.

It is obsolete to give the type of the return value here; it can already be seen from the method's declaration.

Next there has to be a \nameref{sec:TagThrows} tag for each checked exception that may be thrown by the method, describing the condition that may trigger that exception. It is also possible to add \nameref{sec:TagThrows} clauses for unchecked exceptions, but not required. Refer to chapter \tqfullvref{sec:GeneralExceptionHandling} for additional details on exception handling.

A method that implements an interface method or that overrides a method from a base class be commented with the \nameref{sec:TagInheritDoc} tag instead of writing a full comment. The tag can be combined with additional text, too.

The documentation comment for a non-\lstinline|final| \lstinline|public| or \lstinline|protected| method has to provide detailed information when and how it has to be overwritten; especially if the overriding method has to call the super implementation and when:\footnote{Usually you should avoid the requirement for calling the super implementation, but that is not always appropriate or possible; refer to chapter \tqref{sec:NonFinalMethods} about some more details.}.

A comment for that case may look like this:\footnote{The tag @note is a custom tag; refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc}}
\begin{lstlisting}
/**
 *  …
 *
 *  @note Call this implementation {before|after} your code, to make
 *      sure that the initialisations provided here are performed.
 *
 *  …
 */
\end{lstlisting}

For more details on this refer to chapter \tqfullvref{sec:ExtendingClassesOverridingMethods}.

Usually, the documentation comment for a method does not reveal details about the method's implementation, but in case of empty “place holder methods” or mount points, a sentence like below does not harm.
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 */
\end{lstlisting}

If such a method has a dummy or default return value, there has to be an appropriate \nameref{sec:TagReturn} tag, specifying that value:
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 *  @return Always <the default value>.
 */
\end{lstlisting}
 
Finally it is absolutely crucial that the documentation comment provides all information about possible side effects of a call to the method, even more when these side effects are unexpected.

\subsubsection{The Constructor Comment}\label{sec:ConstructorComment}
Basically, a constructor is a special kind of a method, so the same rules are valid for the documentation comment for a constructor than for the documentation comment for a method, as given in chapter \tqref{sec:MethodComment}.

For an empty default constructor, the constructor comment may be as simple as this, no matter if it is \lstinline|public|, \lstinline|private|, or \lstinline|protected|:
\begin{lstlisting}
/**
 *  Creates a new {@code MyClass} instance object.
 */
public MyClass() { /* Does nothing */ }
\end{lstlisting}
or
\begin{lstlisting}
/**
 *  Default constructor for class {@code MyClass}.
 */
private MyClass() { /* Does nothing */ }
\end{lstlisting}
with the first alternative being the preferred one; in fact, this comment can be used for every constructor, not only for the default ones.

Of course, these comments do not say very much, but the constructor is also not doing that much, and what it does is very obvious. But if it has side effects, these should be described properly.

A class that does have only \lstinline|static| methods\footnote{Such a class is called a “Utility Class”; refer to \tqfullvref{sec:UtilityClasses} for more details.} should have a \lstinline|private| constructor like this:\footnote{The \lstinline|Error| class is described in \autocite{TQUADRAT_ORG_FOUNDATION_PRIVATECONSTRUCTORFORSTATICCLASSCALLEDERROR}.}
\begin{lstlisting}
/**
 *  No instance is allowed for class {@code MyUtilityClass}.
 */
private MyUtilityClass() 
{ 
    throw new PrivateConstructorForStaticClassCalledError( MyUtilityClass.class); 
}   // MyUtilityClass()
\end{lstlisting}

If a constructor takes parameters, there has to be a \nameref{sec:TagParam} tag for each of them, exactly like for a method.

Although constructors should not throw (checked) exceptions, sometimes it could not be avoided without overcomplicating the API of a class. In such case, all exceptions has to be listed with the \nameref{sec:TagThrows} tag and a description of the conditions for the particular exception – as far as it is possible or make sense. Refer also to chapter \tqfullvref{sec:GeneralExceptionHandling} for some more details on exception handling.

\subsection{The JavaDoc Tags}\label{sec:JavaDocTags}
The next two chapters describe the tags that should be used in your documentation comments where appropriate.

One general rule for all JavaDoc tags: Do not insert line breaks between the parameters of a tag:
\begin{lstlisting}
// WRONG!!
/*
 *  …
 *  @param args
 *         The command line arguments
 *  @param  otherArg
 *          This parameter needs a very long explanatory comment that
 *          requires a line break.
 *  @throws IOException
 *          Reading the file failed.
 *  …
 */

// CORRECT:
/*
 *  …
 *  @param  args   The command line arguments
 *  @param  otherArg    This parameter needs a very long explanatory
 *      comment that requires a line break.
 *  @throws IOException Reading the file failed.
 *  …
 */
\end{lstlisting}

\subsubsection{The Standard Doclet Tags}
Most of the contents of this chapter was taken from the document “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG}. 

In the context of the JavaDoc tool, the interpretation of the content of a documentation comment is done by the implementation of the interface \lstinline|jdk.javadoc.doclet.Doclet|\footnote{Refer to \autocite{ORACLE_DOC_DOCLET_INTERFACE}.} interface that is used to process the comment. Other implementation may accept the same syntax as the standard doclet (provided through the class \lstinline|jdk.javadoc.doclet.StandardDoclet|\autocite{ORACLE_DOC_STANDARDDOCLET_CLASS}), or they may support an alternate syntax. However, due to the support by many tools, the syntax supported by the standard doclet has become a \textit{de facto} standard.

\paragraph{\lstinline|@author|}\label{sec:TagAuthor} Usage: \lstinline|@author <name-text>|

The tag adds an “Author” entry with the specified name text to the generated documents when the \verb#-author# option is used. A documentation comment can contain multiple \lstinline|@author| tags. Use the \nameref{sec:TagExtAuthor} tag instead.

\paragraph{\lstinline|@code|}\label{sec:TagCode}  Usage: \lstinline|{@code <text>}|

This is equivalent to \lstinline|<code>{@literal text}</code>|.

It displays text in the code font without interpreting the text as HTML markup or nested JavaDoc tags. This enables you to use regular angle brackets (< and >) instead of the HTML entities (\&lt; and \&gt;) in documentation comments, such as in parameter types (<Object>), inequalities (3 < 4), or arrows (->).

If you want the same functionality without the code font, then use the \nameref{sec:TagLiteral} tag. 

\paragraph{\lstinline|@deprecated|}  Usage: \lstinline|{@deprecated <text>}|

This tag is used in conjunction with the \lstinline|@Deprecated|\autocite{ORACLE_DOC_DEPRECATED_ANNOTATION} annotation to indicate that this API should no longer be used (even though it may continue to work).

The first sentence of the text should tell the user when the API was deprecated and what to use as a replacement. Subsequent sentences can also explain why it was deprecated.

A \nameref{sec:TagLink} tag that points to the replacement API should be added where feasible.

\paragraph{\lstinline|@docRoot|}  Usage: \lstinline|{@docRoot}|

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages.

\paragraph{\lstinline|@exception|} This is a synonym for \nameref{sec:TagThrows}; it should not be used.

\paragraph{\lstinline|@hidden|}  Usage: \lstinline|@hidden|

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all.

\paragraph{\lstinline|@index|}  Usage: \lstinline|{@index <word> <description>}| or \lstinline|{@index "<phrase>" <description>}|

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym.

\paragraph{\lstinline|@inheritDoc|}\label{sec:TagInheritDoc}  Usage: \lstinline|{@inheritDoc}|

Inherits (copies) the documentation comment from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text.

\paragraph{\lstinline|@link|}\label{sec:TagLink}  Usage: \lstinline|{@link <module/package.class#member> <label>}|

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. 

This tag is similar to the \nameref{sec:TagSee} tag. Both tags require the same references and accept the same syntax for \verb|<module/package.class#member>| and the label. The main difference is that the \lstinline|{@link}| tag generates an inline link rather than placing the link in the “See Also” section. The \lstinline|{@link}| tag begins and ends with curly braces to separate it from the rest of the inline text. If you need to use the right curly brace (“\}”) inside the label, then use the HTML entity notation \verb|&#125;|.

\paragraph{\lstinline|@linkplain|}\label{sec:TagLinkplain}  Usage: \lstinline|{@linkplain <module/package.class#member> <label>}|

Behaves the same as the \nameref{sec:TagLink} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text.

\paragraph{\lstinline|@literal|}\label{sec:TagLiteral}  Usage: \lstinline|{@literal <text>}| 

Same as the \nameref{sec:TagCode} tag, but the text is shown as plain text and not in the code font.

\paragraph{\lstinline|@param|}\label{sec:TagParam}  Usage: \lstinline|@param <parameter-name> <description>|

Adds a parameter with the specified parameter name followed by the specified description to the “Parameters” section. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets (“\verb#<…>#”) around such a parameter name to indicate the use of a type parameter.

\paragraph{\lstinline|@provides|}\label{sec:TagProvides}  Usage: \lstinline|@provides <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document an implementation of a service that is provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider itself. 

\paragraph{\lstinline|@return|}\label{sec:TagReturn}  Usage: \lstinline|@return <description>|

Adds a “Returns” section with the description text to the documentation comment of a method.

\paragraph{\lstinline|@see|}\label{sec:TagSee}  Adds a “See Also” heading with a link or text entry that points to a reference. The \lstinline|@see| tag has three variations; see \autocite{ORACLE_DOC_JAVADOC_TAG} for the details.

\paragraph{\lstinline|@serial|}\label{sec:TagSerial} Used in the documentation comment for a default serializable field. See “Documenting Serializable Fields and Data for a Class”\autocite{ORACLE_DOC_OBJECT_SERIALIZATION:DocumentingSerializableFieldsData}. 

\paragraph{\lstinline|@since|}\label{sec:TagSince}  Usage: \lstinline|@since <since-text>|

Adds a “Since” heading with the specified \verb#<since-text># value to the generated documentation. The text has no special internal structure. This tag that this change or feature has existed since the software release specified by the \verb#<since-text># value, for example: \lstinline|@since 1.5|.

Although it would possible to provide a date or something else, it is recommended to always use a version number with the \lstinline|@since| tag.

\paragraph{\lstinline|@summary|}\label{sec:TagSummary}  Usage:  \lstinline|{@summary <text>}|

Identifies  the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content.

The \lstinline|{@summary}| tag has to be used always when a documentation comment has more than one sentence; see also chapter \tqvref{sec:StructureAndContents}.

\paragraph{\lstinline|@throws|}\label{sec:TagThrows}  Usage: \lstinline|@throws <class-name> <description>|

The \lstinline|@throws| tag adds a “Throws” subheading to the generated documentation, with the \verb#<class-name># and the description text. The class name is the name of the exception that might be thrown by the method, and the description provides information about the conditions for that exception to be thrown. 

\paragraph{\lstinline|@uses|}\label{sec:TagUses}  Usage: \lstinline|@uses <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available.

\paragraph{\lstinline|@value|}\label{sec:TagValue}  Usage: \lstinline|{@value}| or \lstinline|{@value <module/package.class#field>}|

This tag is used to display the values of constant in the generated documentation. When the \lstinline|{@value}| tag is used without an argument in the documentation comment of a \lstinline|static final| field, it displays the value of that constant:
\begin{lstlisting}
/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"
\end{lstlisting}

When used with the argument \verb|<module.package.class#field>| in any documentation comment, the \lstinline|{@value}>| tag displays the value of the specified constant:
\begin{lstlisting}
/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public final String evalScript( String script ) { … }
\end{lstlisting}
The argument \verb|<module.package.class#field>| takes a form similar to that of the \nameref{sec:TagLink}, the \nameref{sec:TagLinkplain}, or the \nameref{sec:TagSee} tag argument, except that the member must be a \lstinline|static final| field.

\paragraph{\lstinline|@version|}\label{sec:TagVersion}  Usage: \lstinline|@version <version-text>|

Adds a “Version” subheading with the specified \verb#<version-text># value to the generated documents when the \verb#-version# option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the \nameref{sec:TagSince} tag, which holds the release number where this code was introduced. The \verb#<version-text># value has no special internal structure.

\subsubsection{Custom Tags for JavaDoc}\label{sec:CustomTagsForJavaDoc}
You can define your own JavaDoc tags; simple tags can be defined on the commandline for the JavaDoc tool (see the option \verb#-tag# in \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}) or by implementing the interface \lstinline|jdk.javadoc.doclet.Taglet|\autocite{ORACLE_DOC_TAGLET_INTERFACE}.

I created a set of custom tags that I use regularly, and that I also recommend for your documentation comment. The respective library can be found at \autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC}.

\paragraph{\lstinline|@anchor|}\label{sec:TagAnchor}  Usage: \lstinline|{@anchor #<anchor-name> <text>}|

This tag allows to add an HTML anchor to the generated documentation, where \verb#<anchor-name># is the name of the anchor to the given text. The hash symbol (‘\#’) before the name of the anchor is mandatory!

\paragraph{\lstinline|@extauthor|}\label{sec:TagExtAuthor}  Usage: \lstinline|@extauthor <name-text> - <email-address>|

This is a replacement for the \nameref{sec:TagAuthor} tag that renders the given email address as \verb#mailto:# link in the generated documentation. It does not regard the \verb#-author# option\footnote{This is valid for version 0.1.0 of the library; it may have changed for a later version}. 

\paragraph{\lstinline|@href|}\label{sec:TagHref}  Usage: \lstinline|{@href <url> <text>}| or \lstinline|{@href <url>}|

With this tag, an HTML hyperlink can be added to the generated documentation; if will place inside the description text, but different from the \nameref{sec:TagLink} and \nameref{sec:TagLinkplain} tags, it allows to refer to arbitrary external resources, not only to other documented elements. Obviously, \verb#<url># is the target URL, while \verb#<text># is the clickable text. If the latter is omitted, the URL itself will be used instead.

\paragraph{\lstinline|@inspired|}\label{sec:TagInspired}  Usage: \lstinline|@inspired <text>|

Sometimes a piece of code was inspired by a document of some kind, a description of an algorithm, a product white paper, or whatever. This tag allows you to add a reference to that source of inspiration. 

\paragraph{\lstinline|@modified|}\label{sec:TagModified}  Usage: \lstinline|@modified <name-text> - <email-address>|

This is a variant of the \nameref{sec:TagExtAuthor} tag. It is meant to provide the name of the developer that modified the respective element without claiming to be an author.

\paragraph{\lstinline|@note|}\label{sec:TagNote}  Usage: \lstinline|@note <text>|

With this tag, it is easy to add important notes to the generated documentation for an element. All notes will be added to a bullet list placed immediately beneath the documentation text. The text for the \lstinline|@note| tag is somehow limited as it does not allow other JavaDoc tags.

\paragraph{\lstinline|@thanks|}\label{sec:TagThanks}  Usage: \lstinline|@thanks <name-text> - <email-address>|

Use this tag to mention someone who provided input to the respective element without being an author; that person might have wrote an article about the algorithm that was implemented by this element, or they may have reported a bug.

Same as for the \nameref{sec:TagExtAuthor} and the \nameref{sec:TagModified} tags, the email address will be rendered to a \verb#mailto:# link in the generated documentation.

\paragraph{\lstinline|@UMLGraph.link|}\label{sec:TagUMLGraph}  Usage: \lstinline|@UMLGraph.link|

This adds an UML graph for the current class to the generated documentation.


\section{Implementation Comment Formats}
A source code file can have four styles of implementation comments:
\begin{itemize}[nosep]
\item{structuring comments}
\item{block comments}
\item{single-line comments}
\item{trailing or end-of-line comments}
\end{itemize}

\subsection{Structuring Comments}\label{sec:StructuringComments}
Structuring comments are the most simple comments: they are used to separate the parts of a class (as defined in chapter \tqfullvref{sec:ClassAndInterfaceDeclarations}) from each other. They have the form
\begin{lstlisting}
    /*------------------*\
====** Enum Declaration **===========================================
    \*------------------*/
    /*---------------*\
====** Inner Classes **==============================================
    \*---------------*/
    /*-----------*\
====** Constants **==================================================
    \*-----------*/
    /*------------*\
====** Attributes **=================================================
    \*------------*/
    /*------------------------*\
====** Static Initialisations **=====================================
    \*------------------------*/
    /*--------------*\
====** Constructors **===============================================
    \*--------------*/
    /*---------*\
====** Methods **====================================================
    \*---------*/
\end{lstlisting}

with the lines ending at column 80 (the samples here are too short).

If a class or interface does not have a particular part, the assigned structuring comment must be omitted.

I recommend to create “Building Blocks” with these comments. Eclipse provides the Snippet facility for this purpose\footnote{Storing the comments as code templates is not recommended as a template would be reformatted on insert.}. Refer to chapter \tqfullvref{sec:SnippetStructuringComments} for the snippet code for the structuring comments.

\subsection{Block Comments}\label{sec:BlockComments}
Block comments are used to provide detailed descriptions of files, methods, data structures and algorithms – meaning that the text of the comment is longer than just one line. Block comments may be used at the beginning of each block after the opening brace. They can also be used in other places, such as within methods. Block comments inside a function or method should be indented to the same level as the code they describe. 

A block comment should be preceded by a blank line to set it apart from the rest of the code. If the block comment does not directly refer to the code line immediately after it, it should be followed by another blank line.

Next, the first line of the comment block has to remain empty, and the closing of the comment block has to be placed on a line of its own.

Some samples:
\begin{lstlisting}
{
    /*
     * Here is a sample of a block comment. Block comments are used
     * to provide detailed information about code internals.
     */
    Result value = retrieveResult( parameter );
    …

    /*
     * Here is another sample of block comment, somewhere in the
     * middle of a code block. Please note the blank line above!
     */
    …
}

// AVOID!
/*
 * This block comment is outside the code block it refers to. Block 
 * comments should be placed after the opening curly brace of the
 * block.
 */
{
    Result value = retrieveResult( parameter );
    …
 
/* The first line of the block comment should be left empty and the
 * comment should be indented in the same way as the code in the
 * block.
 */
    processResult( value, parameter );
    /* 
     * Here the empty line above the comment is missing …
     * … and the closing tag should be on a line of its own. */
\end{lstlisting}
 
\subsection{Single-Line Comments}\label{sec:SingleLineComments}
Short comments can appear on a single line; they will be indented also to the level of the code that follows. Usually it should be written in the form of a headline:
\begin{lstlisting}
//---* Handle the condition *----------------------------------------
\end{lstlisting}
with the dashes ending on column 80.\footnote{A quick reminder: the sample code in this document uses a line length of 70, so the dashes in the comment line above ends an column 70.}

If a comment cannot be written in a single line, it should have the block comment format (see chapter \tqref{sec:BlockComments}). A single-line comment should be separated from the preceding code by a blank line. Only when the preceding line contains only the opening curly brace as in the \lstinline|if-then-else| sample below (lines~3 and 8). 

Here are some examples of single-line comments in Java code:
\begin{lstlisting}[numbers=left]
if( cache.contains( key ) )
{
    //---* Take the data from the cache *----------------------------
    …
}
else
{
    //---* Load the data from its original source *------------------
    …
}
…
ResultData resultData = executeService();

//---* Format the output for the UI *--------------------------------
formatResult( resultData );
…
\end{lstlisting}

Another form of the single line comment is the empty block comment:
\begin{lstlisting}
public interface Marker
{ /* No methods */ }

public class Extension extends Base
{ /* No implementation */ }

private Constructor() { /* Does nothing */ }

public void adapterMethod() { /* Does nothing */ }

public final void method()
{
    …

    try
    {
        …
    }
    catch( final MyException e ) { /* Exception deliberately swallowed /* }

    …
}   // method()
\end{lstlisting}

And finally, there are the “class termination comments” that repeats the name of the class after the last curly brace:
\begin{lstlisting}
public final class MyClass
{
    …
}
//  class MyClass

public final interface MyInterface
{
    public record InnerRecord( final int number )
    {
        …
    }
    //  record InnerRecord
    
    …
}
//  interface MyInterface

\end{lstlisting}

\subsection{Trailing or End-Of-Line Comments}\label{sec:TrailingOrEndOfLineComments}
Very short comments can appear on the same line as the code they describe, but should be shifted right far enough to separate them from the statements. If more than one short comment appears in a chunk of code, they should all be indented to the same tab setting.

Here's an example of a trailing comment in Java code:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            /* special case */
}
else
{
    return isPrime( a );    /* works only for odd a */
}
\end{lstlisting}

But it is more common to use “\verb#//#” instead of “\verb#/*…*/#” for these trailing comments:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            // special case
}
else
{
    return isPrime( a );    // works only for odd a
}
\end{lstlisting}

You will use trailing comments to provide the documentation for local variables\footnote{Usually, the name of that local variable should be sufficient (refer to chapter \tqvref{sec:Fields}), or the meaning of that variable is obvious from the context, but sometimes it still make sense to provide that kind of additional information.}:
\begin{lstlisting}[numbers=left,caption={Gauss's Easter algorithm\autocite{WIKIPEDIA:DateOfEaster,WIKIPEDIA:Gaussche_Osterformel}}]
/**
 *  <p>{@summary This method calculates the date of Easter Sunday 
 *  for the given year.} The year has to be in the range from 1583 
 *  to 3900 (included).</p>
 *  <p>The resulting date is for the Gregorian calendar.</p>
 *  <p>The algorithm itself is not the original one published by Carl
 *  Friedrich Gauß first in 1800 (corrected version in 1816), but
 *  that one published by Heiner Lichtenberg in 1997.
 *
 *  @thanks Carl Friedrich Gauß
 *  @thanks Heiner Lichtenberg  
 *
 *  @param  year    The year for which the date of Easter Sunday is 
 *      wanted for.
 *  @return The date of Easter Sunday in the given year.
 *  
 *  @see <a href="https://de.wikipedia.org/wiki/Gau%C3%9Fsche_Osterformel">Gaußsche Osterformel</a>
 */
public static final LocalDate calcEasterDate( final Year year )
{
    /*
     * The explanation for the variables was taken from the German
     * Wikipedia article and translated by me. The original terms
     * are given in parenthesis.
     */
    final int x;  // The year
    final int k;  // The secular number (die Säkularzahl)   
    final int m;  // The secular moon shift (die säkulare Mondschaltung)
    final int s;  // The secular moon shift (die säkulare Sonnenschaltung)
    final int a;  // The moon parameter (der Mondparameter)
    final int d;  // The seed for the first full moon in spring (der Keim 
        // für den ersten Vollmond im Frühling)
    final int r:  // The calendar adjustment (die kalendarische
        // Korrekturgröße)
    final int og; // The Easter limit (die Ostergrenze)
    final int sz; // The first Sunday in March (der erste Sonntag im März)
    final int oe; // The distance of Easter Sunday from the Easter limit
        // – Easter distance in days (die Entfernung des Ostersonntags
        // von der Ostergrenze – Osterentfernung in Tagen)
    final int os; // The date of Easter Sunday as a March date with 
        // March 32 as April 1 etc. (das Datum des Ostersonntags als 
        // Märzdatum – 32. März = 1. April usw.)
    
    //---* Check the arguments *-------------------------------------    
    if( requireNonNullArgument( year, "year" ).isBefore( Year.of( 1583 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years greater than or equal to 1583" );
    }
    if( year.isAfter( Year.of( 3900 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years less than or equal to 3900" );
    }

    //---* Lichtenberg's Easter formula *----------------------------
    x = year.getValue();
    k = x / 100;    
    m = 15 + (3 * k + 3) / 4 - (8 * k + 13) / 25;
    s = 2 - (3 * k + 3) % 4;
    a = x % 19;
    d = (19 * a + m) % 30;
    r = (d + a / 11) / 29;
    og = 21 + d - r;
    sz = 7 - (x + x / 4 + s) % 7;
    oe = 7 - (og - sz) % 7;
    os = og + oe;

    /*
     * Initialise the return value with the last day of February and 
     * add the calculated number of days.
     */
    final var retValue = LocalDate.of( y, MARCH, 1 )
        .minusDays( 1 )
        .plusDays( os );

    //---* Done *----------------------------------------------------
    return retValue;
}   //  calcEasterDate()
\end{lstlisting}

As you can see, for this use case it is acceptable to continue a long comment in the following line (see lines~31 and 32, for example) without using a block comment.

Another use case for these kind of comments is to provide information about the arguments of a method call; usually, you should avoid method signatures where this is required (the formal parameter of the method should be sufficient to explain the argument), but sometimes it makes still sense:
\begin{lstlisting}
…
drawCircle(
    x, y, // The center of the circle
    d/2.0 // The radius of the circle, calculated from the diameter
);
…
\end{lstlisting}

The end comment for a method is also of this type:
\begin{lstlisting}
public final void method()
{
    …
} //  method()
\end{lstlisting}

Also a long code block\footnote{But if it seems really necessary to add such a comment to a linear code block, you should consider to re-organise your code.} can be commented like this:
\begin{lstlisting}
{
    //---* Calculate the result *------------------------------------
    // Lots of code comes here ...
    …
} //  End of result calculation
\end{lstlisting}

The end comments for the bodies of \lstinline|for|, \lstinline|while|, \lstinline|switch| and even \lstinline|if-then-else| blocks are a special case, as those blocks should be introduced by a label, and this label should be repeated as the end comment:
\begin{lstlisting}
ScanLoop: for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  ScanLoop:

ForeverLoop: while( true )
{
    // Lots of code comes here ...
    …
}   //  ForeverLoop:

TypeSwitch: switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  TypeSwitch:

SpecialCaseTurnout: if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  SpecialCaseTurnout:
else
{
    // Not so much code here
    …
}    
\end{lstlisting}
Note the colon at the end of each of the comments!

Do not use the introducing code line for the end comment! That code line may change at some point in time and then the end comment does not have a corresponding starting line anymore.\footnote{This also means that you should be careful with removing or changing labels in the code.}

Avoid this:
\begin{lstlisting}
// AVOID!!!
for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  for( final var s : lines )

while( true )
{
    // Lots of code comes here ...
    …
}   //  while( true )

switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  switch( type )

if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  if( isSpecialCase() )
else
{
    // Not so much code here
    …
}    
\end{lstlisting}

\section{Maintenance Comments}\label{sec:MaintenanceComments}
It is very likely that source code will be changed more than once during its lifetime. Bugs will be fixed, functionality is added or removed, refactorings will be applied, or the code will be migrated to other platforms or different versions of the programming language, the underlying libraries, the connected systems and/or the operating system.

There is a practice that all the changes made in the code will be commented in the code. These comments are usually referred to as “Maintenance Comments”.

This may look like this:
\begin{lstlisting}
…
//<<BEGIN FSP-4711 – applied by Micky Mouse
//<Old Code>
//…
//>><<
<New Code>
…
//>>END FSP-4711
\end{lstlisting}

It has proved that this is not a good practice at all, and a really bad practice if dealing with code that is managed by an SCCS.

First, this practice causes problems for the compare tools coming with the SCCS – at least it will make it more difficult to read the comparison results from those tools.\footnote{Most comparison tools will recognise the out-commenting of the old code as a change and the new code as additional code instead of the replacement for the old code. This is at least confusing when a code revisions are made on the fix.} And the main function of those comments – documenting the changes – is much better served by the SCCS tools themselves.

Second, this gets even worse when the fix needs a fix. Just think about overlapping changes, like FSP-4712 changes lines from the new code of FSP-4711, together with lines directly below, or changes that has to be partially reverted, and so on.

And finally, the comments does not help to identify if your are currently running the patched code, or the old one.

On the other hand, nothing can be said against adding a line to the file or class comment that lists the patches that were applied to the code.

Therefore I recommend to introduce an annotation that can be used to mark elements that are affected by a fix.

Such an annotation can provide the BUG number of the fix, together with a short description of the issue. This annotation replaces a comment about the applied patches, with the advantage that it can be retrieved also from the compiled classes, even at runtime.

Chapter \tqfullvref{sec:PatchIdentification} provides an example of such an annotation.

Old code will be removed and not commented out, or just replaced by the new code. One or the other short comment with a hint is not mandatory, but does not harm either.

When using the suggested annotation from chapter \tqref{sec:PatchIdentification}, this could look like this:
\begin{lstlisting}
…
@BUG( id = "BUG-4711", comment = "No end criterion for loop" )
@BUG( id = "BUG-4712", comment = "Exception was swallowed" )
public final void myMethod()
{
    ForeverLoop: while( true )
    {
        try
        {
            …
            
            if( !hasMore() ) break ForeverLoop; // BUG-4711
        }
        catch( final IllegalStateException e )
        {
            log( e );
            break ForeverLoop; // BUG-4712: Added exception handling
        }
    }   //  ForeverLoop:
}   //  myMethod()
…
\end{lstlisting}

\section{Special Comments}
The “Code Conventions for the Java\textsuperscript{TM} Programming Language”\autocite{SUN_CODE_CONVENTIONS:SpecialComments} suggests some special comments: \verb#XXX# in a comment flags something that is bogus but works. \verb#FIXME# flags something that is bogus and broken (and has to be fixed very soon).

Eclipse knows a setting that allows to externalise such comments into a task list:\\ \verb#Window|Preferences|General|Editors|Structured Text Editors|Task Tags#.

It also adds \verb#TODO# to that list, for something that still needs to be implemented.

\section{Commenting out Code}
Use the “//” delimiter to comment out a complete line, only a partial line, or a whole bunch of consecutive lines of code.

Example:
\begin{lstlisting}
if( foo > 1 )
{
    //---* Do a double-flip *----------------------------------------
    …
}
else
{
    return false;          // Explain why here.
}
//if( bar > 1 )
//{
//    //---* Do a triple-flip *--------------------------------------
//    …
//}
//else
//{
//    return false;
//}
\end{lstlisting}

To use a block comment (“\verb#/*…*/#”) for commenting out sections of code is not a good idea, although you do not have to type that much: you cannot have a block comment inside a block comment.

The easiest way to comment out a selected code block this way in Eclipse is to use \verb#Source|Toggle Comment# from the menu or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “7” instead of “/”.}.

In IntelliJ IDEA, it is the menu command \verb#Code|Comment with Line Comment# or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “÷” on the numeric keypad instead of “/”.}.

\section{Comments when?}\label{sec:CommentsWhen}
To repeat what was already said at the beginning of the chapter \tqfullref{sec:WritingProperComments}: The frequency of comments reflects poor quality of code, but code can be “under-commented” or “over-commented”. This means that there is a “frequency band” for comments that has to be hit for good quality code.

The advice “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” raises the question for whom the code has to made clearer, because the experts and the rookies are completely distinct audiences, with different needs in regard of comments in the source code.

Same with that other advice (“Even if you don't think, a comment might be necessary, add it nevertheless”): it is the other extrema, and equally bad.

That leads us (again) to the conclusion, that writing good comments to source code is a complex art.

This means that this document cannot give you a complete rule set here, just some guidance.

That documentation comments are required everywhere possible, and how to write them was already covered in chapter \tqfullvref{sec:DocumentationComments}, thus we focus here on the implementation comments.

\begin{itemize}
\item{No empty blocks are allowed (means that “\{\}” may not occur in the code). If there is really no code in a block, there have to be least a comment, just to show that this is deliberate. For \lstinline|catch| blocks, there should be a good (at least some) explanation, why it is empty (see also chapter \tqfullref{sec:GeneralExceptionHandling}).

Some samples:
\begin{lstlisting}
//---* Skip input stream until then end *----------------------------
while( input.read() != EOF ) { /* empty */ }
// Better
while( input.read() != EOF );

//---* Spent CPU cycles on counting *--------------------------------
for( var i = 0; i < maxValue; ++i ) { /* empty */ }
// Better
for( var i = 0; i < maxValue; ++i );


InputStream input = null; // null if cannot open file
try
{
    input = new FileInputStream( "myFile" );
}
catch( final FileNotFoundException ignored ) { /* Deliberately ignored */ }
// Better
InputStream input; // null if cannot open file
try
{
    input = new FileInputStream( "myFile" );
}
catch( final FileNotFoundException ignored ) 
{ 
    input = null;
}

@MountPoint
public Data customAction( final Data data ) { /* Does nothing */ }

public MyClass() { /* Just exists */ }

public interface MyInterface { /* No methods */ }
\end{lstlisting}

The annotation \lstinline|@MountPoint| is described in the chapters \tqfullvref{sec:NonFinalClasses} and \tqfullvref{sec:NonFinalMethods}, a sample implementation can be found in chapter \tqvref{sec:MountPoint}.}
\item{A short description of the algorithm that was implemented by the current code is always helpful; even just mentioning its name can make a difference when hunting a bug. But in case the implementation changes, such a comment needs to be adjusted as well.}
\item{Whenever you hurt or ignore one of the rules, guidelines, or recommendations from this document, it is worth a comment:
\begin{lstlisting}
value = 7.0 / a; // a != 0.0 was already checked above

o.execute(); // o != null was checked in foo.bar( o )

/*
 * bar.getQ() will never return null, so an explicit check on
 * null for q was omitted
 */
q = bar.getQ();
q.execute();}
\end{lstlisting}
In all these samples, arguments or values are not checked for \lstinline|null| or zero, \textit{because this was already done elsewhere} – and not necessarily just one line above the current location. The comment tells a maintenance engineer that the check was made – at least in the initial version of the code – and that the root cause for the problem might be elsewhere (perhaps because someone eliminated that other location or at least the value check there).}
\item{A comment is mandatory each time an exception is swallowed, no matter if silently or not, meaning the exception is logged somewhere. If the program is continued after an exception was caught, write a comment (see also chapter \tqfullref{sec:GeneralExceptionHandling}).}
\item{As said already in chapter \tqfullvref{sec:SwitchStatements}, a comment is required on a case fall-through.}
\item{Non-obvious class casts should be explained with a comment, in order to document that the programmer knew what they did:
\begin{lstlisting}
private final void valueProcessor( List<Object> values )
{
    …
    Value value;
    for( Object o : values )
    {
        /*
         * We know that values can only contain Value objects;
         * otherwise this method would not have been called to
         * process the list.
         */
        value = (Value) o;
        …
}
\end{lstlisting}
This makes sense here because a check like
\begin{lstlisting}
if( o instanceof Value ) value = (Value) o;
\end{lstlisting}
is relatively expensive – especially if the contract for this \lstinline|private| method is that it is called only with lists containing \lstinline|Value| objects so that the check would not be positive only in very, very, very rare cases. And finally: what else can be done in cases where the object is not of the right type than throwing a ClassCastException? That's the same that is done by the code above in such a case, too.

First, the version
\begin{lstlisting}
if( o instanceof Value value )
{
    …
}
\end{lstlisting}
might be clearer, but it is not less expensive.

Second, having a list of \lstinline|Value| objects declared as \lstinline|List<Object>| is bad design – or legacy code.}
\item{In some sources you will find the recommendation to add a comment at the end of a long compound statement; this was already discussed in chapter \tqfullref{sec:SingleLineComments}.}
\item{With the \lstinline|@SuppressWarnings| annotation\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION}, you can switch off a compiler warning or error caused by code that is somehow “hurting the rules”. Basically, the \lstinline|@SuppressWarnings| annotation is a replacement for a comment about that deviation from the rules, an additional comment is required only in cases it is not obvious why that annotation was applied. More details on this are provided in \tqfullvref{sec:CompilerWarningsAndErrors}.}
\item{tbc}
\end{itemize}

\section{Updating Comments}
If the code has to be modified, no matter if due to regular maintenance, bug fixing or a migration, all related comments has to be updated accordingly. There is no value in keeping “historical comments”, although mentioning the old algorithm when the former implementation has been replaced completely might be useful in some cases.

But keeping the outdated code as a comment is definitely not useful, in particular not when there is an SCCS used to manage the code.

\chapter{Coding Guidelines}\label{sec:CodingRules}
These guidelines are a collection of coding standards and best practices. Obeying them should make your code better readable and less error prone. Some of them will even help to increase the program's overall performance. So perhaps you should see them not as optional, but more as obligatory rules.

As always there may be good reasons to do it different from what is recommended or even requested by the guidelines\footnote{You remember the bullet points~\ref{lst:ZoP:SpecialCases} and \ref{lst:ZoP:Practicality} from the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython, PYTHON_ORG_MAILING_LIST:ThePythonWay} that I quoted in chapter \tqvref{sec:OtherProgrammingLanguages}? If not, here are they again: “\ref{lst:ZoP:SpecialCases}~Special cases aren't special enough to break the rules~…” and “\ref{lst:ZoP:Practicality}~…~although practicality beats purity”.}. In such case a comment is required that describes that reason.\footnote{Omitting this comment is also a deviance from the rule, requiring a comment to explain it. Also known as the Catch~22\autocite{WIKIPEDIA:Catch22}.}

One basic recommendation is that you should not write the same code over and over again. This is also known as the “DRY Principle” (“Don't Repeat Yourself”) and we will discuss this later again.

And please keep in mind that not always the shortest, most compact source code is the best. Also avoid what is known as “Premature Optimization”\footnote{Donald E. Knuth made the following statement on optimisation: “We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil.”\autocite{Knuth:PrematureOptimization}}. Modern optimising compilers and run-time optimisers do a very good job to create compact object code, so in most cases the programmer can concentrate fully on writing readable and comprehensible code. In this context I would like to remind you on the quotation from Martin Fowler's book that I put in front of this document, and again to the “Zen of Python”, here the points “\ref{lst:ZoP:SimpleVsComplex}.~Simple is better than complex” and “\ref{lst:ZoP:ComplexVsComplicated}.~Complex is better than complicated”.\footnote{Yes, I know: for a document about Java Coding Conventions, there is an astonishing amount of references to Python~…}

But although optimisation still may have some limits, comments will have never any impact on the runtime performance of a program. So please refer to chapter \tqfullvref{sec:CommentsWhen} (if not done already) and see the recommendations on when to apply comments to your code.

\subsubsection{Types of Products}\label{sec:TypesOfProducts}
Some of the coding guidelines below are different for the type of product or project you are working on. Basically, we can distinguish the following types that will be explained in the following chapters\footnote{If you miss the terms ‘Framework’ and ‘Server’ on the list above: a \textit{Framework} is in this regard a \textit{Feature Library}, and a \textit{Server} is a \textit{Standalone Application} (what else could a server be?).}:
\begin{itemize}[nosep]
\item{Function Libraries}
\item{Feature Libraries}
\item{Tools}
\item{Standalone Applications}
\item{Server-based Applications}
\item{Extensions}
\end{itemize}
The individual types cannot be clearly distinguished one from another, there are some overlappings and gray areas. So when applying a guideline, you still have to use your judgement which implementation really fits for \textit{your project}.

\paragraph{Function Library}\label{sec:FunctionLibrary}
A function library is a collection of functions (often organised in utility classes – refer to chapter \tqvref{sec:UtilityClasses}) and helper classes. A function library does not have a state or requires an initialisation or configuration.

Samples are my Foundation Util library\autocite{TQUADRAT_ORG_FOUNDATION_UTIL}, the Commons Lang library from the Apache Commons project\autocite{APACHE_COMMONS_LANG}, or Google Guava\autocite{GOOGLE_GUAVA}.

My JavaComposer library\autocite{TQUADRAT_ORG_FOUNDATION_JAVACOMPOSER} is a sample for the beforementioned ‘gray area’: I decided to treat it as a function library, but it could have been a feature library, too. The various XML parsers and JSON parsers/generators will also belong to this gray area. 

\paragraph{Feature Library}\label{sec:FeatureLibrary}
A feature library adds a service or a complex functionality to your application. Quite often that functionality runs in its own thread(s) and is accessed like an external service, it has its own configuration and initialisation.

Sometimes these libraries can even be started standalone.

Samples for this are the various JDBC drivers, the H2 Database Engine\autocite{H2_DATABASE}, ActiveMQ\autocite{APACHE_ACTIVEMQ}, Jetty\autocite{ECLIPSE_JETTY}, or Hibernate\autocite{HIBERNATE_ORM}.

In the gray area here I would place JUnit\autocite{JUNIT5} and Log4j\autocite{APACHE_LOG4J}.

\paragraph{Tool}\label{sec:Tool}
A tool in this context is a program that is started, performs a single task and terminates afterwards. Most probably it will be invoked from the command line, and it will not have a UI, but takes all input data somehow from the command line. Perhaps it may even work as a filter\autocite{WIKIPEDIA:Filter}, reading from standard input and writing to standard output.

Programs like \verb#ls# or \verb#grep# belongs to this type, although they are of course not written in Java.

Gray area candidates are \verb#awk# and also \verb#sed#, but even \verb#javac#, the Java compiler, or \verb#javadoc#.

\paragraph{Standalone Application}\label{sec:StandaloneApplication}
A standalone application will run indefinitely (meaning until deliberately terminated by the user) and takes input continuously. Samples are a text editor, an IDE, an application server like WebSphere\autocite{IBM_WEBSPHERE} or a web container like Tomcat\autocite{APACHE_TOMCAT}.

\paragraph{Server-based Application}\label{sec:ServerbasedApplication}
Server-based applications are applicationn that require a special environment to be executed; the best example are JEE applications that need an application server like JBoss\autocite{REDHAT_JBOSS}, WebLogic\autocite{ORACLE_WEBLOGIC} or WebSphere\autocite{IBM_WEBSPHERE}, and web applications, requiring Tomcat\autocite{APACHE_TOMCAT} or any of the appservers mentioned before.

In this case, the program code has to follow several special rules, determined by the server environment. On the other side the enviroment provides several services that can be used by the application.

Other samples are Maillets for James\autocite{APACHE_JAMES} or the customisations (“mods”) for Minecraft\autocite{MINECRAFT} (although these could be regarded both as the gray area candidates here, because both could be seen also as extensions).

\paragraph{Extension}\label{sec:Extension}
An extension or a plugin requires also an environment to run in, but it is not an application as such. It just changes the behaviour of that environment. Annotation processors are samples for this (they change the behaviour of the Java compiler), as well as Maven\autocite{APACHE_MAVEN} plugins.

\section{Error Handling}\label{sec:ErrorHandling}
A proper error handling is crucial for any code, no matter in which type of program it lives – but the definition of \textit{proper} depends significantly on the type of the final product, as it was defined above.

Basically, we have to deal with only a very limited set of possible error categories:
\begin{enumerate}[nosep]
\item{An exception is thrown by an operation triggered by our code.}
\item{An operation returns an error state.}
\item{The result of an operation is an unexpected or an unwanted value.}
\item{A method is called with an invalid argument.}
\item{Input data is invalid or corrupted.}
\item{A command line argument is invalid.}
\item{An external resource is not or no longer available.}
\end{enumerate}

Of course, all those categories are possible triggers for an exception in Java. This means that we can quite simply generalise the response to an error: \textit{in case of an error condition, throw an exception}!

Consequently, we can also simplify \textit{error} handling to \textit{exception} handling. And there are only a few options on how to respond to an exception:
\begin{itemize}
\item{Throw an exception and make it an S.E.P.\footnote{S.E.P~=~Someone Else's Problem (refer to \autocite{ADAMS_HITCHHIKERS_GUIDE}).} – particularly suitable (no irony!) for libraries.}
\item{Perform an alternate operation or provide a default value.}
\item{Retry/repeat the operation.}
\item{Abort the current operation – either the current thread or the whole program.}
\end{itemize}

As said, throwing an exception will always work, but at some point exceptions need to be handled in some way.

The other alternatives are feasible only in some special contexts:
\begin{itemize}
\item{Repeating or retrying a failed operation depends on the kind of operation, and not that much on the type of the product. This also should not be done indefinitely; at some point, it gets useless to repeat or retry a constantly failing operation.}

\item{Same for an alternate operation that will be executed in case of an error.}

\item{Providing a default value demands that this default value makes sense in the current context. It should be obvious that this is not always the case.}

\item{To abort a Java program (in fact, to abort the JVM that executes that Java program), you call the method \lstinline|java.lang.System::exit|\autocite{ORACLE_DOC_SYSTEM:exit} with a negative integer as the argument. But this is only acceptable for a tool and, with some limitations, for a standalone application. Libraries, extensions and especially server-based applications are not allowed to call \lstinline|System.exit()|! Never!

A thread will be aborted automatically when an exception is thrown and not caught. If this thread is the last non-deamon thread, the JVM will go down, too. So usually the best thing to abort the current operation is to throw an \lstinline|Error| – for the details, refer to chapter \tqref{sec:GeneralExceptionHandling}.}
\end{itemize}

Only these four options do exist for handling an exception! This means that afterwards the error condition is fixed, or that it persists.

I bet that you now ask yourself why the actions below are missing from my list above:
\begin{itemize}
\item{Log an error message.}
\item{Write an error message to the console, a message window or status bar.}
\item{Display an error dialog.}
\end{itemize}

That is because \textit{none of these are handling the error}! Of course you should log an error, of course you should inform the user about an error condition. But none of these actions will change the state of the system!

Far too often you find code like this:
\begin{lstlisting}
…
try
{
    writeStatusToBillingSystem( invoice );
}
catch( final TimeOutException e )
{
    m_Logger.error( e );
}
invoice.markAsPaid();
…
\end{lstlisting}

Looks good, right?

Really?

You mark the invoice as paid, despite the writing to the billing system failed?

You think that this cannot happen, because you have logged the exception?

I think that the accountants are no longer your friend when they find out that this piece of code was written by you~…

The chapters \tqvref{sec:ThrowingExceptions} and \tqvref{sec:GeneralExceptionHandling} discuss throwing and handling exception. More about reporting the various error conditions can be found in chapter \tqvref{sec:ReportingErrors} and the chapter \tqvref{sec:Logging} deals with logging in particular.

\subsection{Throwing Exceptions}\label{sec:ThrowingExceptions}
Your code will emit an exception when it encounters an error condition of some kind. Exceptions are discussed in detail in the Java Language Specification\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Exceptions}; I just repeat the basics here.

For the Java programming language, an exception is an instance of a class that is derived from \lstinline|java.lang.Throwable|\autocite{ORACLE_DOC_THROWABLE_CLASS}, or – more precise – from one of the child classes of \lstinline|Throwable|:
\begin{itemize}[nosep]
\item{\lstinline|java.lang.Exception|\autocite{ORACLE_DOC_EXCEPTION_CLASS}}
\item{\lstinline|java.lang.RuntimeException|\autocite{ORACLE_DOC_RUNTIMEEXCEPTION_CLASS}}
\item{\lstinline|java.lang.Error|\autocite{ORACLE_DOC_ERROR_CLASS}}
\end{itemize}

The different kinds of exceptions are discussed in \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:KindsOfExceptions}.

Exception classes that extend \lstinline|java.lang.Exception| are so-called \textit{checked} exceptions; if a method wants to throw one of these, it has to declare that with the \lstinline|throws| clause. The class \lstinline|java.lang.RuntimeException| is a direct subclass of \lstinline|java.lang.Exception| and the superclass of all \textit{runtime} exceptions – declaring these is not mandatory.

While an ordinary program can \textit{potentially} recover from an error condition signalled by an \lstinline|Exception| instance, it is assumed that instances of the class \lstinline|java.lang.Error| and its subclasses will indicate unrecoverable error conditions, causing the program to abort.

The class of the thrown exception should be chosen appropriate to the error condition it indicates. So throwing just an instance  \lstinline|java.lang.Exception| or \lstinline|java.lang.RuntimeException| is usually not a good idea – same if throwing a \lstinline|java.lang.NullPointerException| in case a divisor is 0.

When selecting the exception class, your first look should be to the already existing exception implementations if there is already one that fits your needs.\footnote{Although sometimes the name of an exception looks good, you should also consider which package it lives in; throwing an exception from a JNDI related package like \lstinline|javax.naming.OperationNotSupportedException| in a code segment that does nothing with the “Java Naming and Directory Interface” at all will cause more confusion than it helps. Not to mention that it may require an additional module.} If none of the existing ones fit, implement your one exception class by extending one of \lstinline|Exception|, \lstinline|RuntimeException|, or \lstinline|Error|, depending on your needs\footnote{You can create your own exception class that extends \lstinline|Throwable| directly, but so far I have not found a use case for that.}. This is always useful in the case of a feature library to simplify its API\footnote{All methods will only throw one exception especially created for that library, or exceptions derived from that. Samples for this pattern are the Servlet API (throwing only instances of \lstinline|IOException| and \lstinline|ServletException|) or JDBC (throwing only \lstinline|SQLException| instances).}, and it can be also helpful for an application.

When implementing an extension or a server-based application (or when using a particular framework), you have to implement quite often methods that declare only one, sometimes two exceptions. Nevertheless, it may happen that a method call in your code throws an exception that cannot be handled by the current code, but it cannot be delegated also, because the interface for the method does not declare that particular exception. In such a case, you have to catch the exception and to wrap it into an instance of the declared exception that will be thrown afterwards. For a servlet implementation\autocite{JAKARTA_EE_HTTPSERVLET_CLASS}, this may look like this:
\begin{lstlisting}
protected final void doGet( HttpServletRequest request, HttpServletResponse response )
    throws ServletException, IOException
{
    …
    try
    {
        …
    }
    catch( final TimeOutException e )
    {
        throw new ServletException( e );
    }

    …
}  //  doGet()
\end{lstlisting}

When instantiating an exception instance, you should always provide a textual message that describes the error condition and/or provides additional information, like the name of the file that cannot be found, or the SQL statement with the invalid syntax.\footnote{In this regard, the sample above is bad, because it does not provide such an explanation.} These text have to be in English language, for the same reason why the names and the comments are in English.

Of course, messages that will be presented to the end user in a UI have to be localised, but the UI should not display the raw exception message anyway at all.

Some exception classes do not have a constructor that allows to provide a cause, or they have constructors that allow either a message or a cause, but not both. A sample for that is \lstinline|java.lang.ExceptionInInitializerError|\autocite{ORACLE_DOC_EXCEPTIONININITIALIZERERROR_CLASS}.

Some of these exception classes will allow a workaround that allows you to still provide both, cause and message, with them exceptions, like below:\footnote{Unfortunately, \lstinline|ExceptionInInitializerError| does not belong to this group of exception classes.}: 
\begin{lstlisting}
static
{
    try
    {
        …    
    }
    catch( final Exception e )
    {
        throw new DumpException( "Message" )
            .initCause( e );    
    }
}
\end{lstlisting}

For the method \lstinline|initCause()| refer to \autocite{ORACLE_DOC_THROWABLE:initCause}.

\subsection{General Exception Handling}\label{sec:GeneralExceptionHandling}
A method is only allowed to handle an exception if it is able to restore the program state, otherwise it has to delegate it. Delegation can be done either by ignoring the exception – in this case it will be propagated to the caller automatically (it “bubbles up”) – or by catching and wrapping it, as described in chapter \tqfullref{sec:ThrowingExceptions}.

To handle an exception you first have to catch it.

Catching \lstinline|java.lang.Exception| is discouraged in most cases; it \textit{can} be acceptable when you need to wrap all checked exceptions into a runtime exception or an error:
\begin{lstlisting}
public final void run()
{
    try
    {
        …
    }
    catch( final Exception e )
    {
        throw new WrapperException( e );
    }
}   // run()
\end{lstlisting}

You should absolutely avoid to catch \lstinline|java.lang.Error| and all of its subclasses, \lstinline|java.lang.RuntimeException|, and of course, you should not never ever catch \lstinline|java.lang.Throwable|!\footnote{But no rule without an exception: refer to chapter \tqvref{sec:ExceptionHandlingInThreads}.}

Provide a \lstinline|catch| block for each and every exception that you want to handle:
\begin{lstlisting}
public final void run()
{
    try
    {
        …
    }
    catch( final FileNotFoundException e )
    {
        throw new ApplicationError( "Cannot find file", e );
    }
    catch( final IOException e )
    {
        throw new ApplicationError( "An error occurred on processing the input file", e );
    }
    catch( final NumberFormatException e )
    {
        throw new ApplicationError( "Input Data is corrupted", e );
    }
    catch( final PatternSyntaxException e )
    {
        throw new ApplicationError( "Pattern invalid", e );
    }
}   // run()
\end{lstlisting}

Sometimes when a large number of exceptions has to be handled with all the same code, you may be tempted to just catch \lstinline|java.lang.Exception|. As already said: don't do it! This approach will definitely cause problems as it may handle runtime exceptions in the same \lstinline|catch|-block as the checked exceptions, and usually this is not intended.

A simplificatin for the sample above could look like this:
\begin{lstlisting}
public final void run()
{
    try
    {
        …
    }
    catch( final IOException | NumberFormatException | PatternSyntaxException e )
    {
        throw new ApplicationError( "Processing failed", e );
    }
}   // run()
\end{lstlisting}
Still only the declared exceptions will be handled in the \lstinline|catch|-block, but unexpected exceptions will now bubble up\footnote{The exception class \lstinline|java.io.FileNotFoundException| is not listed because the class \lstinline|java.io.IOException| is its superclass.}.

Sometimes an exception indicates a regular program state (although this would indicate poor design in most cases)\footnote{Nevertheless, you can find this even in the Java Runtime Library~… but no one has ever said that the authors of the JDK had never made doubtful decisions.}. Usually you will avoid this situation by e.g. checking the operands before an operation, but a very popular example where this is not practicable is the conversion of a string into a numerical value:
\begin{lstlisting}
…
var amount = 0.0;
final var requestParam = request.getParameter( "amount" );
try
{
    if( nonNull( requestParam ) )
    {
        amount = Double.parseDouble( requestParam );
    }
}
catch( final NumberFormatException ignored )
{
    //---* If amount in request is not numeric, set it to 0.0 *------
    amount = 0.0;
}
…
\end{lstlisting}

As shown in the example, a comment is required in the catch clause, because you do not further propagate the exception neither do you log it.

It is also possible that you checked the preconditions, but you still have to deal with some checked exceptions:
\begin{lstlisting}
…
final var file = new File( … );
if( file.exists() )
{
    try( final var input = new FileInputStream( file ) )
    {
        …
    }
    catch( final FileNotFoundException e )
    {
        throw new UnexpectedExceptionError( "File was there when checked!", e );
    }
}
…
\end{lstlisting}

A sample for the class \lstinline|UnexpectedExceptionError| can be found in \autocite{TQUADRAT_ORG_FOUNDATION_UNEXPECTEDEXCEPTIONERROR}.

Some APIs in the JDK declares a checked exception, but that will never be thrown for the given arguments by any means. Most famous for this are the conversions from byte arrays to Strings and back:
\begin{lstlisting}
…
final String s;
try
{
    s = new String( byteArray, "UTF-8" );
}
catch( final UnsupportedEncodingException e )
{
    throw new ImpossibleExceptionError( "UTF-8 must exist!", e );
}
…
\end{lstlisting}

According to \autocite{ORACLE_DOC_CHARSET:StandardCharsets}, the UTF-8 encoding is mandatory for each JDK/JVM implementation, therefore the code sequence above will \textit{never} throw an \lstinline|UnsupportedEncodingException|. Nevertheless, it is not allowed to swallow the exception; instead an error should be thrown in the \lstinline|catch| clause, indicating the error condition. In the improbable case UTF-8 is not supported by the current Java runtime environment, the problem will surface, and the program will not die silently without any hint about the reason.\footnote{If, of course, there is no catch for \lstinline|Throwable| somewhere on the path.} It also protects you from malicious changes to the name of the character encoding: a none existing \lstinline|Charset| will cause noise.

Of course, the problem could be solved differently, by using an instance of \lstinline|java.nio.charset.Charset|\autocite{ORACLE_DOC_CHARSET_CLASS} as the argument to the \lstinline|String| constructor, instead of the name of the character encoding. For this case, the constructor does not declare an \lstinline|UnsupportedEncodingException|. 

Another example is the interface \lstinline|java.lang.Appendable|\autocite{ORACLE_DOC_APPENDABLE_INTERFACE}: it is implemented by \lstinline|java.io.Writer| and \lstinline|java.io.PrintStream|, but also by \lstinline|java.lang.StringBuilder| (and a few more). The method \lstinline|java.lang.Appendable::append| declares to throw an \lstinline|IOException|, but the implementation of that method for \lstinline|StringBuilder| will never throw it and does not even declare it.
\begin{lstlisting}
…
final Appendable appendable = new StringBuilder();
try
{
    appendable.append( "Some Text" );
}
catch( final IOException e )
{
    throw new ImpossibleExceptionError( "Append to StringBuilder", e );
}
…
\end{lstlisting}

Again, a sample for \lstinline|ImpossibleExceptionError| can be found in \autocite{TQUADRAT_ORG_FOUNDATION_IMPOSSIBLEEXCEPTIONERROR}.

Sometimes a method wants to act upon an error condition without handling the exception. In this case, it may catch the exception, does whatever necessary, then throw it again. An example:
\begin{lstlisting}
public final void myMethod() throw IOException
{
    final Predicate<String> isNetworkError = m_NetworkErrorPattern.asMatchPredicate();
    …
    try
    {
        …
    }
    catch( final IOException e )
    {
        final var message = e.getMessage();
        if( nonNull( message ) && isNetworkError.test( message ) ) ++networkErrors;
        throw e;
    }
    …
}   // myMethod()
\end{lstlisting}

It is usually not a good idea to log an exception and to rethrow or to wrap it afterwards, because this might cause the exception to be logged twice (or even more often). More details about logging can be found in chapter \tqvref{sec:Logging}.

Finally, you handle the exception somehow, by assigning a default value\footnote{see the sample about the conversion from string to number, above.}, or by performing an alternative action. In any case, you need to provide a comment in the \lstinline|catch| why you do not further delegate the handling of the exception.

If an exception was not caught in your code, it ”bubbles up” until it reaches the main method for the current thread (that is \lstinline|main()| for the main or program thread, and \lstinline|run()|\autocite{ORACLE_DOC_RUNNABLE:run} for any other thread). If this method will not handle the exception, the thread will be aborted. If this thread is the last non-deamon thread, the JVM will be terminated, too.

\subsection{Exceptions in Threads}\label{sec:ExceptionHandlingInThreads}
When we execute the Java program below, the \lstinline|Error| is printed to the console:
\lstinputlisting[numbers=left,caption={Test Abort main()}]{TestAbortMain.java}

\begin{verbatim}
$ java TestAbortMain.java
Exception in thread "main" java.lang.Error: Aborted
    at TestAbortMain.main(TestAbortMain.java:5)
$ 
\end{verbatim}

In the sample below, we abort a secondary thread:
\lstinputlisting[numbers=left,caption={Test Abort run()}]{TestAbortRun.java}

The output looks like this\footnote{When using an older version of Java, no output from the thread would be shown.}
\begin{verbatim}
$ java TestAbortRun.java
Exception in thread "Thread-0" java.lang.Error: run() aborted!
    at TestAbortRun.run(TestAbortRun.java:5)
    at java.base/java.lang.Thread.run(Thread.java:833)
Exception in thread "main" java.lang.Error: main() aborted!
    at TestAbortRun.main(TestAbortRun.java:20)
$ 
\end{verbatim}

This behaviour is sufficient for a tool in most cases, but not for a standalone application and not for a feature library. A function library usually relies on the a caller, while serverbase applications and extensions use the facilities provided by the host applications.

For both a standalone application and for a feature library, you want that error conditions will be logged, under all circumstances.

For the main thread of an application this can be achieved quite easily, by implementing the method \lstinline|main()| like this:
\begin{lstlisting}
/**
 *  The program entry method.
 *
 *  @param  args    The command line arguments.
 */
public static final void main( final String... args )
{
    try
    {
        final var application = new MyClass();
        applicaton.execute( … );
    }
    catch( final Throwable t )
    {
        //---* Log the previously unhandled exceptions *-------------
        m_Logger.error( "Unhandled Exception/Error", e );
    }
}   //  main()
\end{lstlisting}
In this case, the \lstinline|catch| statement catches \lstinline|Throwable| and the 
\lstinline|catch|-block does nothing else but logging the exception!

This is acceptable here only because the program ends immediately after the closing curly brace of the \lstinline|catch|-block!\footnote{Ok, technically only the main thread ends here because other non-deamon threads may still run at this point. But the goal should be that the main thread dies always at last.}

Theoretically, you can do the same thing for threads:
\begin{lstlisting}
public final void run()
{
    try
    {
        //---* The thread's payload *--------------------------------
        …
    }
    // NOT Recommended
    catch( final Throwable t )
    {
        //---* Log the previously unhandled exceptions *-------------
        m_Logger.error( "Unhandled Exception/Error", e );
    }
}   //  run()
\end{lstlisting}

One reason is that the method \lstinline|Runnable::run|\autocite{ORACLE_DOC_RUNNABLE:run} can be called also in other contexts than just as the main method of a thread; swallowing the exception like shown in the example is a bad idea in that case.

Another reason is that when the method is implemented as part of a library, an extension or even a server-based application, different facilities may be used to report the error.

But the main reason is that there is a much better mechanism that handles those otherwise unhandled exceptions: the “Uncaught Exception Handler”\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER_INTERFACE}.

The interface \lstinline|java.lang.Thread.UncaughtExceptionHandler| is a functional interface\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:FunctionalInterfaces, ORACLE_DOC_LANGUAGE_SPECIFICATION:FunctionalInterface, ORACLE_DOC_FUNCTIONALINTERFACE_ANNOTATION} providing the method \lstinline|uncaughtException()|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER:uncaughtException}.

There are basically two ways\footnote{In fact, three ways. But as you should avoid anonymous classes, this option is omitted here.} to implement an uncaught exception handler; the classical way would be to create a new class:
\begin{lstlisting}[numbers=left,caption={Class UncaughtExceptionHandlerImpl}]
/**
 *  The implementation of the interface
 *  {@link java.lang.Thread.UncaughtExceptionHandler}
 *  that is used by this project.
 */
public final class UncaughtExceptionHandlerImpl implements Thread.UncaughtExceptionHandler
{
    /**
     *  The logger that is used to report the uncaught exceptions.
     */
    private static final Logger m_Logger = getLogger( UncaughtExceptionHandlerImpl.class );
     
    /**
     *  {@inheritDoc}
     */
    @Override
    public final void uncaughtException( final Thread t, final Throwable e )
    {
        m_Logger.error( "Unhandled Exception/Error in Thread '%s'".formatted( t.getName(), e );
    }   //  uncaughtException()
}
//  class UncaughtExceptionHandlerImpl 
\end{lstlisting}

Otherwise you can benefit from \lstinline|java.lang.Thread.UncaughtExceptionHandler| being a functional interface and implement the uncaught exception handler as a method in your class:
\begin{lstlisting}
public final class MyClass
{
    /**
     *  The logger that is used by this class.
     */
    private static final Logger m_Logger = getLogger( MyClass.class );
     
    /**
     *  <p>{@summary This method will be invoked when the given
     *  thread terminates due to the given uncaught exception.}</p>
     *  <p>Any exception thrown by this method will be ignored by
     *  the Java Virtual Machine.</p>
     *
     *  @param  t   The thread that terminated.
     *  @param  e   The exception that caused the termination.
     *     
     *  @see UncaughtExceptionHandler#uncaughtException(Thread,Throwable)
     */
    private final void uncaughtException( final Thread t, final Throwable e )
    {
        m_Logger.error( "Unhandled Exception/Error in Thread '%s'".formatted( t.getName(), e );
    }   //  uncaughtException()
}
//  class MyClass
\end{lstlisting}
In the second case, the uncaught exception handler uses the resources provided by the class it lives in. This may be desired or not.

A thread can be configured with the uncaught exception handler in three different ways:
\begin{enumerate}
\item{Each single thread can get its own uncaught exception handler by calling \lstinline|setUncaughtExceptionHandler()|\autocite{ORACLE_DOC_THREAD:setUncaughtExceptionHandler} on it, with an instance of an implementation of \lstinline|Thread.UncaughtExceptionHandler| as the argument:
\begin{lstlisting}
public final class MyClass
{
    /**
     *  Does the program's work.
     *
     *  @throws InterruptedException   The worker thread was
     *      interrupted.
     */
    private final void execute() throws InterruptedException
    {
        final var thread = new Thread( this::run, "MyWorkerThread" );
        thread.setUncaughtExceptionHandler( this::uncaughtException );
        thread.start();
        thread.join();
    }   //  execute()
     
    /**
     *  The thread's main method.
     */
    private final void run() { … }
}
//  class MyClass
\end{lstlisting}
}
\item{On creation of a thread, a \lstinline|ThreadGroup|\autocite{ORACLE_DOC_THREADGROUP_CLASS} instance will be assigned to it; if none is explicitly set, it will be the group of the current thread.

The instance has a method \lstinline|uncaughtException()|\autocite{ORACLE_DOC_THREADGROUP:uncaughtException} method is called in the case the thread itself does not have an uncaught exception handler assigned to it. To change the behaviour of the handler from the thread group it is necessary to derive a new class from \lstinline|ThreadGroup| and to overwrite the \lstinline|uncaughtException()|.

Chapter \tqvref{sec:ThreadGroup} shows an implementation for \lstinline|ThreadGroup| that allows to configure the uncaught exception handler; when using that, the configuration can look like this:
\begin{lstlisting}
public final class MyClass
{
    /**
     *  The thread group for all threads used by this program.
     */
    private final ThreadGroup m_ThreadGroup;
    
    /**
     *  Creates a new instance of {@code MyClass}.
     */
    public MyClass()
    {
        m_ThreadGroup = new ThreadGroupExt( "MyWorkerThreads", this::uncaughtException );
    }   //  MyClass()
    
    /**
     *  Does the program's work.
     *
     *  @throws InterruptedException   The worker thread was
     *      interrupted.
     */
    private final void execute() throws InterruptedException
    {
        final var thread = new Thread( m_ThreadGroup, this::run, "MyWorkerThread" );
        thread.start();
        thread.join();
    }   //  execute()
     
    /**
     *  The thread's main method.
     */
    private final void run() { … }
}
//  class MyClass
\end{lstlisting}
}
\item{By calling \lstinline|java.lang.Thread::setDefaultUncaughtExceptionHandler|\autocite{ORACLE_DOC_THREAD:setDefaultUncaughtExceptionHandler} it is possible to install an instance of \lstinline|Thread.UncaughtExceptionHandler| for all threads that does neither have their own handler nor got one from their thread group. This uncaught exception will be called as a last resort.
\begin{lstlisting}
public final class MyClass
{
    /**
     *  Does the program's work.
     *
     *  @throws InterruptedException   The worker thread was
     *      interrupted.
     */
    private final void execute() throws InterruptedException
    {
        //---* Install the default uncaught exception handler *------
        Thread.setDefaultUncaughtExceptionHandler( new UncaughtExceptionHandlerImpl() );
        
        final var thread = new Thread( this::run, "MyWorkerThread" );
        thread.start();
        thread.join();
    }   //  execute()
     
    /**
     *  The thread's main method.
     */
    private final void run() { … }
}
//  class MyClass
\end{lstlisting}
}
\end{enumerate}

The last option can be used only from standalone applications and from tools. The environments for server-based applications and extensions do quite often restrict the creation of additional threads. A feature library should accept an uncaught exception handler and/or a thread group as a configuration value.

If a function library creates new threads, the respective methods must accept at least an uncaught exception handler and optionally a thread group. Alternatively, a thread factory\autocite{ORACLE_DOC_THREADFACTORY_INTERFACE} can be injected.
 
\subsection{Reporting Errors}\label{sec:ReportingErrors}
As already said earlier, at some point we need to report an error condition to the user of the program; this can happen in various ways. The most common is to log the error somehow, but as logging has various additional aspects, it is covered by a chapter of its own: chapter \tqfullvref{sec:Logging}.

Other means to report the error condition are the following:
\begin{itemize}
\item{Write an error message to the console, a message window or status bar.}
\item{Display an error dialog.}
\item{Send an email, a tweet or another kind of message.}
\item{Trigger an external signalling device (an alarm bell, a horn, a flashlight,~…).}
\item{…}
\end{itemize}

Before discussing this further, I want to repeat: \textit{Reporting an error condition is not handling it!}

Obviously, not all ways of reporting an error condition are feasible for types of products.

\begin{itemize}
\item{First, a function library should not report an error condition in any other way than just throwing the appropriate exception. It should not even log them.}

\item{Extensions and server-based applications should use the APIs that are provided to them by their host/container for reporting the error conditions, although server-based applications may introduce additionals ways to report an error.}

\item{Code in a function library, in a server-based application and in an extension should never write to the console or display an error dialog. The code of a feature library can use a message window, status bar or error dialog, if it provides these resources itself (basically, when it provides the UI).

Application servers, frameworks and the hosts for extensions usually provides a facility for error reporting that can be used; this may result in updating a message window or status bar, but for your code, this is transparent.}

\item{Sending messages around to report an error condition should be considered mainly for dark (headless) applications, either standalone or server-based. Of course, this something that can be provided by a feature library (as the new featured), but a feature library should not use it.

Whether it makes sense for a tool depends on the kind of the tool.}

\item{Same for the use of external signalling devices.}
\end{itemize}

In most cases, it is not sufficient to provide the user with the caught exception only – meaning just calling \lstinline|java.lang.Throwable::printStackTrace| is not enough. In fact, for most users, this is even too much information. Also providing the call stack for an operation in an \textit{error message} is sometimes considered as a security loophole, because it may give a potential attacker information about code internals that they can use to shape their attack against your system.

You should also consider to localise the error message to the locale of the user; that is mainly translating it to the user's language, but not only. You should always add the time zone to timestamps, or at least the offset to UTC, even when you adjust them to the user's time zone.

It is a good idea to have a unique error code with your error message. That allows you to identify it when the user reports it back to you, and you do not understand their language. 

Obviously, you should avoid to have sensitive data in your error messages. But ‘sensitive data’ may depend from the context your program is running in.

\subsection{Logging}\label{sec:Logging}
Logging is a mean to report errors and to make the respective messages available even after the program is down. But you can use logging for other purposes, too.

Nevertheless, \textit{logging} is mainly for the recording of technical issues. If you need to keep track of business transactions (if you have to provide an audit log or a journal), we talk about \textit{journalling} instead. There may be some overlapping between those two, and the requirements look similar, but logging and journalling are two distinct topics and should be treated independently from each other.

\subsubsection{Logging Infrastructure}
The simplest way would be to open a file during startup and to write the log messages there. That works, but this is not very flexible.

Because logging is an important feature, Java comes with a logging facility right out of the box, the so called ‘JDK~Logging’\footnote{Sometimes also referred to as ‘JUL’, by the name of the package.}, provided by the package \lstinline|java.util.logging|\autocite{ORACLE_DOC_LOGGING_PACKAGE, ORACLE_DOC_LOGGING_OVERVIEW}.

Despite the fact that it has improved significantly since its introduction with Java~1.4, most people prefer still use the logging subsystem provided by Log4j\autocite{APACHE_LOG4J}.

Next, only tools and standalone applications should configure a logging framework. Function libraries should no log at all, while feature libraries rely on the logging facilities of the host environment, same as server-based applications and extensions.

Logging for the latter two depends on the host environment, but for feature libraries (and for function libraries that really require logging) it is recommended to use SLF4J\autocite{SLF4J}.

SLF4J is only a facade for a logging framework (“SLF4J” stands for “Simple Logging Facade for Java”), its methods delegate to a \textit{real} logging framework; refer to \autocite{SLF4J:Binding} on how this is done. Originally, the API was inspired from Log4j, but it has evolved since then. SLF4J supports Log4j, JDK~Logging, Apache Commons Logging\autocite{APACHE_COMMONS_LOGGING} (formerly known as JCL – Jakarta Commons Logging) and Logback\autocite{LOGBACK} as well as ‘Simple’ logging. Support for other frameworks could be implemented easily if required.

Looking a the code to write, all three (JDK~Logging, Log4j and SLF4J) work basically the same:
\begin{enumerate}[nosep]
\item{During the initialisation of your class, obtain an instance of a logger class; the instances are named, usually by the name of the the class that obtains it\footnote{This is discussed in more detail in chapter \tqvref{sec:NamingOfLoggers}.}. These names are used for the configuration of a logger.}
\item{Keep the reference in a \lstinline|private static final| variable with the name \lstinline|m_Logger|.}
\item{Check whether the desired log level is active.}
\item{If the desired log level is active, log your message.}
\end{enumerate}

Even APIs are quite similar\footnote{Of course the code sample will not compile.}: 
\begin{lstlisting}[numbers=left]
// For JDK Logging:
import static java.util.logging.Logger.getLogger;
import static java.util.logging.Level.*; 
import java.util.logging.Logger;

// For Log4j:
import static org.apache.logging.log4j.LogManager.getLogger;
import org.apache.logging.log4j.Logger;

// For SLF4J:
import static org.slf4j.LoggerFactory.getLogger;
import org.slf4j.Logger;

public final class MyClass
{
       /*------------------------*\
    ===** Static Initialisations **==================================
       \*------------------------*/
    /**
     *  The logger that is used by this class.
     */
    private static final Logger m_Logger = getLogger( MyClass.class.getName() );
    
    // For Log4j and SLF4J, this also works:
    private static final Logger m_Logger = getLogger( MyClass.class );
    
       /*---------*\
    ===** Methods **=================================================
       \*---------*/
    public final void myMethod()
    {
        //---* Logging an error message *----------------------------
        final var message = "An error occurred!";
        final var error = new Error( "Something happened!" );
        
        // With JDK Logging
        m_Logger.severe( message );
        m_Logger.log( SEVERE, message, error );
        
        // With Log4j and SLF4J
        m_Logger.error( message, error );

        //---* Logging an informational message *--------------------
        // With JDK Logging
        if( m_Logger.isLoggable( INFO ) )
        {
            final var message = getCurrentStatus();
            m_Logger.log( INFO, message );
        }
        
        // With Log4j and SLF4J
        if( m_Logger.isInfoEnabled() )
        {
            final var message = getCurrentStatus();
            m_Logger.info( message );
        }
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

\subsubsection{The Log Levels}\label{sec:LogLevels}
The loggers can be configured to only log message with at least a certain priority or \textit{log level}. For JDK~Logging, Log4j and SLF4J, the predefined log levels differ:
\begin{filecontents}{LogLevels.tbl}
  \begin{longtable}{|c|c|c|X|}
  \caption{Log Levels} \\
  \hline 
  JDK~Logging & Log4j & SLF4J & Description \\ 
  \hline
  \endfirsthead
  \multicolumn{4}{c}%
  {\tablename\ \thetable\ -- \textit{Continued from previous page}} \\
  \hline 
  JDK~Logging & Log4j & SLF4J & Description \\ 
  \hline
  \endhead
  \multicolumn{4}{r}{\textit{Continued on next page}} \\ 
  \endfoot
  \endlastfoot
  & \verb#FATAL# & & A fatal event that will prevent the application from continuing. \\
  \hline
  \verb#SEVERE# & \verb#ERROR# & \verb#ERROR# & An error in the application, possibly recoverable. A message level indicating a serious failure. \\ 
  \hline 
  \verb#WARNING# & \verb#WARN# & \verb#WARN# & An event that might possibly lead to an error. \\ 
  \hline 
  \verb#INFO# & \verb#INFO# & \verb#INFO# & An event for informational purposes. \\ 
  \hline 
  \verb#CONFIG# & & & A message level for static configuration messages. \\ 
  \hline 
  \verb#FINE# & \verb#DEBUG# & & A general debugging event. A message level providing tracing information. \\ 
  \hline 
  \verb#FINER# & & & A fairly detailed tracing message.\\
  \hline 
  \verb#FINEST# & \verb#TRACE# & \verb#TRACE# & A fine-grained debug message, typically capturing the flow through the application. A highly detailed tracing message. \\
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{LogLevels.tbl}
In addition, they also know the ‘levels’ \verb#ALL# (log everything) and \verb#OFF# (log nothing), but you cannot check for these.

A lower level includes all the higher levels, too. So when a logger is configured for the log level \verb#INFO#, \lstinline|m_Logger.isLoggable()| will return \lstinline|true| for \verb#INFO#, \verb#WARNING# (or \verb#WARN#), \verb#SEVERE#, \verb#ERROR# and \verb#FATAL#, but not for \verb#DEBUG# or \verb#FINER#.

JDK~Logging and Log4j allow both to define additional log levels. Basically, this is also possible for SLF4J, but without knowlegde about the implementation that is really used for logging, it is quite difficult to determine how these new log levels in SLF4J are mapped to those of the effective logging framework.

\subsubsection{How to log}\label{sec:HowToLog}
This chapter discusses how to emit log messages, but also when you should log something, and what you should log.

\paragraph{Errors} First, you should log error conditions at some point in the program flow. Usually this means that you will log an exception. And you will log an exception only when you do not further delegate the handling of that exception. For tools and standalone applications, this means that you will log an exception latest in the \lstinline|main()| method.

We said already that a function library will not log at all. For a feature library, an extension and server-based application, you should log when the control flow is about to leave the realm of your component and you do not know how the host code will handle the exception.

You should also log (uncaught) exceptions in threads that your code creates; this was already discussed in chapter \tqfullvref{sec:ExceptionHandlingInThreads}.

As a rule of thumb, you log an exception at the latest possible occasion.

The log message should contain all information that you have a this point; this is at least the exception itself with its message and stacktrace. But perhaps you know additional things, for example what your code attempted when the exception was thrown, that name of resources that should be tried to access, the user name, the access rights and many other things – as long as these are not sensible data! So you should never add a password to a log message. And even the user name is already in a gray area.

Obviously, the log levels \verb#FATAL#, \verb#SEVERE# and \verb#ERROR# are meant for these messages.

The other log levels are not meant for reporting \textit{current} error conditions.

\paragraph{Warnings} The description for the log levels \verb#WARNING# and \verb#WARN# says that these indicate “an event that might possibly lead to an error” somewhen in the future.

Such an event could be the repeatingly failed login attempt of a user, as that could be the indication for a hacker attack. Most probably, you should not log the first failed attempt, perhaps not even the second or third (at least not as a warning), but consecutive attempts from the same devide and/or with the same user name should be logged. And obviously, the respective log message must contain all the necessary data that can be used to repel that attack. Whether the used passwords should be added to the log messages can be discussed.

In the same way obvious, you have to implement the necessary infrastructure to collect the data for all failed (and successful) logins, and you do this only to be able to log the respective warning.\footnote{Although you can collect this data also for general monitoring if your application lives in an environment where this is provided. Or you make it available through JMX – see chapter \tqvref{sec:UtilisingJMX}.} This means that you can switch it off when the log level is disabled.

In the same way, you should log attempts of unauthorised access by authenticated users.

Another reason to log a warning would be when you handle an error condition by repeating an operation or by performing an alternative operation. Although the current problem is solved for now, it is worth to keep track of it in the logs.

Then you should emit a warning to the logs when a resource gets short; even when the application recovers from that, it should be tracked.

If you run out of a particular resource, this would be an error condition, no longer a warning condition.

Obviously, this is not a complete list.

\paragraph{Info} You \textit{may} also log other important events that are clearly no error condition nor a warning. The log level for this kind of log entries is \verb#INFO#. You should assume that this is the default log level for each new logger, meaning that messages with the log levels \verb#INFO#, \verb#WARNING#/\verb#WARN# and \verb#FATAL#/\verb#ERROR#/\verb#SEVERE# are always written to the log file.

This may be the successfully established connection with an external system, the start and the termination of a long running background process, the creation of a new user and alike.

It is also a good idea to log the system configuration on startup.

You should not log (at least not with a log level of \verb#INFO#) the successful termination of common operations.\footnote{The kind of application that you create may request an audit log of some kind, but this is not covered by \textit{logging}. Instead we talk about \textit{journalling} here.}

In general, you should avoid to log the “happy path” in your code – at least, you should not do this with the log level \verb#INFO#.

\paragraph{Debug and Trace} A very basic tecnic for the debugging of a program is to add statements to the code that prints the current state to the console.

Logging with the log levels \verb#DEBUG#, \verb#TRACE#, \verb#FINE#, \verb#FINER#, and \verb#FINEST# is basically the same, just with the difference that you do not emit to a console, but to the log file.

There are some recommendations to log the entry and exit for each method, together with the arguments and the return value. In JDK~Logging, the class \lstinline|java.util.logging.Logger| does even have a set of specialised methods to support this approach (\lstinline|Logger::entering| and \lstinline|Logger::exiting|) that emit messages with the log level \verb#FINER#. That will look like this:
\begin{lstlisting}
public final class myClass
{
    private static final String CLASS_NAME = myClass.class.getName();
    private static final Logger m_Logger = getLogger( CLASS_NAME );
    
    public final String myMethod( final String value, final boolean flag )
    {
        final var METHOD_NAME = "myMethod";
        m_Logger.entering( CLASS_NAME, METHOD_NAME, value, Boolean.valueOf( flag ) );
        
        //---* Does some work here … *-------------------------------
        …
    
        //---* Done *------------------------------------------------
        m_Logger.exiting( CLASS_NAME, METHOD_NAME, retValue );
        return retValue;
    }   //  myMethod()
}
//  class myClass
\end{lstlisting}
Similar methods are missing in the other logging frameworks, for a reason:
\begin{itemize}
\item{First, the kind of information provided by this kind of logging is rarely useful.}
\item{If really each and every method is instrumented in that way, the log file will be flooded with messages when the general log level is set to \verb#FINER# or \verb#FINEST#, making it very difficult to find the information you really need.}
\item{It requires a real lot amount of unnecessary code to write.}
\item{Neither the name of the class nor that of the method will be detected automatically; instead, these values have to be provided as a constant.That makes some refactorings quite challenging~…}
\end{itemize}

As a result, I do not recommend to use this approach. In fact, you should think twice before you add log statement for \verb#DEBUG# and \verb#TRACE# proactively.

Of course, there are scenarios that are well known to cause issues during runtime quite often and therefore \verb#DEBUG# logging should be added for them. One good sample is the processing of emails, others are REST and SOAP communications.

But in general, you should never add \verb#TRACE# logging \textit{proactively}, and \verb#DEBUG# logging only in special cases.

On the other hand, you should never remove \verb#DEBUG# and \verb#TRACE# logging that you added during a bug hunt; it may get useful again if a regression tests fails. This also means that the \verb#DEBUG# and \verb#TRACE# log messages should be very verbose so that you can identify them even years later.
\begin{lstlisting}
public final String myMethod( final String value, final boolean flag )
{
    // DISCOURAGED!!
    m_Logger.trace( value );
    
    // RECOMMENDED
    m_Logger.trace( "BUGHUNT_2022-12-14 - entering myMethod()|value = '{}', flag = {}", value, flag );
    
    final var buffer = retrieveData( value, flag );
    
    // DISCOURAGED
    m_Logger.debug( buffer );
    
    // RECOMMENDED
    if( m_Logger.isDebugEnabled )
    {
        m_Logger.debug( "BUGHUNT_2022-12-14 - myMethod() called retrieveData()|value = '{}', flag = {}", value, flag );
        if( isNull( buffer )
        {
            m_Logger.debug( "BUGHUNT_2022-12-14 - retrieveData() returned null!" );
        }
        else
        {
            m_Logger.debug( "BUGHUNT_2022-12-14 - retrieveData() returned '{}'", buffer );
        }
    }
    
    final var retValue = process( buffer );
    
    //---* Done *----------------------------------------------------
    // DISCOURAGED
    m_Logger.debug( retValue );
    
    // RECOMMENDED
    m_Logger.trace( "BUGHUNT_2022-12-14 - exting myMethod()|retValue = '{}'", retValue );
    
    return retValue;
}   //  myMethod()
\end{lstlisting}

In chapter \tqref{sec:GeneralExceptionHandling} I said that it is usually not a good idea to log an exception and to rethrow or to wrap it afterwards. But there is on exception on this rule: sometimes you want to know about an exception that will be handled later and will be not logged then. Or you have some additional information at the current code location that you cannot add to the wrapper exception (perhaps because of its size). In this case, you can log that exception for debugging (the sample uses Log4j/SLF4J): 
\begin{lstlisting}
public final void myMethod() throw IOException
{
    …
    try
    {
        …
    }
    catch( final IOException e )
    {
        //---* Log and rethrow *-------------------------------------
        m_Logger.catching( DEBUG, e );
        throw e;
    }
    …
    try
    {
        …
    }
    catch( final IllegalStateException e )
    {
        //---* Log and wrap *----------------------------------------
        if( m_Logger.isDebugEnabled() )
        {
            final var message = composeIllegalStateContextMessage();
            m_Logger.debug( message, e );
        }    
        throw new ApplicationError( "Already in use", e );
    }
    …
}   // myMethod()
\end{lstlisting}

Here you also accept that the same exception might be logged twice.

\paragraph{Configuration} I have to confess that I never understood the purpose of the log level \verb#CONFIG# for the JDK~Logging. The description says “A message level for static configuration messages”. So you should use it to log the configuration parameters of your program – things like the current IP address, but also the system properties, or at least the command line parameters.

Of course, these could be relevant information for debugging issues, and it would make sense to log them with each restart of your program.

But \verb#CONFIG# has a lower priority than \verb#INFO# – this means that when you activate \verb#CONFIG#, you have also activated \verb#INFO# for that logger. This is probably not wanted.

Therefore most people uses a dedicated logger\footnote{refer to chapter \tqfullvref{sec:NamingOfLoggers}.} to log the configuration settings – but this makes the log level \verb#CONFIG# completely obsolete.

My recommendation would be to completely ignore the log level \verb#CONFIG# and to use a dedicated logger with log level \verb#INFO# instead. If you are using another logging framework than JDK~Logging, you don't have another choice either.

\subsubsection{Naming of Loggers}\label{sec:NamingOfLoggers}
In all samples we have seen so far in this chapter, the logger was given the fully qualified name of the class it lives in:
\begin{lstlisting}
public final class MyClass
{
       /*------------------------*\
    ===** Static Initialisations **==================================
       \*------------------------*/
    /**
     *  The logger that is used by this class.
     */
    private static final Logger m_Logger = getLogger( MyClass.class.getName() );
    
    // For Log4j and SLF4J, this also works:
    private static final Logger m_Logger = getLogger( MyClass.class );
}
//  class MyClass
\end{lstlisting}
This make sense, as there is a in fact a hierarchy for the loggers (I will come back to that in chapter \ref{sec:LoggerConfiguration} about the configuration of loggers).

Assume \lstinline|com.foo.application.internal.MyClass| is the fully qualified name of your class; then this is also the name of the logger that is configured for that class.

If you have not made any other settings\footnote{Like \lstinline|m_Logger.setParent()|~…}, you can change the log level for the logger like this:
\begin{lstlisting}[numbers=left]
getLogger( "com" ).setLevel( newLevel );
getLogger( "com.foo" ).setLevel( newLevel );
getLogger( "com.foo.application" ).setLevel( newLevel );
getLogger( MyClass.class.getPackage().getName() ).setLevel( newLevel );
getLogger( "com.foo.application.internal" ).setLevel( newLevel );
m_Logger.setLevel( newLevel );
getLogger( MyClass.class.getName() ).setLevel( newLevel );
\end{lstlisting}

The lines~4 and 5 as well as the lines~6 and 7 are effectivly the same, and in all cases, the log level for the logger is set to the value of \lstinline|newLevel|. This works first because each call to \lstinline|Logger::getLogger| (for JDK~Logging), \lstinline|LogManager::getLogger| (for Log4j), or \lstinline|LoggerFactory::getLogger| (for SLF4J) with the same argument will always return the \textit{same} logger instance:
\begin{lstlisting}
if( MyClass.class.getName()
    .equals( "com.foo.application.internal.MyClass" ) )
{
    // Always true
    getLogger( MyClass.class.getName() ) == 
        getLogger( "com.foo.application.internal.MyClass" );
}
\end{lstlisting}

Next, the dot (‘.’) indicates a hierarchy: the logger with the name \verb#com# is the parent of all loggers whose name starts with \verb#com.# (like \verb#com.foo# for the sample), and the logger with the name \verb#com.foo# is the parent of all loggers with names starting with \verb#com.foo.# and so on.

Now if a configuration value is not explicitly set by a logger itself, it will pull this setting from the logger that is set as its parent.

If the logger \verb#com.foo.application.internal.MyClass# is only logger that our program creates explicitly, a seven commands from the sample above are equivalent. Otherwise, those in the lines~1 to 5 may have the side effect to set the log level for these other loggers, too. This is exactly what want to achieve in the logger configuration that makes use of this relationship.

Please keep in mind that, once created, you cannot get rid of a logger instance. It will live until the current JVM is shut down. But in the sample above, no new logger will be created; all the loggers in the hierarchy, those with the names \verb#com.foo.application.internal#, \verb#com.foo.application#, \verb#com.foo# and \verb#com# were created implicitely already when creating the logger for the class name. It also means that there is nothing like a temporary logger!

There is no special requirement for the name of a logger. This means that “\verb#logger#”, “\verb#my.logger#”, “\verb#1.2.3.4.5.6.7.8#” or “\verb#Fritz#” are all valid logger names.

Using the fully qualified class name for the main loggers makes perfect sense, as you want to need a predictable naming scheme for the configuration (the log level is not the only configuration parameter to set).

But when you are on a bug hunt and add additional log statements to emit \verb#DEBUG# or \verb#TRACE# messages, this usually affects more then one class. If you use the class logger for the debug or trace logging, you always have to configure multiple loggers. That's not only inconvenient, but also error prone.

Same when you want to provide a debugging facility for a transaction; usually this will also span multiple classes.

So instead of using multiple class loggers, you should consider to introduce dedicated loggers that are reference in multiple classes – all classes that are involved in the respective operation:
\begin{lstlisting}
/**
 *  The logger for this class.
 */
private static final Logger m_Logger = getLogger( MyClass.class.getName() ); 

/**
 *  The loggers for the database transactions.
 */
private static final Lazy<Logger> m_InsertLogger = Lazy.use( () -> getLogger( "CRUD.Insert" ) );
private static final Lazy<Logger> m_SelectLogger = Lazy.use( () -> getLogger( "CRUD.Select" ) );
private static final Lazy<Logger> m_UpdateLogger = Lazy.use( () -> getLogger( "CRUD.Update" ) );
private static final Lazy<Logger> m_DeleteLogger = Lazy.use( () -> getLogger( "CRUD.Delete" ) );

/**
 *  The logger for the bug hunt started on 2022-12-14.
 */
private static final Lazy<Logger> m_BugHunt_2022-12-14_Logger = Lazy.use( () -> getLogger( "BugHunt.2022-12-14" ) );

public final void myMethod( final Operation operation, final Record data ) throws SQLException
{
    m_BugHunt_2022-12-14_Logger.debug( "entered MyClass.myMethod|operation = '{}'", operation );
    try( final var connection = obtainConnection() )
    {
        OperationSwitch: switch( requireNonNullArgument( operation, "operation" ) )
        {
            case INSERT:
                m_InsertLogger.get().debug( "Performing an Insert" );
                …
                break OperationSwitch;
                
            case …
        }   //  OperationSwitch:
        m_BugHunt_2022-12-14_Logger.debug( "MyClass.myMethod – Operation successfully termninated|operation = '{}'", operation );       
    }
    catch( final PoolExhaustedException e )
    {
        m_Logger.warn( "Connection Pool exhausted; operation postponed", e );
        m_BugHunt_2022-12-14_Logger.debug( "MyClass.myMethod – Operation postponed|operation = '{}'", operation );       
        postponeOperation( operation, data ); 
    }    
    catch( final SQLException e )
    {
        m_BugHunt_2022-12-14_Logger.debug( () -> format( "MyClass.myMethod – Operation aborted|operation = '%s'", operation ), e );
        throw e;
    }
}   //  myMethod() 
\end{lstlisting}

An example for the class \lstinline|Lazy| is given in chapter \tqvref{sec:Lazy}.

\subsubsection{Logger Configuration}\label{sec:LoggerConfiguration}
Both, JDK~Logging and Log4j are best configured through configuration files.\footnote{SLF4J does not have a configuration of its own, as it is just a facade to a ‘real’ logging framework, like JDK~Logging or Log4j~…} These configuration files should be provided with the source code for your product.

But both frameworks allow also a programmatical configuration, at least for the log level. This should be used to add a feature to change the log levels during runtime, to switch debugging on and off with requiring a restart of the application. This makes definitely sense for server-based applications, to some extent for feature libraries, and of course for long running standalone applications.

JDK~Logging and Log4j will also support JMX for changes to the log levels\autocite{ORACLE_DOC_LOGGINGMXBEAN_INTERFACE, APACHE_LOG4J:JMX}; this can be used with long running tools to enable or disable some debug output during runtime.

\paragraph{JDK~Logging} The basic information about the configuration of JDK~Logging are given in \autocite{ORACLE_DOC_LOGGING_OVERVIEW:ConfigurationFile, ORACLE_DOC_LOGGING_OVERVIEW:DefaultConfiguration} and some important details can be found at \autocite{ORACLE_DOC_LOGMANAGER_CLASS}.

Usually JDK~Logging will be configured through a properties file; the default path for that file is \verb#${JAVA_HOME}/conf/logging.properties#, and out-of-the-box, it looks like this:
\begin{lstlisting}[language=,numbers=left,caption={Default JDK~Logging Configuration}]
############################################################
#  	Default Logging Configuration File
#
# You can use a different file by specifying a filename
# with the java.util.logging.config.file system property.  
# For example java -Djava.util.logging.config.file=myfile
############################################################

############################################################
#  	Global properties
############################################################

# "handlers" specifies a comma separated list of log Handler 
# classes.  These handlers will be installed during VM startup.
# Note that these classes must be on the system classpath.
# By default we only configure a ConsoleHandler, which will only
# show messages at the INFO and above levels.
handlers= java.util.logging.ConsoleHandler

# To also add the FileHandler, use the following line instead.
#handlers= java.util.logging.FileHandler, java.util.logging.ConsoleHandler

# Default global logging level.
# This specifies which kinds of events are logged across
# all loggers.  For any given facility this global level
# can be overriden by a facility specific level
# Note that the ConsoleHandler also has a separate level
# setting to limit messages printed to the console.
.level= INFO

############################################################
# Handler specific properties.
# Describes specific configuration info for Handlers.
############################################################

# default file output is in user's home directory.
java.util.logging.FileHandler.pattern = %h/java%u.log
java.util.logging.FileHandler.limit = 50000
java.util.logging.FileHandler.count = 1
# Default number of locks FileHandler can obtain synchronously.
# This specifies maximum number of attempts to obtain lock file by 
# FileHandler implemented by incrementing the unique field %u as per 
# FileHandler API documentation.
java.util.logging.FileHandler.maxLocks = 100
java.util.logging.FileHandler.formatter = java.util.logging.XMLFormatter

# Limit the message that are printed on the console to INFO and above.
java.util.logging.ConsoleHandler.level = INFO
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter

# Example to customize the SimpleFormatter output format 
# to print one-line log message like this:
#     <level>: <log message> [<date/time>]
#
# java.util.logging.SimpleFormatter.format=%4$s: %5$s [%1$tc]%n

############################################################
# Facility specific properties.
# Provides extra control for each logger.
############################################################

# For example, set the com.xyz.foo logger to only log SEVERE
# messages:
com.xyz.foo.level = SEVERE
\end{lstlisting}

To provide your own configuration, you can modify this file (not recommended) or you create your own configuration file that you announce through the system property \verb#java.util.logging.config.file#.

A sample configuration file for the sample provided above may look like this:
\begin{lstlisting}[language=,numbers=left,caption={Sample JDK~Logging Configuration}]
handlers=java.util.logging.FileHandler
.level=SEVERE

java.util.logging.FileHandler.pattern=%h/target/Sample.log
java.util.logging.FileHandler.level=ALL
java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter

BugHunt_2022-12-14_Logger.level=FINEST
CRUD.level=OFF
\end{lstlisting}

It defines a configuration with two loggers, “\verb#BugHunt_2022-12-14_Logger#" and “\verb#CRUD#". The default log level is set to \verb#SEVERE#, while the logger  \verb#CRUD# is switched off, together with all it is child loggers, and the log level for \verb#BugHunt_2022-12-14_Logger# is set to \verb#FINEST#.

A handler determines the destination for the log messages, and here we selected the file handler. A handler has its own log level, and you define the formatter that determines how the log messages will look like when written by the respective handler. Finally, ‘pattern’ specifies the name of the logfile.

This is more or less the simplest configuration you can make. Refer to \autocite{ORACLE_DOC_LOGGING_OVERVIEW, ORACLE_DOC_LOGGING_PACKAGE, ORACLE_DOC_LOGGING_PACKAGE} and the JavaDoc for the various handlers and formatters for more details.

\paragraph{Log4j} The configuration for Log4j is described in \autocite{APACHE_LOG4J:Configuration}. It allows four different formats for the configuration file (XML, JSON, YAML, or properties format), but the XML format is still the most common one.

Log4j has the ability to automatically configure itself during initialization. 
\begin{enumerate}
\item{When Log4j starts it will inspect the “\verb#log4j2.configurationFile#” system property and, if set, will attempt to load the configuration using a \lstinline|ConfigurationFactory| that matches the file extension.

Note that this is not restricted to a location on the local file system and may contain a URL.}
\item{If no system property is set the “properties \lstinline|ConfigurationFactory|” will look for \verb#log4j2-test.properties# in the classpath.}
\item{If no such file is found the “YAML \lstinline|ConfigurationFactory|” will look for \verb#log4j2-test.yaml# or \verb#log4j2-test.yml# in the classpath.}
\item{If no such file is found the “JSON \lstinline|ConfigurationFactory|” will look for \verb#log4j2-test.json# or \verb#log4j2-test.jsn# in the classpath.}
\item{If no such file is found the “XML \lstinline|ConfigurationFactory|” will look for \verb#log4j2-test.xml# in the classpath.}
\item{If a test file cannot be located the “properties \lstinline|ConfigurationFactory|” will look for \verb#log4j2.properties# on the classpath.}
\item{If a properties file cannot be located the “YAML \lstinline|ConfigurationFactory|” will look for \verb#log4j2.yaml# or \verb#log4j2.yml# on the classpath.}
\item{If a YAML file cannot be located the “JSON \lstinline|ConfigurationFactory|” will look for \verb#log4j2.json# or \verb#log4j2.jsn# on the classpath.}
\item{If a JSON file cannot be located the “XML \lstinline|ConfigurationFactory|” will try to locate \verb#log4j2.xml# on the classpath.}
\item{If no configuration file could be located the \lstinline|DefaultConfiguration|” will be used. This will cause logging output to go to the console.}
\end{enumerate}

A \verb#log4j2.xml# file may look like that one below:
\begin{lstlisting}[language=XML,numbers=left,caption={Sample Log4j Configuration}]
<?xml version="1.0"
      encoding="UTF-8"?>
<Configuration name="SampleConfiguration" 
               status="debug" 
               strict="true">
  <Properties>
    <Property name="filename">target/Sample.log</Property>
  </Properties>
 
  <Appenders>
    <Appender type="File" 
              name="File" 
              fileName="${filename}">
      <Layout type="PatternLayout">
        <Pattern>%d %p %C{1.} [%t] %m%n</Pattern>
      </Layout>
    </Appender>
  </Appenders>
 
  <Loggers>
    <Logger name="BugHunt_2022-12-14_Logger" 
            level="trace" 
            additivity="false">
      <AppenderRef ref="File"/>
    </Logger>
 
    <Logger name="CRUD" 
            level="off" 
            additivity="false">
      <AppenderRef ref="File"/>
    </Logger>
 
    <Root level="error">
      <AppenderRef ref="File"/>
    </Root>
  </Loggers>
</Configuration>
\end{lstlisting}

It defines a configuration with the name “\verb#Sample#”, and that has one appender, named “\verb#File#” and two named loggers, “\verb#CRUD#" and that infamous “\verb#BugHunt_2022-12-14_Logger#", together with the default configuration (with the name “\verb#Root#”).

An appender is basically the definition for the target of the log messages and how the messages will look like (the ‘layout’); you can define as many appenders as you want. The name of the defined loggers match with those we used in the program code, and you will set the level and the destination (the ‘appender reference’) for it.

But the configuration is much more powerful than that what I will show here. For more details, see the documentation in \autocite{APACHE_LOG4J:Configuration}.

\subsubsection{Side Effects of Logging}
Logging may not have side-effects!

This means that your code have to behave always in the same way, no matter which log levels are active for any of the loggers.

Although this is literally impossible (a call to the \lstinline|log()| method will consume more or less CPU cycles, depending on whether the respective log level is active or not), you should take care to reduce the impact as much as possible.

On the other side, an inactive log level also should not have any impact.

The good thing is that this problem usually shows up only for \verb#DEBUG# and \verb#TRACE#, rarely for \verb#INFO#.

Some samples:
\begin{lstlisting}[numbers=left]
public final void myMethod()
{
    // AVOID!
    final var logMessage = composeLogMessage();
    m_Logger.debug( logMessage );
    
    // BETTER
    if( m_Logger.isDebugEnabled() )
    {
        final var logMessage = composeLogMessage();
        m_Logger.debug( logMessage );
    }
    
    // RECOMMENDED
    m_Logger.debug( this::composeLogMessage );
}   //  myMethod()
\end{lstlisting}

The method \lstinline|composeLogMessage()| is just a placeholder here, but to keep the code readable, it is sometimes really a good idea to place the generation of the logging output into a dedicated method.

\begin{lstlisting}[numbers=left]
public final void myMethod()
{
    // AVOID!
    final var bufferForLogOutput = new StringBuilder();
    while( input.hasMore() )
    {
        final var line = processInput( input.next() );
        output.println( line );
        bufferForLogOutput.append( line )
            .append( '\n' );
    }
    m_Logger.debug( "Output: {}", bufferForLogOutput.toString() );
    
    // A LITTLE BIT BETTER
    StringBuilder bufferForLogOutput = null;
    if( m_Logger.isLoggable( DEBUG ) ) bufferForLogOutput = new StringBuilder();
    while( input.hasMore() )
    {
        final var line = processInput( input.next() );
        output.println( line );
        if( nonNull( bufferForLogOutput ) )
        {
        	bufferForLogOutput.append( line )
            	.append( '\n' );
        }
    }
    m_Logger.debug( "Output: {}", bufferForLogOutput.toString() );
    
    // RECOMMNENDED
    while( input.hasMore() )
    {
        final var line = processInput( input.next() );
        output.println( line );
        m_Logger.debug( "Output: {}", line );
    }
}   //  myMethod()
\end{lstlisting}

The variants starting in line~3 and line~14 have both the risk that they may cause an \lstinline|OutOfMemoryError| when the output is larger. But it is in general a bad idea to have a variable that exists only for debugging purposes.

On the other hand, the variant starting on line~29 may pollute the logs with a high number of messages. But for debugging purposes, this should be acceptable.

Something that I have seen in real life code, another variant of the pattern above:
\begin{lstlisting}[numbers=left]
public final void myMethod() throws IOException
{
    // AVOID! BY ALL MEANS!!
    PrintStream logOutput = null;
    if( m_Logger.isLoggable( DEBUG ) )
    {
    	final var logOutputName = generateFileName();
    	logOutput = new PrintStream( new FileOutputStream( logOutputName ) );
    	m_Logger.debug( "Writing logOutput File {}", logOutputName );
    };
    while( input.hasMore() )
    {
        final var line = processInput( input.next() );
        output.println( line );
        if( nonNull( logOutput ) )
        {
        	bufferForLogOutput.append( line )
            	.append( '\n' );
        }
    }
    if( nonNull( logOutput ) logOutput.close();
}   //  myMethod()
\end{lstlisting}

In this case, enabling \verb#DEBUG# for the logger can cause exceptions that will never occur in normal operation.

One more?
\begin{lstlisting}[numbers=left]
public final Data myMethod() throws IOException
{
    // AVOID! BY ALL MEANS!!
    final Data retValue;
    
    if( m_Logger.isTraceEnabled() )
    {
        retValue = composeOutputDataWithTrace()
    }
    else
    {
        retValue = composeOutputData();
    }
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  myMethod()
\end{lstlisting}
Do I have to comment this?

As a conclusion, you should avoid side effects of (debug) logging as good as possible. The impact on time can be reduced if the operations done for logging are kept short. And instead of collecting large data chunks, log each small chunk separately.

\section{Checking Method Parameters and Return Values}\label{sec:CheckingMethodParametersAndReturnValues}
A \lstinline|NullPointerException| that is thrown by your code indicates a serious bug: it reveals that either a method argument or a return value was not properly checked before it was further used.

Your code should never throw a \lstinline|NullPointerException|!\footnote{And, of course, it should also never catch it. A \lstinline|NullPointerException| should be treated like an \lstinline|Error|.} Nevertheless, values can still be \lstinline|null|, for various reasons, and if this is indicating an error condition, this has to be signalled.

Consequently, you need to check the arguments for each and every method and constructor. But as these checks are not for free, it could be acceptable to omit these checks for \lstinline|private| methods and constructors, when the caller guarantees that the arguments are valid. But even then you should consider to check the arguments with assertions\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert, ORACLE_DOC_ASSERTIONS}, at least for methods (for constructors that calls to \lstinline|this()| or \lstinline|super()|, this has to be the very first statement; no \lstinline|assert| statement can be placed before it).

\begin{lstlisting}
public final class MyClass
{
    private MyClass( final String value )
    {
        assert nonNull( value ) : "value is null";
        
        m_Value = value;
    }   //  MyClass()
    
    private final void myMethod( final String value )
    {
        assert nonNull( value ) : "value is null";
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
    
    public static final MyClass myFactory( final String value1, final String value2 )
    {
    	final var retValue = nonNull( value1 ) ? new MyClass( value1 ) : null;
    	if( nonNull( retValue ) && nonNull( value2 ) ) retValue.myMethod( value2 );
    }   //  myFactory()
}
//  class MyClass
\end{lstlisting}
As said in the Java Language Specification\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert}:
\begin{quotation}
“[Because they can be disabled], assertions should not be used for argument checking in \lstinline|public| methods. Argument checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled.

A secondary problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception […]. An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate. It is intended that \lstinline|AssertionError| never be caught, but it is possible to do so, thus the rules for \lstinline|try| statements should treat assertions appearing in a \lstinline|try| block similarly to the current treatment of throw statements.”
\end{quotation}

You can also delegate the argument check to another method:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
    
    public static final MyClass myFactory( final String value1, final String value2 )
    {
    	//---* Null check is done by constructor *----------------------
    	final var retValue = new MyClass( value1 );
    	
    	//---* Null check is done by myMethod() *-----------------------
    	retValue.myMethod( value2 );
    }   //  myFactory()
}
//  class MyClass
\end{lstlisting}

In case the problematic \lstinline|null| value is an argument to a method or to a constructor, you should throw an \lstinline|java.lang.IllegalArgumentException|\autocite{ORACLE_DOC_ILLEGALARGUMENTEXCEPTION_CLASS}:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

As this check is quite common, I suggest to create a custom exception for this purpose: \lstinline|NullArgumentException|, extending \lstinline|java.lang.IllegalArgumentException|; chapter \tqvref{sec:IllegalArgumentExceptions} provides sample implementations for this and the other exceptions discussed here. With that the sample looks like this:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

You may have noticed that I always use \lstinline|isNull()|\autocite{ORACLE_DOC_OBJECTS:isNull} and \lstinline|nonNull()|\autocite{ORACLE_DOC_OBJECTS:nonNull}\footnote{Both methods are defined in the class \lstinline|java.util.Objects|\autocite{ORACLE_DOC_OBJECTS_CLASS} that will be discussed in more detail later in this chapter.} instead of \lstinline|… == null| and \lstinline|… != null|. I think that the method calls are easier to read than the \verb#==# and \verb#!0# operators.

Foreign code will still throw a \lstinline|NullPointerException| if called with \lstinline|null|, but we are not allowed to catch that …

This means that we have to check the values before we call that foreign code. That's easy for a method, we already check all arguments. But what if we have to call the constructor of a super class?
\begin{lstlisting}
public final class MyClass extends ForeignClass
{
    public MyClass( final String value )
    {
        // WILL NOT COMPILE!!
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        super( value );
    }   //  MyClass()
}
//  class MyClass
\end{lstlisting}

The solution is to have a method that is doing the \lstinline|null| and throwing the \lstinline|NullArgumentException| if that fails. Then our sample may look like this:

\begin{lstlisting}
public final class MyClass extends ForeignClass
{
    public MyClass( final String value, final Data data )
    {
        super( requireNonNullArgument( data, "data" ) );
        
        m_Value = requireNonNullArgument( value, "value" );
    }   //  MyClass()
    
    public final void myMethod( final String value, final Data data )
    {
        if( requireNonNullArgument( value, "value" ).equals( m_Value ) && requireNonNullArgument( data, "data" ).equals( getData() ) )
        {
            …
        }
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

The method \lstinline|requireNonNullArgument()| looks like this\footnote{This one and the other methods in this chapter are implemented in the class \lstinline|org.tquadrat.foundation.lang.Objects|\autocite{TQUADRAT_ORG_FOUNDATION_OBJECTS} that also provides reimplementations of the methods from \lstinline|java.util.Objects|.}:
\begin{lstlisting}[numbers=left,caption={requireNonNullArgument()}]
/**
 *  Checks if the given argument {@code a} is {@code null} and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}.
 *
 *  @param  <T> The type of the argument to check.
 *  @param  a   The argument to check.
 *  @param  name    The name of the argument; this is used for the 
 *      error message.
 *  @return The argument if it is not {@code null}.
 *  @throws NullArgumentException   {@code a} is {@code null}.
 */
public static final <T> T requireNonNullArgument( final T a, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );
    if( isNull( a ) ) throw new NullArgumentException( name );

    //---* Done *----------------------------------------------------
    return a;
}   //  requireNonNullArgument()
\end{lstlisting}

In general, it is a good idea to check the arguments for a method or a constructor is as soon as possible, but is needs to be checked latest before it is used in some way.

We can check an argument for being empty, and Strings can be even tested for being blank, in the same way as for the null check:
\begin{lstlisting}[numbers=left,caption={requireNotEmptyArgument()}]
/**
 *  <p>{@summary Checks if the given argument {@code arg} is 
 *  {@code null} or empty and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}, or an
 *  {@link EmptyArgumentException}
 *  if it is empty.}</p>
 *  <p>Strings, arrays, instances of
 *  {@link java.util.Collection} and
 *  {@link java.util.Map}
 *  as well as instances of
 *  {@link java.lang.StringBuilder},
 *  {@link java.lang.StringBuffer},
 *  and
 *  {@link java.lang.CharSequence}
 *  will be checked on being empty.</p>
 *  <p>For an instance of
 *  {@link java.util.Optional},
 *  the presence of a value is checked in order to determine whether
 *  the
 *  {@link Optional} is empty or not.</p>
 *  <p>Because the interface
 *  {@link java.util.Enumeration}
 *  does not provide an API for the check on emptiness
 *  ({@link java.util.Enumeration#hasMoreElements() hasMoreElements()}
 *  will return {@code false} after all elements have been taken from
 *  the {@code Enumeration} instance), the result for arguments of
 *  this type has to be taken with caution.</p>
 *  <p>For instances of
 *  {@link java.util.stream.Stream},
 *  this method will only check for {@code null} (like
 *  {@link #requireNonNullArgument(Object,String)}.
 *  This is because any operation on the stream itself would render 
 *  it unusable for later processing.</p>
 *  <p>In case the argument is of type
 *  {@link Optional},
 *  this method behaves different from
 *  {@link #requireNotEmptyArgument(Optional,String)};
 *  this one will return the {@code Optional} instance, while the
 *  other method will return the contents of the 
 *  {@code Optional}.</p>
 *  <p>This method will not work properly for instances of
 *  {@link java.util.StringJoiner}, because its method
 *  {@link java.util.StringJoiner#length() length()}
 *  will not return 0 when a prefix, suffix, or an
 *  &quot;{@linkplain java.util.StringJoiner#setEmptyValue(CharSequence) 
 *  empty value}&quot; was provided.</p>
 *
 *  @param  <T> The type of the argument to check.
 *  @param  arg The argument to check; may be {@code null}.
 *  @param  name    The name of the argument; this is used for the 
 *      error message.
 *  @return The argument if it is not {@code null} or empty.
 *  @throws NullArgumentException   {@code arg} is {@code null}.
 *  @throws EmptyArgumentException   {@code arg} is empty.
 */
public static final <T> T requireNotEmptyArgument( final T arg, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );

    switch( arg )
    {
        /*
         * When using guarding expressions, the code would not get
         * better to read and to understand, as the positive cases
         * will be handled all by the default case then.
         */
        case null -> throw new NullArgumentException( name );
        case CharSequence charSequence ->
        {
            if( charSequence.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Collection<?> collection ->
        {
            if( collection.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Map<?,?> map ->
        {
            if( map.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Enumeration<?> enumeration ->
        {
            /*
             * The funny thing with an Enumeration is that it could 
             * have been not empty in the beginning, but it may be 
             * empty (= having no more elements) now.
             * The good thing is that Enumeration.hasMoreElements() 
             * will not change the state of the Enumeration - at 
             * least it should not do so.
             */
            if( !enumeration.hasMoreElements() ) throw new EmptyArgumentException( name );
        }
        case Optional<?> optional ->
        {
            if( optional.isEmpty() ) throw new EmptyArgumentException( name );
        }
        default ->
        {
            if( arg.getClass().isArray() )
            {
                if( Array.getLength( arg ) == 0 ) throw new EmptyArgumentException( name );
            }
            else
            {
                /*
                 * Other data types are not further processed; in
                 * particular, instances of Stream cannot be checked 
                 * on being empty. This is because any operation on 
                 * the Stream itself will change its state and may 
                 * make the Stream unusable.
                 */
            }
        }
    }

    //---* Done *----------------------------------------------------------
    return arg;
}   //  requireNotEmptyArgument()
\end{lstlisting}

\begin{lstlisting}[numbers=left,caption={requireNotBlankArgument()}]
/**
 *  <p>{@summary Checks if the given String argument {@code arg} is
 *  {@code null}, empty or blank and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}, an
 *  {@link EmptyArgumentException}
 *  if it is empty, or a
 *  {@link BlankArgumentException}
 *  if it is blank.}</p>
 *
 *  @param  <T> The type of the argument to check.
 *  @param  arg The argument to check; may be {@code null}.
 *  @param  name    The name of the argument; this is used for the
 *      error message.
 *  @return The argument if it is not {@code null}, empty or blank.
 *  @throws NullArgumentException   {@code arg} is {@code null}.
 *  @throws EmptyArgumentException   {@code arg} is empty.
 *  @throws BlankArgumentException   {@code arg} is blank.
 *
 *  @see    String#isBlank()
 */
public static final <T extends CharSequence> T requireNotBlankArgument( final T arg, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );

    switch( arg )
    {
        case null -> throw new NullArgumentException( name );
        case String string ->
        {
            if( string.isEmpty() ) throw new EmptyArgumentException( name );
            if( string.isBlank() ) throw new BlankArgumentException( name );
        }
        case CharSequence charSequence ->
        {
            if( charSequence.isEmpty() ) throw new EmptyArgumentException( name );
            if( charSequence.toString().isBlank() ) throw new BlankArgumentException( name );
        }
    }

    //---* Done *----------------------------------------------------------
    return arg;
}   //  requireNotBlankArgument()
\end{lstlisting}

The classes \lstinline|java.util.Objects|\autocite{ORACLE_DOC_OBJECTS_CLASS} and \lstinline|org.tquadrat.foundation.lang.Objects|\autocite{TQUADRAT_ORG_FOUNDATION_OBJECTS} provide a bunch of additional methods that can help with the validation of arguments.

Beside the arguments to a method or constructor, you also have to check the values that are returned by a method call, at least that they are not \lstinline|null|. But don't be paranoid: if the specification of the called method clearly declares that the method will not return \lstinline|null|, you should trust it\footnote{Although you can still add an \lstinline|assert| statement to ensure that.}

The methods in your code should \textit{never} return \lstinline|null|, at least not those methods that are published as the API of your class.\footnote{Nevertheless, when you are implementing a (3\textsuperscript{rd} party) interface that requests a return value of \lstinline|null| under some conditions, you have to obey that requirements.} Instead, they should return an instance of \lstinline|java.util.Optional|\autocite{ORACLE_DOC_OPTIONAL_CLASS}.

Additionally, the classes \lstinline|java.util.OptionalInt|\autocite{ORACLE_DOC_OPTIONALINT_CLASS}, \lstinline|java.util.OptionalLong|\autocite{ORACLE_DOC_OPTIONALLONG_CLASS} and \lstinline|java.util.OptionalDouble|\autocite{ORACLE_DOC_OPTIONALDOUBLE_CLASS} can help you to avoid “magic numbers” as return values, indicating special results. And still no \lstinline|null|~…

\section{Extending Classes, Overriding Methods}\label{sec:ExtendingClassesOverridingMethods}
This chapter provides some hints for the design and implementation of classes and methods that should be/can be extended. This is basically relevant for libraries, but also for applications that should be customisable in some way and therefore providing an API.

\subsection{“final” for Classes and Methods}
Each non-\lstinline|private| method, that is not explicitly meant to be overridden by an extending class has to be \lstinline|final|. Each non-\lstinline|final| class is implicitly meant to be extended – even if it contains only \lstinline|final| methods.

Non-\lstinline|final| methods require a comment about when and how they can be overridden, and if the super implementation has to be called, and when. On how to write the comments for classes and methods, refer to the respective chapters \tqvref{sec:ClassComment} and \tqvref{sec:MethodComment}.

\lstinline|private| and \lstinline|static| methods are implicitly \lstinline|final|. Nevertheless, they will be marked as \lstinline|final|, too, although that is redundant.

\subsection{Non-“final” Classes}\label{sec:NonFinalClasses}
As already said above, each non-\lstinline|final| class is implicitly meant to be extended. This means, it has to be designed in a way that supports that extension, and it has to provide proper documentation on how to implement the extension and when.

Only when the class is \lstinline|sealed|\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:SealedClasses, ORACLE_DOC_LANGUAGE_SPECIFICATION:SealedInterfaces}, this is obsolete: for a \lstinline|sealed| class (and for a \lstinline|sealed| interface), all implementations has to be provided by you. This is discussed further in chapter \tqvref{sec:EncapsulationWithModules}.

Unfortunately it is difficult to provide a globally valid recipe for extensible classes. In general, such a class should provide some so called ‘mount points’ or ‘extension points’ where the behaviour could be changed or added. This could be an \lstinline|abstract| method, an empty, non-\lstinline|final| place holder method, or a non-\lstinline|final| method providing some default behaviour. Such a method should be marked with the annotation \lstinline|@Mountpoint|\footnote{Refer to chapter \tqvref{sec:MountPoint} for an implementation of the Annotation.} (if not \lstinline|abstract| or part of an interface), to indicate that you have not just forgotten to add the \lstinline|final| keyword.

An extensible class can also provide useful and/or convenience functionality as \lstinline|protected final| methods. 

Although \textit{it is not recommended}, an extensible class can even provide direct access to fields by declaring them \lstinline|protected| instead of \lstinline|private|.

\subsection{Non-“final” Methods}\label{sec:NonFinalMethods}
A method will be overridden to change the behaviour of an extended class, compared with its base class. The method either has already a behaviour, or it is empty, doing nothing\footnote{…~or it is \lstinline|abstract|, but that is another pattern.}.

In the latter case, it is very likely that this method was already added to design an extendable class.

In the other case, the new method's behaviour will completely replace that of the original one with new functionality. If this is not possible – meaning that some of the original method's functionality has to be kept, this needs to be described in the documentation comment for that method. Or, even better, you should change the design of your class to use the Template Method Pattern\autocite{Gamma:DesignPatterns}.

Assume your class has to implement the following process:
\begin{enumerate}
\item{Initialisation}
\item{Gathering data}
\item{Validate the input data}
\item{Filtering the input data}
\item{Processing the data}
\item{Formatting the output data}
\item{Cleanup and housekeeping}
\item{Writing the output}
\end{enumerate}

Your first, naïve implementation looks like this:
\begin{lstlisting}[numbers=left]
public class MyClass
{
    public String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final String inputData;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            inputData = readStream( inputFile );
        }
        
        //---* Validate and filter the data *------------------------
        final var filteredData = … // Do something with inputData
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = … // Do something with resultData
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}
Works! Job done! Until your project manager returns to you with the requirement that the input data should be taken alternatively from other source that just a file, that different filter schemes are possible, and that the output format has to be customisable. But the initialisation step, the validation and the housekeeping are fine~…

Ok, the method \lstinline|MyClass::process| is not final, you override it:

\begin{lstlisting}[numbers=left]
public class CustomClass extends MyClass
{
    public String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final String inputData;
        try( final var inputFile = new FileInputStream( new URL( "192.168.0.1" ).openStream() )
        {
            inputData = readStream( inputFile );
        }
        
        //---* Validate and filter the data *------------------------
        final var filteredData = … // Do something with inputData
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = … // Do something else with resultData
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class CustomClass
\end{lstlisting}

But obviously, this is not the solution … so you modify the original class:
\begin{lstlisting}[numbers=left]
public class MyClass // Second attempt
{
    /**
     *  Validate and filters the input data. Usually, no filtering should
     *  be required.
     *  An implementation of this method in a subclass needs to call this
     *  implementation in order to validate the data.
     *  
     *  @param  data    The raw input data.
     *  @param  context The process context.
     *  @return	The validated and filtered data.
     *  @throws IllegalArgumentException  The input data is invalid.
     */
    @MountPoint 
    protected String filterData( final String data, final ProcessContext context )
    {
        if( /* data is not valid */ ) throw new IllegalArgumentException();
        
        //---* Done *------------------------------------------------
        return data;
    }   //  filterData()
    
    /**
     *  Formats the output data.
     * 
     *  @param  data    The data to prepare for the output.
     *  @param  context The process context.
     *  @return	The formatted data.
     */
    @MountPoint
    protected String formatData( final String data, final ProcessContext context )
    {
        final var retValue = … // Do something with data
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  formatData()
    
    /**
     *  Obtains the input data from somewhere; the default 
     *  implementation reads it from the file {@code inputFileName}.
     *
     *  @return The input data.
     *  @throws IOException An I/O error occurred while gathering the 
     *      data.
     */
    @MountPoint
    protected String obtainInputData() throws IOException
    {
        final String retValue;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            retValue = readStream( inputFile );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  obtainInputData()
        
    public final String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final var inputData = obtainInputData();
        
        //---* Validate and filter the data *------------------------
        final var filteredData = filterData( inputData, context );
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = formatData( resultData, context );
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}

Looks good now! Tests were successful! Job done!

Your colleagues implemented some custom classes extending your class, and basically, all is fine. Just once in a blue moon, the programs using one of the custom classes crashes spectacularly.

When you look into the the source, you found this implementation for \lstinline|filterData()|
\begin{lstlisting}
protected final String filterData( final String data, final ProcessContext context )
{
    final var validData = super.filterData( data, context );
    
    final var retValue = … // Do some filtering on validData
        
    //---* Done *----------------------------------------------------
    return retValue;
}   //  filterData()
\end{lstlisting}

This was not what you meant! It should be, to ensure that \textit{after} filtering the data is valid:
\begin{lstlisting}
protected final String filterData( final String data, final ProcessContext context )
{
    final var filteredData = … // Do some filtering on data
    final var retValue = super.filterData( filteredData, context );
        
    //---* Done *----------------------------------------------------
    return retValue;
}   //  filterData()
\end{lstlisting}

But your colleagues says that they have to check the input data – and it seems that they are right! But the data has to be checked after the filtering again~…

So you modified your base class once more:
\begin{lstlisting}[numbers=left]
public class MyClass // Third attempt
{
    /**
     *  Filters the input data. This implementation does nothing.
     *  
     *  @param  data    The raw input data.
     *  @param  context The process context.
     *  @return	The filtered data.
     */
    @MountPoint 
    protected String filterData( final String data, final ProcessContext context )
    {
        /* Does nothing */
        
        //---* Done *------------------------------------------------
        return data;
    }   //  filterData()
    
    /**
     *  Formats the output data.
     * 
     *  @param  data    The data to prepare for the output.
     *  @param  context The process context.
     *  @return	The formatted data.
     */
    @MountPoint
    protected String formatData( final String data, final ProcessContext context )
    {
        final var retValue = … // Do something with data
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  formatData()
    
    /**
     *  Obtains the input data from somewhere; the default 
     *  implementation reads it from the file {@code inputFileName}.
     *
     *  @return The input data.
     *  @throws IOException An I/O error occurred while gathering the 
     *      data.
     */
    @MountPoint
    protected String obtainInputData() throws IOException
    {
        final String retValue;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            retValue = readStream( inputFile );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  obtainInputData()
        
    /**
     *  Validates the input data.
     *  
     *  @param  data    The input data.
     *  @param  context The process context.
     *  @throws IllegalArgumentException  The input data is invalid.
     */
    private final void validateData( final String data, final ProcessContext context )
    {
        if( /* data is not valid */ ) throw new IllegalArgumentException();
    }   //  validateData()
    
    public final String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final var inputData = obtainInputData();
        
        //---* Validate and filter the data *------------------------
        validateData( inputData );
        final var filteredData = filterData( inputData, context );
        if( !inputData.equals( filteredData ) ) validateData( filteredData );
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = formatData( resultData, context );
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}

Now \lstinline|filterData()| does only filter data, it is no longer responsible for the validation, too. And the default implementation of that method is now empty.

So you have basically the following options:
\begin{itemize}
\item{The method (and the base class) is \lstinline|abstract|; this forces that any instantiable implementation (any non-\lstinline|abstract| subclass) is required to implement that method.}
\item{The method does nothing (the method body is empty or contains only a return statement) and can be implemented to add functionality if needed/desired.}
\item{The method provides a default behaviour that can be \textit{completely} replaced in a subclass.}
\end{itemize}

You should avoid the \textit{requirement} to call the super implementation of the overriden method, by all means! But if you cannot avoid it, provide a detailed comment on how this has to be done!

That does not mean that an overriding method is not allowed to call the super implementation! Assume that in the sample above, the method \lstinline|MyClass::formatData| is more or less doing what you want, but there is just one caption that you want to have different. Then a completely legal implementation for \lstinline|CustomClass::formatData| could look like this:
\begin{lstlisting}
/**
 *  {@inheritDoc}
 */
@Override
protected final String formatData( final String data, final ProcessContext context )
{
	final var formattedData = super.formatData( data, context );
    final var retValue = formattedData.replace( "Caption:", "Description:" );
       
    //---* Done *------------------------------------------------
   return retValue;
}   //  formatData()
\end{lstlisting}

And before it gets lost: each overriding method has to be annotated with the \lstinline|@Override| annotation\autocite{ORACLE_DOC_OVERRIDE_ANNOTATION}, no matter it was declared in a class or in an interface. Usually, you can use just \verb#{@inheritDoc}# as the documentation for that method.

\subsection{Adapter Classes}\label{sec:Adapter}
An adapter class implements an interface with mainly optional methods; all methods in the class are empty. In addition, an adapter class does not define any attributes\footnote{Otherwise, it would need at least accessor and probably also mutator methods for these attributes that could not be empty.}. A sample for that pattern is the class \lstinline|java.awt.event.KeyAdapter|; it implements the interface \lstinline|java.awt.event.KeyListener|.

This is used like this:
\begin{lstlisting}
public final class MyClass 
{
    public static final void main( final String... args ) 
    {
        final var frame = new JFrame( "Key Listener" );
        final var contentPane = frame.getContentPane();
        final KeyListener listener = new KeyAdapter() 
        {
            @Override
            public void keyPressed(KeyEvent event) {
                printEventInfo("Key Pressed", event);
            }
            @Override
            public void keyReleased(KeyEvent event) {
                printEventInfo("Key Released", event);
            }
            @Override
            public void keyTyped(KeyEvent event) {
                printEventInfo("Key Typed", event);
            }
            
            private final void printEventInfo( final String str, final KeyEvent e ) 
            {
                System.out.println( str );
                int code = e.getKeyCode();
                System.out.println( "   Code: " + KeyEvent.getKeyText( code ) );
                System.out.println( "   Char: " + e.getKeyChar() );
                int mods = e.getModifiersEx();
                System.out.println( "    Mods: " + KeyEvent.getModifiersExText( mods ) );
                System.out.println( "    Location: " + keyboardLocation( e.getKeyLocation() ) );
                System.out.println( "    Action? " + e.isActionKey() );
            }   //  printEventInfo()
            
            
            private final String keyboardLocation( final int keybrd ) 
            {
                final var retValue = switch( keybrd ) 
                {
                    case KeyEvent.KEY_LOCATION_RIGHT -> "Right";
                    case KeyEvent.KEY_LOCATION_LEFT -> "Left";
                    case KeyEvent.KEY_LOCATION_NUMPAD -> "NumPad";
                    case KeyEvent.KEY_LOCATION_STANDARD -> "Standard";
                    default -> "Unknown";
                };
                
                //---* Done *----------------------------------------
                return retValue;
            }	//	keyboardLocation()
        };
        
        final var textField = new JTextField();
        textField.addKeyListener( listener );
        contentPane.add( textField, BorderLayout.NORTH );
        frame.pack();
        frame.setVisible( true );
    }   //  main()
}
//  class MyClass
\end{lstlisting}

The advantage from using \lstinline|KeyAdapter| instead of implementing the interface \lstinline|KeyListener| directly is that you do not have to implement those methods you are not interested in. Below the relevant part when using the interface:

\begin{lstlisting}
public final class MyClass 
{
    public static final void main( final String... args ) 
    {
        …
        final KeyListener listener = new KeyListener() 
        {
            @Override
            public void keyPressed( KeyEvent event ) { /* Does nothing */ }

            @Override
            public void keyReleased(KeyEvent event) { /* Does nothing */ }
            
            @Override
            public final void keyTyped( final KeyEvent event ) 
            {
                printEventInfo("Key Typed", event);
            }   //  keyTyped()
            
			…
    }   //  main()
}
//  class MyClass
\end{lstlisting}

For this interface and this adapter class, the advantage is marginal, but already the JDK knows some interfaces with much more methods that do have an adapter class, and these would benefit much more from an adapter class.

But since Java~8, interfaces may have \lstinline|default| methods\autocite{ORACLE_TUTORIALS:DefaultMethods, ORACLE_DOC_LANGUAGE_SPECIFICATION:MethodDeclarationsInterface}. Therefore, today the concept of an adapter class has got obsolete. Instead, you would define the interface differently, using \lstinline|default| methods.

For the interface \lstinline|java.awt.event.KeyListener| this would look like this:
\begin{lstlisting}
package java.awt.event;

import java.util.EventListener;

/**
 *  The listener interface for receiving keyboard events (keystrokes).
 *  […]
 *
 *  @author Carl Quinn
 *
 *  @see KeyAdapter
 *  @see KeyEvent
 */
public interface KeyListener extends EventListener 
{
    /**
     *  <p>{@summary Invoked when a key has been typed.} See the
     *  class description for 
     *  {@link KeyEvent} 
     *  for a definition of a key typed event.</p>
     *
     *  @param	e   The event to be processed.
     */
    public default void keyTyped( final KeyEvent e ) { /* Does nothing */ }

    /**
     *  <p>{@summary Invoked when a key has been pressed.} See the
     *  class description for 
     *  {@link KeyEvent}
     *  for a definition of a key pressed event.</p>
     *
     *  @param  e   The event to be processed.
     */
    public default void keyPressed( final KeyEvent e ) { /* Does nothing */ }

    /**
     *  <p>{@summary Invoked when a key has been released.} See the
     *  class description for 
     *  {@link KeyEvent} 
     *  for a definition of a key released event.</p>
     *
     *  @param  e   The event to be processed.
     */
    public default void keyReleased( final KeyEvent e ) { /* Does nothing */ }
}
//  interface KeyListener
\end{lstlisting}

This would allow to use the interface, but to implement only the method \lstinline|keyTyped()|.

\section{Types for Argument and Return Values}\label{sec:TypesForArgumentAndReturnValues}
This topic is relevant for all types of code, not only for code in a public API. Basically, it can be reduced to two questions that needs to be answered:
\begin{enumerate}
\item{Interface vs. concrete Class}
\item{Mutable vs. Immutable}
\end{enumerate}

In general, the answers are “Interface” and “Immutable”, but this is not always the best option.

\subsection{Return Types}\label{sec:ReturnTypes}
A method, in particular a non-\lstinline|private| method, should return the most general interface or class whenever possible. This means~…
\begin{itemize}[nosep]
\item{…~the interface \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} or even \lstinline|java.util.Collection|\autocite{ORACLE_DOC_COLLECTION_INTERFACE} instead of the concrete implementation \lstinline|java.util.ArrayList|\autocite{ORACLE_DOC_ARRAYLIST_CLASS}}
\item{…~the interface \lstinline|java.util.Map|\autocite{ORACLE_DOC_MAP_INTERFACE} and not the class \lstinline|java.util.HashMap|\autocite{ORACLE_DOC_HASHMAP_CLASS}}
\item{…the base class ~\lstinline|java.io.InputStream|\autocite{ORACLE_DOC_INPUTSTREAM_CLASS} and not the wrapper class \lstinline|java.io.FileInputStream|\autocite{ORACLE_DOC_FILEINPUTSTREAM_CLASS}}
\end{itemize}

Only when a concrete class or a more specialised interface provides features that are relevant to the caller, the method should be defined to return that type.

The only exception is \lstinline|java.lang.String| as the return type. Here you should really use that type, and not \lstinline|java.lang.CharSequence|. That is because this interface is implemented by immutable types (\lstinline|String|) and mutable types (e.g. \lstinline|StringBuilder|) as well.

In general, it is not evil if a method returns a mutable type, but it can get nasty under some circumstances – for example when you expose the object's internal state this way:
\begin{lstlisting}
public final class MyClass
{
    private final List<String> m_Attribute = new ArrayList<>();

    // PROBLEMATIC!!    
    public final List<String> getAttribute() { return m_Attribute; }
}
//  class MyClass    
\end{lstlisting}

This means that code like that below would modify \lstinline|myObject| – and not only the lines~3 to~5, but also the lines~9 to~11:
\begin{lstlisting}[numbers=left]
final var myObject = new MyClass();

myObject.getAttribute().add( "Some String" );
myObject.getAttribute().sort( String.CASE_INSENSITIVE_ORDER );
myObject.getAttritute().clear();

final var list = myObject.getAttribute();

list.getAttribute().add( "Some String" );
list.getAttribute().sort( String.CASE_INSENSITIVE_ORDER );
list.getAttritute().clear();
\end{lstlisting}
Usually, this is not desired! Otherwise, it should be clearly documented: 
\begin{lstlisting}
…
/**
 *  Returns a reference to the attribute.
 * 
 *  @note Any modification of the returned value will be reflected to
 *      the attribute itself and changes the state of the object.
 * 
 *  @return The reference to the attribute.
 */ 
public final List<String> getAttribute() { return m_Attribute; }
…
\end{lstlisting}

Some better implementations of \lstinline|getAttribute()| would be:
\begin{lstlisting}[numbers=left]
…
/**
 *  Returns the attribute.
 * 
 *  @return The attribute.
 */ 
public final List<String> getAttribute() 
{ 
	final var retValue = List.copyOf( m_Attribute );
	final List<String> retValue = unmodifiableList( m_Attribute );
	final List<> retValue = new ArrayList<>( m_Attribute );
	final List<String> retValue = unmodifiableList( new ArrayList<>( m_Attribute ) );
	final List<String> retValue = m_Attribute.clone();

    //---* Done *----------------------------------------------------
    return retValue;
}   //  getAttribute()
…
\end{lstlisting}

\paragraph{Line~9} creates an unmodifiable copy of \lstinline|m_Attribute|. The method \lstinline|copyOf()| exists for \lstinline|java.util.List|, \lstinline|java.util.Set|\autocite{ORACLE_DOC_SET_INTERFACE} and \lstinline|java.util.Map|. The only limitation is that \lstinline|null| is not valid as a value, and – for \lstinline|Map| – as a key.

It is important to know, that in case a \lstinline|Set| is a \lstinline|SortedSet|\autocite{ORACLE_DOC_SORTEDSET_CLASS} or a \lstinline|Map| is a \lstinline|TreeMap|\autocite{ORACLE_DOC_TREEMAP_CLASS}, the sort order gets lost for the copy.

\paragraph{Line~10} wraps \lstinline|m_Attribute| into an unmodifiable instance of \lstinline|List|. Drawback is that the returned value changes when the attribute itself will be changed.

The method \lstinline|unmodifiableList()| is part of the utility class \lstinline|java.util.Collections|\autocite{ORACLE_DOC_COLLECTIONS_CLASS}.

\paragraph{Line~11} creates a copy of \lstinline|m_Attribute|; the returned value will be mutable, but changes will not affect the attribute and therefore will not affect the state of the object instance, too. And \lstinline|null| values are no problem.

\paragraph{Line~12} creates a copy of \lstinline|m_Attribute| and wraps it into an umodifiable instance of \lstinline|List| – it combines lines~10 and 11, eliminating the shortcoming of the solutions from lines~9 and 10.

\paragraph{Line~13} ‘clones’ \lstinline|m_Attribute|; obviously this works only for instances that implement \lstinline|java.lang.Cloneable|\autocite{ORACLE_DOC_CLONEABLE_INTERFACE}, but although collections (and arrays) are cloneable themselves, they may contain elements that are not cloneable, causing a \lstinline|CloneNotSupportedException|\autocite{ORACLE_DOC_CLONENOTSUPPORTEDEXCEPTION_CLASS}.

A similar approach has to be taken for all attributes of a mutable type that will be returned by a method. The sample uses a collection, for other mutable types the details on how to create a copy or to make it immutable will differ.

If a method creates (generates, obtains, reads, loads,~…) the return value, it is part of the methods's contract whether that value is mutable or not. 

\subsection{Arguments}\label{Arguments}
Same as for a return type, the types for the formal parameters of a method should always be the most general type (interface or class) possible, but different from the return types, you should always to consider to use \lstinline|java.lang.CharSequence| instead of \lstinline|java.lang.String|.

A method must declare that it will modify an argument value. This is important because otherwise it could be called with an immutable implementation, what would cause an exception. Conversely, this also means that a method that does not specify this will not change any of the arguments, and that it would also be safe to call a method with a mutable object – safe for the caller.

But when the called method stores the provided reference in the instance, this may call for trouble:
\begin{lstlisting}
public final class MyClass
{
    private List<String> m_Attribute;
    
    public MyClass( final List<String> attribute )
    {
        // AVOID!!
        m_Attribute = attribute;
    }   //  MyClass()
}
//  classMyClass
\end{lstlisting}

If the caller holds a reference to the argument object, it can still modify it – and change the internal state of the \lstinline|MyClass| instance at the same time.

Therefore you should create a copy for the argument:
\begin{lstlisting}
…
m_Attribute = new ArrayList( attribute );
…
\end{lstlisting}
If the code of the class will not modify the attribute, you can of course use \lstinline|List::copyOf|, too.

Or you can do it like this\footnote{And do not forget the null check!}:
\begin{lstlisting}
public final class MyClass
{
    private final List<String> m_Attribute = new ArrayList<>();
    
    public MyClass( final List<String> attribute )
    {
        m_Attribute.addAll( attribute );
    }   //  MyClass()
}
//  classMyClass
\end{lstlisting}

\section{Swap Logic Errors for Compiler Errors}
From a book about Java programming:
\begin{quotation}
“One fundamental principle of programming is that, generally, it is best to swap a logic error for a compiler error. Compiler errors tend to be found in seconds and are corrected just as fast. Syntax errors are a good example […]

Logic errors, on the other hand, are the bane of all programmers. They hide and hate to reveal themselves. Logic errors seem to have minds of their own, constantly evading detection and dodging your efforts to pin down their cause. They can easily take a thousand times more effort to solve than the worst compiler errors. Worst of all, many logic errors are not found at all and occur only intermittently in sensitive places, which causes your customer to scream for a fix. Logic errors often require you to throw thousands of man-hours at them, only to finally discover that they are minor typos.”

Robert Simmons Jr.: \textit{Hardcore Java}\autocite{Simmons:HARDCORE_JAVA}
\end{quotation}

A sample for swapping a logic error for a compiler error is the recommendation to write comparisons always with the unchangeable value on the left side\footnote{This recommendation originates from C/C++ programming where \lstinline|if| conditions are checking values of type integer – and in C, nearly everything can be an integer, or at least be interpreted like one. Java forces that the type of the expression in the \lstinline|if| condition has to be \lstinline|boolean|, therefore this approach is less useful for Java code.}. So if you forget the second equal sign for a comparison on equal, the compiler will complain immediately:
\begin{lstlisting}
if( length() == len ) …
if( 5 == len ) …
\end{lstlisting}

Another sample for this is the recommendation to name fields with the “m\_” prefix (refer to chapter \tqfullvref{sec:Fields}). The compiler will never complain if you omit the \lstinline|this.| prefix when accessing a field, and it will not complain if you name a local variable in the same way as a field\footnote{Although you can configure both Eclipse and IntelliJ Idea to raise an error or a warning if you access a field without \lstinline|this.| and if you shadow a field through a local variable with the same name.} – but it will scream loudly about a non-existing reference if you forget the “m\_” prefix when accessing a field named along the rules defined here.

The best thing about compiler errors is, that they usually show up during development – and not first after deployment at customer side.

See also chapter \tqvref{sec:CompilerWarningsAndErrors} about compiler warnings and errors.

\section{Local Variable Type Inference}\label{sec:LocalVariableTypeInference}
Java~10 introduced type inference for local variables. Previously, all local variable declarations required an explicit (manifest) type on the left-hand side. With type inference, the explicit type can be replaced by the reserved type name \lstinline|var|\footnote{That \lstinline|var| was not introduced as an new \textit{keyword} for the language, it can be still used as name for local variables, fields and methods – although it is definitely discouraged to do so!} for local variable declarations that have initialisers. The type of the variable is inferred from the type of the initialiser.

There is a certain amount of controversy over this feature. Some welcome the concision it enables; others fear that it deprives readers of important type information, impairing readability. And both groups are right, to some extent. It can make code more readable by eliminating redundant information, and it can also make code less readable by eliding useful information. Another group worries that it will be overused, resulting in more bad Java code being written. This is also true, but it’s also likely to result in more good Java code being written. Like all features, it must be used with judgment. There’s no blanket rule for when it should and shouldn’t be used. 

Local variable declarations do not exist in isolation; the surrounding code can affect or even overwhelm the effects of using \lstinline|var|. The goal of this chapter is to examine the impact that surrounding code has on \lstinline|var| declarations, to explain some of the tradeoffs, and to provide guidelines for the effective use of \lstinline|var|.\footnote{This chapter is basically a summary of the article “Local Variable Type Inference – Style Guidelines”, published by Stuart~W.~Marks in March 2018\autocite{Marks:LocalVariableTypeInference}.}

\subsection{Principles}
The guidelines below are based on a few principles.

\begin{enumerate}
\item[P1.]{Reading code is more important than writing code.

Code is read much more often than it is written. Further, when writing code, you usually have the whole context in your head, and take your time; when reading code, you are often context-switching, and may be in more of a hurry. Whether and how particular language features are used ought to be determined by their impact on future readers of the program, not its original author. Shorter programs can be preferable to longer ones, but shortening a program too much can omit information that is useful for understanding the program. The central issue here is to find the right size for the program such that understandability is maximized.

You should be specifically unconcerned here with the amount of keyboarding that is necessary to input or to edit a program. While concision may be a nice bonus for the author, focusing on it misses the main goal, which is to improve the understandability of the resulting program.}

\item[P2.]{Code should be clear from local reasoning.

The reader should be able to look at a \lstinline|var| declaration, along with uses of the declared variable, and understand almost immediately what is going on. Ideally, the code should be readily understandable using only the context from a snippet or a patch. If understanding a \lstinline|var| declaration requires the reader to look at several locations around the code, it might not be a good situation in which to use \lstinline|var|. Then again, it might indicate a problem with the code itself.}

\item[P3.]{Code readability shouldn’t depend on IDEs.

Code is often written and read within an IDE, so it’s tempting to rely heavily on the code analysis features of IDEs. For type declarations, why not just use \lstinline|var| everywhere, since one can always point at a variable to determine its type?

The main reason is that code is often read outside an IDE. Code appears in many places where IDE facilities are not available, such as snippets within a document, browsing a repository on the internet, or in a patch file. It is counterproductive to have to import code into an IDE simply to understand what the code does.

Code should be self-revealing. It should be understandable on its face, without the need for assistance from tools.}

\item[P4.]{Explicit types are a tradeoff.

Java has historically required local variable declarations to include the type explicitly. While explicit types can be very helpful, they are sometimes not very important, and are sometimes just in the way. Requiring an explicit type can add clutter that crowds out useful information.

Omitting an explicit type can reduce clutter, but only if its omission does not impair understandability. The type is not the only way to convey information to the reader. Other means include the variable's name and the initialiser expression. You should take all the available channels into account when determining whether it is appropriate to mute one of these channels.}
\end{enumerate}

\subsection{Guidelines}
\begin{enumerate}
\item[G1.]{Choose variable names that provide useful information.

This is good practice in general, but it is much more important in the context of \lstinline|var|. In a \lstinline|var| declaration, information about the meaning and use of the variable can be conveyed using the variable's name. Replacing an explicit type with \lstinline|var| should often be accompanied by improving the variable name.

For example:

\begin{lstlisting}
// BAD
final List<Customer> x = dbConnection.executeQuery( query );

// BETTER
final var customerList = dbConnection.executeQuery( query );
\end{lstlisting}

In this case, a useless variable name has been replaced with a name that is evocative of the type of the variable, which is now implicit in the var declaration.

Encoding the variable's type in its name, taken to its logical conclusion, results in “Hungarian Notation”. Just as with explicit types, this is sometimes helpful, and sometimes just clutter. In this example the name \lstinline|customerList| implies that a \lstinline|List| is being returned. That might not be significant. Instead of the exact type, it’s sometimes better for a variable’s name to express the role or the nature of the variable, such as \lstinline|customers|:

\begin{lstlisting}
// BAD
try( final Stream<Customer> result = dbConnection.executeQuery( query ) ) 
{
    return result.map( … )
        .filter( … )
        .findAny();
}

// BETTER
try( final var customers = dbConnection.executeQuery( query ) ) 
{
    final var retValue = customers.map( … )
        .filter( … )
        .findAny();
    return retValue;
}
\end{lstlisting}}

\item[G2.]{Minimize the scope of local variables.

Limiting the scope of local variables is good practice in general. This practice is described in “Effective Java (3\textsuperscript{rd} Edition)”\autocite{Bloch:EffectiveJava}, Item~57. It applies with extra force if \lstinline|var| is in use.

In the following example, the \lstinline|add()| method clearly adds the special item as the last list element, so it’s processed last, as expected.

\begin{lstlisting}
final var items = new ArrayList<Item>( … );
items.add( MUST_BE_PROCESSED_LAST );
for( final var item : items ) { … }
\end{lstlisting}

Now suppose that in order to remove duplicate items, you modify this code to use a \lstinline|HashSet| instead of an \lstinline|ArrayList|, like below:

\begin{lstlisting}
final var items = new HashSet<Item>( … );
items.add( MUST_BE_PROCESSED_LAST );
for( fnial var item : items ) { … }
\end{lstlisting}

Your code now has a bug, since sets do not have a defined iteration order. However, it is likely that you will fix this bug immediately, as the uses of the \lstinline|items| variable are adjacent to its declaration.

Now suppose that this code is part of a large method, with a correspondingly large scope for the \lstinline|items| variable:

\begin{lstlisting}
final var items = new HashSet<Item>( … );

// … 100 lines of code …

items.add( MUST_BE_PROCESSED_LAST );
for( final var item : items ) { … }
\end{lstlisting}

The impact of changing from an \lstinline|ArrayList| to a \lstinline|HashSet| is no longer readily apparent, since \lstinline|items| is used so far away from its declaration. It seems likely that this bug could survive for much longer.

If \lstinline|items| had been declared explicitly as \lstinline|List<String>|, changing the initialiser would also require changing the type to \lstinline|Set<String>|. This \textit{might} prompt you to inspect the rest of the method for code that would be impacted by such a change (then again, it might not). Use of \lstinline|var| would remove this prompting, possibly increasing the risk of a bug being introduced in code like this.

This might seem like an argument against using \lstinline|var|, but it really is not. The initial example that uses \lstinline|var| is perfectly fine. The problem only occurs when the variable's scope is large. Instead of simply avoiding \lstinline|var| in these cases, you should change the code to reduce the scope of the local variables, and only then declare them with \lstinline|var|.}

\item[G3.]{Consider \lstinline|var| when the initialiser provides sufficient information to the reader.

Local variables are often initialised with constructors. The name of the class being constructed is often repeated as the explicit type on the left-hand side. If the type name is long, use of \lstinline|var| provides concision without loss of information:

\begin{lstlisting}
// ACCEPTABLE
final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

// BETTER
final var outputStream = new ByteArrayOutputStream();
\end{lstlisting}

It is also reasonable to use \lstinline|var| in cases where the initialiser is a method call, such as a \lstinline|static| factory method, instead of a constructor, and when its name contains enough type information:

\begin{lstlisting}
// ACCEPTABLE
final BufferedReader reader = Files.newBufferedReader( … );
final List<String> stringList = List.of("a", "b", "c");

// BETTER
final var reader = Files.newBufferedReader(...);
final var stringList = List.of("a", "b", "c");
\end{lstlisting}

In these cases, the methods names strongly imply a particular return type, which is then used for inferring the type of the variable.}

\item[G4.]{Use \lstinline|var| to break up chained or nested expressions with local variables.

Consider code that takes a collection of strings and finds the string that occurs most often. This might look like the following:

\begin{lstlisting}
return strings.stream()
    .collect( groupingBy( s -> s, counting() ) )
    .entrySet()
    .stream()
    .max( Map.Entry.comparingByValue() )
    .map( Map.Entry::getKey );
\end{lstlisting}

This code is correct, but it is potentially confusing, as it looks like a single stream pipeline. In fact, it’s a short stream, followed by a second stream over the result of the first stream, followed by a mapping of the \lstinline|Optional| result of the second stream. The most readable way to express this code would have been as two or three statements; first group entries into a map, then reduce over that map, then extract the key from the result (if present), as shown below:

\begin{lstlisting}
// BETTER READABLE
final Map<String, Long> freqMap = strings.stream()
    .collect(groupingBy( s -> s, counting() ) );
final Optional<Map.Entry<String,Long>> maxEntryOpt = freqMap.entrySet()
    .stream()
    .max( Map.Entry.comparingByValue() );
return maxEntryOpt.map( Map.Entry::getKey );
\end{lstlisting}

But you probably resisted doing that because writing the types of the intermediate variables seemed too burdensome, so instead they distorted the control flow. Using \lstinline|var| here allows you to express the code more naturally without paying the high price of explicitly declaring the types of the intermediate variables:

\begin{lstlisting}
// EVEN BETTER READABLE
final var freqMap = strings.stream()
    .collect( groupingBy( s -> s, counting() ) );
final var maxEntryOpt = freqMap.entrySet()
    .stream()
    .max( Map.Entry.comparingByValue() );
final var retValue = maxEntryOpt.map( Map.Entry::getKey );
return retValue;
\end{lstlisting}

You might legitimately prefer the first snippet with its single long chain of method calls. However, in some cases it is better to break up long method chains. Using \lstinline|var| for these cases is a viable approach, whereas using full declarations of the intermediate variables as in the second snippet makes it an unpalatable alternative. As with many other situations, the correct use of \lstinline|var| might involve both taking something out (explicit types) and adding something back (better variable names, better structuring of code).}

\subsection{-------------------------------------------- Proceed from here!}
\item[G5.]{Don’t worry too much about “programming to the interface” with local variables.

A common idiom in Java programming is to construct an instance of a concrete type but to assign it to a variable of an interface type. This binds the code to the abstraction instead of the implementation, which preserves flexibility during future maintenance of the code. For example:

\begin{lstlisting}
// ORIGINAL
List<String> list = new ArrayList<>();
If var is used, however, the concrete type is inferred instead of the interface:

// Inferred type of list is ArrayList<String>
var list = new ArrayList<String>();
\end{lstlisting}

It must be reiterated here that var can only be used for local variables. It cannot be used to infer field types, method parameter types, and method return types. The principle of “programming to the interface” is still as important as ever in those contexts.

The main issue is that code that uses the variable can form dependencies on the concrete implementation. If the variable’s initialiser were to change in the future, this might cause its inferred type to change, causing errors or bugs to occur in subsequent code that uses the variable.

If, as recommended in guideline G2, the scope of the local variable is small, the risks from “leakage” of the concrete implementation that can impact the subsequent code are limited. If the variable is used only in code that’s a few lines away, it should be easy to avoid problems or to mitigate them if they arise.

In this particular case, ArrayList only contains a couple of methods that aren’t on List, namely ensureCapacity and trimToSize. These methods don’t affect the contents of the list, so calls to them don’t affect the correctness of the program. This further reduces the impact of the inferred type being a concrete implementation rather than an interface.}
\item[G6.]{Take care when using var with diamond or generic methods.

Both var and the “diamond” feature allow you to omit explicit type information when it can be derived from information already present. Can you use both in the same declaration?

Consider the following:

\begin{lstlisting}
PriorityQueue<Item> itemQueue = new PriorityQueue<Item>();
\end{lstlisting}
This can be rewritten using either diamond or var, without losing type information:

\begin{lstlisting}
// OK: both declare variables of type PriorityQueue<Item>
PriorityQueue<Item> itemQueue = new PriorityQueue<>();
var itemQueue = new PriorityQueue<Item>();
\end{lstlisting}

It is legal to use both var and diamond, but the inferred type will change:

\begin{lstlisting}
// DANGEROUS: infers as PriorityQueue<Object>
var itemQueue = new PriorityQueue<>();
\end{lstlisting}

For its inference, diamond can use the target type (typically, the left-hand side of a declaration) or the types of constructor arguments. If neither is present, it falls back to the broadest applicable type, which is often Object. This is usually not what was intended.

Generic methods have employed type inference so successfully that it’s quite rare for programmers to provide explicit type arguments. Inference for generic methods relies on the target type if there are no actual method arguments that provide sufficient type information. In a var declaration, there is no target type, so a similar issue can occur as with diamond. For example,

\begin{lstlisting}
// DANGEROUS: infers as List<Object>
var list = List.of();
\end{lstlisting}

With both diamond and generic methods, additional type information can be provided by actual arguments to the constructor or method, allowing the intended type to be inferred. Thus,

\begin{lstlisting}
// OK: itemQueue infers as PriorityQueue<String>
Comparator<String> comp = ... ;
var itemQueue = new PriorityQueue<>(comp);

// OK: infers as List<BigInteger>
var list = List.of(BigInteger.ZERO);
\end{lstlisting}

If you decide to use var with diamond or a generic method, you should ensure that method or constructor arguments provide enough type information so that the inferred type matches your intent. Otherwise, avoid using both var with diamond or a generic method in the same declaration.}
\item[G7.]{Take care when using var with literals.
Primitive literals can be used as initialisers for var declarations. It’s unlikely that using var in these cases will provide much advantage, as the type names are generally short. However, var is sometimes useful, for example, to align variable names.

There is no issue with boolean, character, long, and string literals. The type inferred from these literals is precise, and so the meaning of var is unambiguous:

\begin{lstlisting}
// ORIGINAL
boolean ready = true;
char ch = '\ufffd';
long sum = 0L;
String label = "wombat";

// GOOD
var ready = true;
var ch    = '\ufffd';
var sum   = 0L;
var label = "wombat";
\end{lstlisting}

Particular care should be taken when the initialiser is a numeric value, especially an integer literal. With an explicit type on the left-hand side, the numeric value may be silently widened or narrowed to types other than int. With var, the value will be inferred as an int, which may be unintended.

\begin{lstlisting}
// ORIGINAL
byte flags = 0;
short mask = 0x7fff;
long base = 17;

// DANGEROUS: all infer as int
var flags = 0;
var mask = 0x7fff;
var base = 17;
\end{lstlisting}

Floating point literals are mostly unambiguous:

\begin{lstlisting}
// ORIGINAL
float f = 1.0f;
double d = 2.0;

// GOOD
var f = 1.0f;
var d = 2.0;
\end{lstlisting}

Note that float literals can be widened silently to double. It is somewhat obtuse to initialise a double variable using an explicit float literal such as 3.0f, however, cases may arise where a double variable is initialised from a float field. Caution with var is advised here:

\begin{lstlisting}
// ORIGINAL
static final float INITIAL = 3.0f;
...
double temp = INITIAL;

// DANGEROUS: now infers as float
var temp = INITIAL;
\end{lstlisting}

(Indeed, this example violates guideline G3, because there isn’t enough information in the initialiser for a reader to see the inferred type.)}
\end{enumerate}

\subsection{Examples}
This section contains some examples of where var can be used to greatest benefit.

The following code removes at most max matching entries from a Map. Wildcarded type bounds are used for improving the flexibility of the method, resulting in considerable verbosity. Unfortunately, this requires the type of the Iterator to be a nested wildcard, making its declaration more verbose. This declaration is so long that the header of the for-loop no longer fits on a single line, making the code even harder to read.

\begin{lstlisting}
// ORIGINAL
void removeMatches(Map<? extends String, ? extends Number> map, int max) {
    for (Iterator<? extends Map.Entry<? extends String, ? extends Number>> iterator =
             map.entrySet().iterator(); iterator.hasNext();) {
        Map.Entry<? extends String, ? extends Number> entry = iterator.next();
        if (max > 0 && matches(entry)) {
            iterator.remove();
            max--;
        }
    }
}
\end{lstlisting}
Use of var here removes the noisy type declarations for the local variables. Having explicit types for the Iterator and Map.Entry locals in this kind of loop is largely unnecessary. This also allows the for-loop control to fit on a single line, further improving readability.

\begin{lstlisting}
// GOOD
void removeMatches(Map<? extends String, ? extends Number> map, int max) {
    for (var iterator = map.entrySet().iterator(); iterator.hasNext();) {
        var entry = iterator.next();
        if (max > 0 && matches(entry)) {
            iterator.remove();
            max--;
        }
    }
}
\end{lstlisting}

Consider code that reads a single line of text from a socket using the try-with-resources statement. The networking and I/O APIs use an object wrapping idiom. Each intermediate object must be declared as a resource variable so that it will be closed properly if an error occurs while opening a subsequent wrapper. The conventional code for this requires the class name to be repeated on the left and right sides of the variable declaration, resulting in a lot of clutter:

\begin{lstlisting}
// ORIGINAL
try (InputStream is = socket.getInputStream();
     InputStreamReader isr = new InputStreamReader(is, charsetName);
     BufferedReader buf = new BufferedReader(isr)) {
    return buf.readLine();
}
\end{lstlisting}
Using var reduces the noise considerably:

\begin{lstlisting}
// GOOD
try (var inputStream = socket.getInputStream();
     var reader = new InputStreamReader(inputStream, charsetName);
     var bufReader = new BufferedReader(reader)) {
    return bufReader.readLine();
}
\end{lstlisting}

Conclusion
Using var for declarations can improve code by reducing clutter, thereby letting more important information stand out. On the other hand, applying var indiscriminately can make things worse. Used properly, var can help improve good code, making it shorter and clearer without compromising understandability.

\section{Access to Properties}
Encapsulation is an important design principle for classes. This means that the internal state of an object can be manipulated only in a well defined manner, through the methods. Consequently, it may not be possible to modify the attributes  directly, by a direct assignment.

To achieve that, instance or class variables – also known as properties, attributes or fields – have to be \lstinline|private|.

If it is necessary to set or retrieve an instance variable (a property) directly, it mandatory to provide the appropriate methods for this (setter and/or getter, or mutator and/or accessor methods). But often attributes are set or retrieved as a side effect of method calls that modify the internal state of the object instance, or rely on it.

Programmers are inclined to use \lstinline|public| fields when the need a data structure like a \lstinline|struct| in C/C++, and not a full-fledged class. But as Java does not now that data structure, it seems to be a quick solution to have a \lstinline|class| with only \lstinline|public| fields and no methods, just to spare typing effort, and sometimes with the idea, that the direct access to the \lstinline|public| field is much faster that accessing it through a method. But modern optimising compilers will inline the code of a simple getter method, so that there is no difference in the end.

And if you want to avoid the typing, use a \lstinline|record|\autocite{ORACLE_DOC_RECORD,ORACLE_DOC_LANGUAGE_SPECIFICATION:RecordClasses} instead. Sometimes also an instance of \lstinline|java.util.Map| or another collection implementation could be an alternative to a specialised class.
 
Sometimes fields from base classes are defined as \lstinline|protected|, to make them directly accessible by methods from the derived implementations, but this is also discouraged.\footnote{The idea behind that is the same false assumption that the direct access to the \lstinline|protected| field is much faster that accessing it through a method.}

It does not matter if we talk about properties (instance variables) or \lstinline|static| field (class variables): both should always be \lstinline|private|.

Constants are the only exception, obviously, because a constant is explicitly defined as a \lstinline|public static final| field.

Regarding encapsulation in general, refer to chapter \tqvref{sec:EncapsulationWithModules}.

\section{Accessing Fields or Methods using Reflection}
First of all, you should avoid to use Reflection whenever possible. Just do not use it!\footnote{The only acceptable exception is for unit tests; we will discuss that later in this chapter.}

One reason is that accessing a field or a method via reflection causes some overhead that decreases a program’s performance. 

Next, such code is usually not easy to read or to understand, not only because of all the necessary error handling code around it.

And with modularisation, it is quite often not even possible to access methods and fields of an object via Reflection, even if they are \lstinline|public|; they are not even visible in some cases.

Of course, there are some patterns whose implementation in Java requires the use of Reflection, because any other approach is either even less performant, much more cumbersome, or will not work at all – meaning there are occasions when it is not really possible to avoid the use of Reflection. Nevertheless, you should still consider an alternative; lambdas\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:LambdaExpressions} and method references\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:MethodReference} are quite often a very good replacement for an implementation based on Reflection.

Reflection also allows you to access non-\lstinline|public| member of a class that are usually not accessible by your code. This is considered a “dirty hack” and may not be used in production code. In particular as it may not work properly with modules.

But there are useful applications for this, too: you can and should used it in unit tests for \lstinline|private| or \lstinline|protected| methods that are not \lstinline|public| for good reasons, and if these methods cannot be tested indirectly.\footnote{The alternative would be to make the method at least \lstinline|protected|, but this would make it (more) visible to the consumers of the API, and perhaps even accessible – but there was a reason why that method was originally \lstinline|private|.}

I recommend to use the following pattern if you want to access a \lstinline|private| method in your unit tests:
\begin{lstlisting}[numbers=left]
public final class MyClass
{
    /**
     *  Does something.
     *
     *  @param  value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    private final String myMethod( final CharSequence value ) throws IOException      { … }
}   
//  class MyClass

/**
 *  This class provides some unit tests for
 *  {@link MyClass}.
 */
public final class TestMyClass
{
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The reference to {@code myMethod()}.
     */
    private static final Method METHOD_myMethod;
    
    static
    {
        final var targetClass = MyClass.class;
        String methodName;
        try
        {
            methodName = "myMethod";
            METHOD_myMethod = targetClass.getDeclaredMethod( methodName, CharSequence.class );
            METHOD_myMethod.setAccessible( true );
        }
        catch( final NoSuchMethodException ignored )
        {
            throw new ExceptionInInitializerError( "Cannot find method '%s()' in class '%s'".formatted( methodName, targetClass.getName() );
        }
    }
    
        /*---------*\
    ====** Methods **================================================ 
        \*---------*/
    /**
     *  Calls
     *  {@link MyClass#myMethod(CharSequence)}
     *
     *  @param  instance    The candidate.
     *  @param	value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    protected static final String myMethod( final MyClass instance, final CharSequence value )
    {
        final String retValue;
        try
        {
            retValue = (String) METHOD_myMethod.invoke( requireNonNullArgument( instance, "instance" ), value );
        }
        catch( final IllegalAccessException | ClassCastException e )
        {
            throw new AssertionError( e );
        }
        catch( final InvocationTargetException e )
        {
            switch( e.getCause() )
            {
                case null -> throw new AssertionError( e );
                case IOException ioe -> throw ioe;
                default -> throw new AssertionError( e.getCause() );
            }
        }
    }   //  myMethod()   
    
    @Test
    final void testMyMethod() throws Exception
    {
        final var candidate = new MyClass();
        final var result = myMethod( candidate, "" );
        assertTrue( result instanceof String );
    }   // testMyMethod()
}
//  class TestMyClass  
\end{lstlisting}
This allows you to call the method \lstinline|MyClass::myMethod| nearly directly; the method \lstinline|TestMyClass::myMethod| behaves in the same way as the original method.

\lstinline|java.lang.AssertionError|\autocite{ORACLE_DOC_ASSERTIONERROR_CLASS} is the base class for the errors thrown by JUnit\autocite{JUNIT5}.

\section{Implementing the Object Methods}
In Java all \textit{classes} are somehow extending the class \lstinline|java.lang.Object|\autocite{ORACLE_DOC_OBJECT_CLASS}, and therefore, they inherit several methods from it. Four of these methods\footnote{In fact, it is five methods, but the method \lstinline|finalize()|\autocite{ORACLE_DOC_OBJECT:finalize} is deprecated and should not be used anymore. Refer to chapter \tqfullvref{sec:Finalisation} for more details on this topic.} can be overridden to adjust the behaviour of your class to your needs:
\begin{itemize}[nosep]
\item{\lstinline|clone()|\autocite{ORACLE_DOC_OBJECT:clone}}
\item{\lstinline|equals()|\autocite{ORACLE_DOC_OBJECT:equals}}
\item{\lstinline|hashCode()|\autocite{ORACLE_DOC_OBJECT:hashCode}}
\item{\lstinline|toString()|\autocite{ORACLE_DOC_OBJECT:toString}}
\end{itemize}

The chapters below will provide some guidelines on how to code new implementations for these methods.

\subsection{equals() and hashCode()}\label{sec:EqualsAndHashCode}
Overriding the method \lstinline|java.lang.Object::equals|\autocite{ORACLE_DOC_OBJECT:equals} always requires to override the method \lstinline|java.lang.Object::hashCode|\autocite{ORACLE_DOC_OBJECT:hashCode}, too – and vice versa.

\textit{This is not optional!}

The method \lstinline|equals()| returns \lstinline|true| if the given reference to refers to an object to is equals to the current one, according to \textit{your criteria what “being equal” means} in this context, and – obviously – \lstinline| false| otherwise.

So two objects can be considered to be equal when they both have the same unique id, or you require for equality that all attributes do have the same values (are also equal), or something in between. The default implementation of \lstinline|java.lang.Object.equals()| returns \lstinline|true| only if the two objects are identical\footnote{This means that both objects are the \textit{same}; the given reference points to the current object itself.}.

If two objects are equal, the result of \lstinline|hashCode()| has to be the same for both objects, but that the hash values for two objects are the same does not necessarily imply that the two objects are equal.

An implementation for the two methods should look like this:
\begin{lstlisting}[numbers=left,caption={Methods equals() and hashCode()}]
public class MyClass
{
    /**
     *  {@inheritDoc}
     */
    public boolean equals( final Object o )
    {
        var retValue = o == this;
        if( !retValue && o instanceof MyClass other
            && getClass().equals( other.getClass() ) )
        {
            retValue = Objects.equals( <attribute>, other.<attribute> )
                && Objects.equals( < … >, other.< … > );
        }
            
        //---* Done *------------------------------------------------
        return retValue;
    }   //  equals()
    
    /**
     *  {@inheritDoc}
     */
    public int hashCode()
    {
        final var retValue = Objects.hash( <attribute>, < … > );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  hashCode()    
}
//  class MyClass
\end{lstlisting}
The check in line~10 can be omitted if \lstinline|MyClass| is \lstinline|final|. If that check is omitted for a non-\lstinline|final| class, it means that instances of derived classes can be equal to an instance of the superclass – something that is rarely wanted, especially because it would break the rule that any implementation of \lstinline|equals()| has to guarantee that
\begin{lstlisting}
a.equals( b ) == b.equals( a )
\end{lstlisting}
is always valid.

The attributes that are compared in the lines~12 and following have all to be used in \lstinline|hashCode()| to calculate the hash value.

When both a superclass and its derived classes implement \lstinline|java.lang.Object::equals| and \lstinline|java.lang.Object::hashCode|, the implementation of the derived class may call the superclass implementations of \lstinline|equals()| and \lstinline|hashCode()|:
\begin{lstlisting}[numbers=left]
public class OtherClass extends MyClass
{
    /**
     *  {@inheritDoc}
     */
    public boolean equals( final Object o )
    {
        var retValue = o == this;
        if( !retValue && o instanceof OtherClass other
            && super.equals( other ) )
        {
            retValue = Objects.equals( <attribute>, other.<attribute> )
                && Objects.equals( < … >, other.< … > );
        }
            
        //---* Done *------------------------------------------------
        return retValue;
    }   //  equals()
    
    /**
     *  {@inheritDoc}
     */
    public int hashCode()
    {
        final var retValue = Objects.hash( Integer.valueOf( super.hashCode ), <attribute>, < … > );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  hashCode()    
}
//  class OtherClass
\end{lstlisting}
Obviously, both methods consider only the attributes that comes with the definition of the derived class; the attributes of the superclass are already covered.

\subsection{toString()}\label{sec:ToString}
According to \autocite{ORACLE_DOC_OBJECT:toString}, the method \lstinline|toString()|
\begin{quotation}
“Returns a string representation of the object.

In general, the \lstinline|toString()| method returns a string that ‘textually represents’ this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. […]”
\end{quotation}

What does “textually represents” mean?

The implementation for \lstinline|java.lang.Object::toString|~…
\begin{quotation}
“[…] returns a string consisting of the name of the class of which the object is an instance, the at-sign character ‘@’, and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:\
\lstinline|getClass().getName() + '@' + Integer.toHexString( hashCode() )|”
\end{quotation}
But for an instance of \lstinline|java.lang.Integer|\autocite{ORACLE_DOC_INTEGER_CLASS}, that ‘string representation’ is just a string containing the digits for the numerical value of that object, and for an instance of \lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}, it is the current contents of the buffer.

For the class \lstinline|java.util.StringJoiner|\autocite{ORACLE_DOC_STRINGJOINER_CLASS}, \lstinline|toString()| is even the method that provides the result.

Originally, the textual representation of an object as provided by the \lstinline|toString()| method was meant only for debugging purposes, but soon it was also used for the conversion of the object's value to a string, as you can see for classes like \lstinline|java.lang.Integer|, \lstinline|java.util.UUID| or \lstinline|java.time.Instant|.

So how to implement the method \lstinline|toString()| for your method?

If your class represents objects that can be easily written as a string, you should implement \lstinline|toString()| accordingly:
\begin{lstlisting}
public final class PhoneNumber
{
    private final int m_AreaCode;
    private final int m_CountryCode;
    private final int m_SubscriberNumber;
    
    …
    
    /**
     *  {@inheritDoc}
     */
    @Override 
    public final String toString()
    {
        final var retValue = "+%d %d %d".formatted( m_CountryCode, m_AreaCode, m_SubscriberNumber );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  toString()
}   
//  class PhoneNumber
\end{lstlisting}

Some samples for this from the Java Runtime Library are the classes below:
\begin{itemize}
\item\lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\item\lstinline|java.lang.StringBuffer|\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\item\lstinline|java.util.UUID|\autocite{ORACLE_DOC_UUID_CLASS}
\item\lstinline|java.time.Instant|\autocite{ORACLE_DOC_INSTANT_CLASS} and the other classes representing time/date values from the \lstinline|java.time| package\autocite{ORACLE_DOC_TIME_PACKAGE}
\item\lstinline|java.io.File|\autocite{ORACLE_DOC_FILE_CLASS}
\item\lstinline|java.lang.Integer|\autocite{ORACLE_DOC_INTEGER_CLASS} and the other wrapper classes for the primitives
\end{itemize}

In all these cases, you can use a call to \lstinline|toString()| to embed the value of the instance into a regular text:
\begin{lstlisting}
final var phoneNumber = new PhoneNumber( … );
out.printf( "The customer's phonenumber is %s.", phoneNumber.toString() );
\end{lstlisting}

If your class is more complex and/or an output makes only sense for debugging purposes or requires additional formatting instructions, you should consider a different implementation of \lstinline|toString()|:
\begin{lstlisting}
public final class EmailMessage
{
    private final String m_Body;
    private final Map<RecipientType,List<EmailAddress>> m_Recipients;
    private final EmailAddress m_Sender;
    private final ZonedDateTime m_SentWhen;
    private final String m_Subject;
    
    …
    
    /**
     *  {@inheritDoc}
     */
    @Override 
    public final String toString()
    {
        final var buffer = new StringJoiner( ", ", "%s[".formatted( getClass().getName(), "]" )
            .add( "Body='%s'".formatted( m_Body ) )
            .add( "Recipients=%s".formatted( Objects.toString( m_Recipients ) ) )
            .add( "Sender='%s'".formatted( Objects.toString( m_EmailAddress ) ) )
            .add( "Sent_when=%s".formatted( Objects.toString( m_SentWhen ) ) )
            .add( "Subject='%s'".formatted( m_Subject ) );
            
        //---* Compose the return value *----------------------------    
        final var retValue = buffer.toString();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  toString()
}
//  class EmailMessage
\end{lstlisting}

This is basically how the IDEs will generate the \lstinline|toString()| method. The output may look like this\footnote{The backslash indicates where I inserted a linebreak so that it looks fine in this document; otherwise it would be just one long line.}:
\begin{verbatim}
org.tquadrat.sample.EmailMessage[Body='This is the body of the\
email', Recipients=[a.b@c.de], Sender='thomas.thrien@tquadrat.\
org', Sent_when=2022-11-26T20:31:17.884636950+01:00[Europe/Ber\
lin], Subject='Ping!']
\end{verbatim}

This will work fine for a debug log, but to get it ‘pretty printed’, you may have to provide another method. Refer to chapter \tqvref{sec:FormattableInterface} for how
this could look like.

If your class is not \lstinline|final|, the method \lstinline|toString()| should not be \lstinline|final| as well. 

\subsection{clone()}\label{sec:Clone}
Per \autocite{ORACLE_DOC_OBJECT:clone}, the method \lstinline|java.lang.Object::clone| returns a copy of the current object.

Usually, this method is \lstinline|protected| and the default implementation throws a \lstinline|java.lang.CloneNotSupportedException|\autocite{ORACLE_DOC_CLONENOTSUPPORTEDEXCEPTION_CLASS} when called.

When instances of your class should support to be cloned, it first has to implement the interface \lstinline|java.lang.Cloneable|\autocite{ORACLE_DOC_CLONEABLE_INTERFACE}, and then you need to override the method \lstinline|clone()|.

The simpliest implementation looks like this:
\begin{lstlisting}[numbers=left,caption={A simple clone() Method}]
public final MyClass implements Cloneable
{
    /**
     *  {@inheritDoc}
     */
    @Override
    public final MyClass clone()
    {
        final MyClass retValue;
        try
        {
            retValue = (MyClass) super.clone();
        }    
        catch( final CloneNotSupportedException e )
        {
            throw new UnexpectedExceptionError( e );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  clone() 
}
//  class MyClass
\end{lstlisting}
This works despite the fact that the class \lstinline|java.lang.Object| \textit{does not} implement \lstinline|java.lang.Cloneable|!

But it fails in case your class extends a class (other than \lstinline|java.lang.Object|) that does not implement \lstinline|java.lang.Cloneable|.

The implementation of \lstinline|java.lang.Object::clone| uses native code to make a shallow copy of the current object. If all attributes of the class are either immutable or primitives, the implementation shown above is sufficient.

But if any of the attributes are collections, arrays or mutable types, there is some
more work to do; in this case, your implementation of \lstinline|clone()| should declare the \lstinline|java.lang.CloneNotSupportedException|.

Such an extended implementation of \lstinline|clone()| may look like below; it is assumed that \lstinline|T| is not immutable\footnote{If \lstinline|T| will not implement  \lstinline|java.lang.Cloneable|, we can reduce the implementation of \lstinline|clone()| to just throw \lstinline|java.lang.CloneNotSupportedException|. But even if \lstinline|T| implements \lstinline|java.lang.Cloneable|, \lstinline|T::clone| can still throw that exception.}.
\begin{lstlisting}[numbers=left,caption={An extended clone() Method}]
public final MyClass<T extends Cloneable> implements Cloneable
{
    private final T [] m_Array;
    private final Collection<T> m_Collection;
    private T m_Mutable; // MAY NOT BE FINAL!!
    
    /**
     *  {@inheritDoc}
     */
    @Override
    public final MyClass clone() throws CloneNotSupportedException
    {
        final var retValue = (MyClass) super.clone();
        for( var i = 0; i < m_Array.size; ++i )
        {
            retValue.m_Array [i] = nonNull( m_Array [i] ) 
                ? m_Array [i].clone() 
                : null;
        }
        retValue.m_Collection.clear();
        for( final var t : m_Collection ) retValue.m_Collection.add( t.clone() );
        retValue.m_Mutable = m_Mutable.clone();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  clone() 
}
//  class MyClass
\end{lstlisting}

The code in line~21 supposes that the collection does not contain any \lstinline|null| values. And obviously, the collection has to be mutable, otherwise already the attempt to clear it in line~20 would throw an exception.

Unfortunately, the interface \lstinline|java.lang.Cloneable| does not declare the method \lstinline|clone()|, therefore the code below will not work:
\begin{lstlisting}
// WILL NOT WORK!!
CloneLoop: for( final var t : m_Collection ) 
{
    if( isNull( t ) ) continue CloneLoop;
    if( t instanceof Cloneable c )
    {
        retValue.m_Collection.add( c.clone() );
    }
    else
    {
        throw new CloneNotSupportedException( t.toString() );
    }    
}   //  CloneLoop:
\end{lstlisting}

So in case a collection (or an array) may contain components that can or cannot be cloned, the test is a bit more complex:
\begin{lstlisting}
CloneLoop: for( final var t : m_Collection ) 
{
    if( isNull( t ) ) continue CloneLoop;
    boolean isCloneable = false;
    if( t instanceof Cloneable )
    {
    	isCloneable = stream( getClass().getMethods() )
    	    .filter( m -> m.getParameterCount() == 0 )
    	    .map( Method::getName )
    	    .filter( n -> n.equals( "clone" ) )
    	    .count() == 1;
    }
    
    if( isCloneable )
    {
        retValue.m_Collection.add( c.clone() );
    }
    else
    {
        throw new CloneNotSupportedException( t.toString() );
    }    
}   //  CloneLoop:
\end{lstlisting}
Instead of the stream operation, you can also use \lstinline|java.lang.Class::getMethod| and respond to the \lstinline|java.lang.NoSuchMethodException| for the check.

If you have to implement the method \lstinline|java.lang.Object::clone| for lots of classes, it could make sense to implement your own \lstinline|Cloneable| interface that then can be used with the \lstinline|instanceof| operator and the pattern:
\begin{lstlisting}
public interface Cloneable<T> extends java.lang.Cloneable
{
    /**
     *  Forces the implementation of
     *  {@link Object#clone()}
     *
     *  @returns The cloned object.
     *  @throws  CloneNotSupportedException One of the mutable
     *      attributes is not cloneable.
     */
    public T clone() throws CloneNotSupportedException; 
}
//  interface Cloneable
\end{lstlisting}

There are several ongoing discussions whether the API that was defined through the \lstinline|java.lang.Object::clone| is generally usefull or more a pain in the ass, and as far as I am aware, these discussions will last for some more time.

I am not a friend of \lstinline|clone()| and I try to avoid its implementation whenever possible. This means that sometimes it is not possible to circumvent the implementation of that method.

My recommendation is to ignore the method \lstinline|java.lang.Object::clone| unless there is a strict requirement to use it.

\section{String Concatenation}
How to concatenate strings has been a topic of discussion since the very beginning of Java. And the truth has changed with nearly each version of the language, not making it easier to decide how it is done correctly. This chapter provides some recommendations and best practices for the current versions of Java (Java~17 and later).

\subsection{The Basics}
The implementation of the concatenation of two (or more) strings – or other data types to create their representation as a text – is a trade off between readability and performance. This is due to one important characteristic of the class \lstinline|java.lang.String|\autocite{ORACLE_DOC_STRING_CLASS}: it is immutable. This means that
\begin{lstlisting}
String a = "part1";
String b = "part2";
a += b;
\end{lstlisting}
will not modify \lstinline|a| but returns a new \lstinline|String| object with the concatenated contents of \lstinline|a| and \lstinline|b| and assigns a reference to that new object to \lstinline|a|.

Older sources described the internal implementation of the \lstinline|+| operator for \lstinline|java.lang.String| like this:
\begin{lstlisting}
// NOT THE REAL IMPLEMENTATION!!
private final String operatorPlus( String a, String b )
{
    final var buffer = new StringBuffer( a )
        .append( b );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  operatorPlus()
\end{lstlisting}

This means that an intermediate object of type \lstinline|java.lang.StringBuffer|\autocite{ORACLE_DOC_STRINGBUFFER_CLASS} has to be created for each concatenation. This gets even worse if you want to append a numerical value to the String, like this:
\begin{lstlisting}
String a = "part1";
a += 42;
\end{lstlisting}

The implementation for this was described as
\begin{lstlisting}
// NOT THE REAL IMPLEMENTATION!!
private final String operatorPlus( String a, int b )
{
    StringBuffer buffer = new StringBuffer( a );
    String bString = Integer.toString( b );
    buffer.append( bString );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  operatorPlus()
\end{lstlisting}
meaning that two intermediate objects are created.

Knowing this, the recommendation was always to write
\begin{lstlisting}
String a = new StringBuffer( b )
    .append( c )
    .toString();
\end{lstlisting}
instead of
\begin{lstlisting}
String a = b + c;
\end{lstlisting}
and
\begin{lstlisting}
String a = new StringBuffer( a )
    .append( b )
    .toString();
\end{lstlisting}
instead of
\begin{lstlisting}
a += b;
\end{lstlisting}
in order to increase performance.\footnote{These recommendations origin from a time when the class \lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS} did not yet exist. Java~5 introduced \lstinline|StringBuilder| as the successor/replacement for \lstinline|StringBuffer|; it is more perfomant than \lstinline|StringBuffer| because its operations are not synchronised and therefore have less overhead than that of \lstinline|StringBuffer|.}

But with each Java version the \textit{real} implementation of \lstinline|+| and \lstinline|+=| for \lstinline|String| changed, so that today there is no longer just only one recommendation.

\subsection{Concatenating String Constants}
In your code, string literals will be always concatenated with the \verb#plus# operator:
\begin{lstlisting}
String a = "StringOne" + "StringTwo";
\end{lstlisting}
because this way, they will already be concatenated \textit{during compile time}; using \lstinline|StringBuilder| here would cause negative effects on both performance and readability. This is also true when \lstinline|static final String| variables, initialised with a literal, are concatenated with each other or with another string literal:
\begin{lstlisting}
public static final String constantA = "StringOne";
public static final String constantB = "StringTwo";
String a = constantA + constantB;
String b = constantA + "StringThree";
\end{lstlisting}
The compiler replaces each reference to the \lstinline|static final String| variables by either the literal itself or a reference to the literal and concatenates them if required.

\subsection{Concatenating String Variables}
Benchmark tests showed that beginning with one of the later versions of Java~1.4 the variant
\begin{lstlisting}
String a = "part1";
String b = "part2";
String s = a + b;
\end{lstlisting}
is significantly faster than
\begin{lstlisting}
String a = "part1";
String b = "part2";
String s = new StringBuffer( a )
    .append( b );
\end{lstlisting}
Even using \lstinline|StringBuilder| in Java~5 instead of \lstinline|StringBuffer| is slower than the \verb#+# operator.

Appending non-string values to a \lstinline|String| can be done as
\begin{lstlisting}
String a = "part1";
int b = 42;
String s = a + Integer.toString( b );
\end{lstlisting}
and that is still being faster than the \lstinline|StringBu*er| versions.

\subsection{Concatenating Strings in Loops}
The picture changes if strings are extended permanently in a loop:
\begin{lstlisting}
// AVOID!!!
public final String buildSentence( String... words )
{
    var retValue = "";
    for( final var s : words )
    {
        if( !retValue.isEmpty() ) retValue += " ";
        retValue += s;
    }
    retValue += ".";
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()
\end{lstlisting}

Here it is the better option to use \lstinline|StringBuilder| or even \lstinline|java.util.StringJoiner|\autocite{ORACLE_DOC_STRINGJOINER_CLASS}:
\begin{lstlisting}
// BETTER
public final String buildSentence( String... words )
{
    final var buffer = new StringBuilder()
    for( final var s : words )
    {
        if( buffer.length() > 0 ) buffer.append( " " );
        buffer.append( s );
    }
    buffer.append( "." );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()

// RECOMMENDED
public final String buildSentence( String... words )
{
    final var buffer = new StringJoiner( " ", "", "." );
    for( final var s : words )
    {
        buffer.add( s );
    }
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()
\end{lstlisting}

This is faster than the first version, although the concatenation with \verb#+# is usually faster than using \lstinline|StringBuilder|, because the shown version will definitely create much less objects that has to be garbage collected later – what will have a negative impact on performance.

\subsection{Conclusion}
The recommendation is to use the \verb#+# operator for strings where to combine literals, \lstinline|String| constants and/or String variables in a single, standalone statement, but to consider \lstinline|StringBuilder| or even \lstinline|StringJoiner| if strings have to be concatenated in loops or (large) a number of consecutive statements.\footnote{But keep \autocite{Knuth:PrematureOptimization} in mind, where Donald E. Knuth said something about “premature optimisation”.}

When “adding” primitives to a string, these should be translated to a \lstinline|String| first by calling the \lstinline|static toString()| method of the appropriate wrapper class. This is not necessary if calling \lstinline|StringBuilder::append| as this exists as specialised versions each primitive type.

Also when "adding" an instance of another type to a string, you should consider to first call \lstinline|toString()| on that object.This is not mandatory, as it is done implicitly anyway, but it clearly shows what you intended.

Finally, \lstinline|java.lang.StringBuilder| should always be preferred over \lstinline|java.lang.StringBuffer|. I have not found any use case where I could not use \lstinline|StringBuilder| and was forced to use \lstinline|StringBuffer| instead.

\section{The Annotation @API}\label{sec:APIAnnotation}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\lipsum[1]

\begin{lstlisting}
\end{lstlisting}

\section{“Convention over Configuration”}
The phrase “Convention over Configuration” (or “Coding by Convention”) got popular with the introduction of Ruby on Rails, but it is related to earlier ideas like the concept of “Sensible Defaults” and the “Principle of Least Astonishment” in user interface design.

Basically it means that an object instance can be created and used properly with only minimal configuration because all not absolutely mandatory settings will have meaningful – and useful! – default values.

On the other hand, there is that number~\ref{lst:ZoP:ExplicitVsImplicit} from the “Zen of Python”, saying “Explicit is better than implicit”~…

These are obviously contradictory statements – so whose right?

Both, to some extent!

Your design should support “Convention over Configuration”, but your code should rely on defaults only when a change of these defaults in unlikely, or such a change will not have an effect to your code.

So assume that you are using a 3\textsuperscript{rd}~party library that creates reports in HTML format; the default format was HTML3 with the previous version, but in the current version – that one used by you – it is HTML5. The generated reports are consumed by a tool that converts HTML5 input into PDF.

According to “Convention over Configuration”, you are fine: the convention is HTML5, you do not need to set the HTML version for the output format explicitly.

But what happens, if in a few years the next version of that report creator library will support HTML7 as the default, but your PDF generator stucks still with HTML5 for its input? Nothing happens until your successor as the maintainer of your software decides to use that new library~… afterwards you may see funny things in the generated PDF documents.

So the recommendation is: do not always rely on conventions! Whenever possible, provide an explicit configuration! At least leave a comment when you rely on the defaults, and that comment should describe what the anticipated defaults are.

\section{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{Compiler Warnings and Errors}\label{sec:CompilerWarningsAndErrors}
It is not allowed to commit any code that emits warnings or even errors on a compiler run to the SCCS. It is also not allowed to switch off any compiler warning globally.

In fact, warnings should even not show up in the development environment, also with the most aggressive settings.

It is allowed to use the annotation \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} to locally deactivate a warning. This is often necessary when dealing with legacy APIs that does not use Generics. So this sample would emit an “unchecked” warning for line 3:
\begin{lstlisting}[numbers=left]
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

To avoid this, the annotation \lstinline|@SuppressWarnings| with the value “unchecked” can be applied – preferably not to the method as a whole, but only to the problematic assignment, even if this means that an additional temporary variable is required (but not in this sample):
\begin{lstlisting}
// RECOMMENDED
public final Map<K,V> clone()
{
    @SuppressWarnings( "unchecked" ) 
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}

// AVOID!!!
@SuppressWarnings( "unchecked" ) 
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

As there is no rule without exception, here is one: I recommend to use labels to mark long code blocks (refer to the chapters \tqfullref{sec:LabelsAndBreakStatements}, \tqfullref{sec:TrailingOrEndOfLineComments}, and \tqfullref{sec:CommentsWhen}), but if those code blocks do not reference these labels, they may cause an “Unused Label” warning in your IDE. The recommendation is here to deactivate that warning – globally.

\section{Terminating a Method and returning Values}\label{sec:ReturningValues}
A method will have only \textit{one single regular} exit point, and that is (after) its last line! Irregular or \textit{exceptional} exit points are always exceptions that will be thrown as the result of an error condition.

This means that a method, that does not return something, does not have a \lstinline|return| statement.

If there is a \lstinline|return| statement in a method, it is \textit{always} the last statement of the method.

\begin{lstlisting}
// AVOID!!!
public final long myMethod( final int a )
{
    if( a < 0 ) throw new IllegalArgumentException( "a < 0" );
    if( a == 0 ) return 1;
    if( a == 1 ) return 1;
    return a * myMethod( a - 1 );
}   //  myMethod()
\end{lstlisting}

As already said in chapter \tqfullvref{sec:NamesForLocalVariables}, the name of the local variable that holds the return value is always \lstinline|retValue|; only when the method returns an attribute, the field name could be used instead. And it is also not necessary to assign \lstinline|this| to \lstinline|retValue| for method chaining. 

Then the recommended code would be:
\begin{lstlisting}
// RECOMMENDED
public final long myMethod( final int a )
{
    if( a < 0 ) throw new IllegalArgumentException( "a < 0" );
    final var retValue = (a > 1) ? myMethod( a - 1L) : 1L;
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  myMethod()

// Still OK
public final long myMethod( final int a )
{
    if( a < 0 ) throw new IllegalArgumentException( "a < 0" );
    var retValue = 1L;
    if( a > 1 ) retValue = myMethod( a - 1 );
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  myMethod()
\end{lstlisting}

It is much easier to grasp what a method is doing when the program flow is always from top to bottom, and if there are not any side exits (other than the ‘emergency exits’, marked by a \lstinline|throw| statement when issuing an exception.

This will supported by always using the same name for the return value – just that \lstinline|retValue|.

\subsection{Lambda Results}\label{sec:LambdaResults}
Most lambdas are just one liners, and if they return something, it will be the return value of that line:
\begin{lstlisting}
n -> (n + 1) * 4; 
\end{lstlisting}

If the code for the lambda will be more complex, you should consider to place it to a method and
refer to it with a method reference:
\begin{lstlisting}
public final class MyClass
{
    private final String format( final String name )
    {
        final var buffer = new StringJoiner( "}, {", "{", "}" );
        if( nonNull( name ) )
        {
            for( final var s: name.split( " " ) )
            {
                buffer.add( s );
            }
        }
        else
        {
            buffer.setEmptyValue( "No Name" );
        }
        final var retValue = buffer.toString();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  format()
    
    public final String myMethod()
    {
        final var retValue = retrieveNames().stream()
            .map( this::format )
            .filter( n -> !n.equals( "No Name" ) )
            .collect( joining( "}, Name={", "Names={Name={", "}}"
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

Only if a complex lambda needs to refer to local variables, it has to be defined locally:
\begin{lstlisting}
public final class MyClass
{
    public final String myMethod( final String longTemplate, final String shortTemplate, final String nullText )
    {
        final var retValue = retrieveNames().stream()
            .map( n ->
            {
                final var result = nullText;
                if( n != null )
                {
                    result = n.length() > 15 
                        ? longTemplate.formatted( n ) 
                        : shortTemplate.formatted( n );
                }
                return result;
            } )
            .filter( n -> !n.equals( "No Name" ) )
            .collect( joining( "}, Name={", "Names={Name={", "}}"
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}
The lambda cannot use the name \lstinline|retValue| for its return value, because that is already defined in the surrounding method\footnote{And even if it is not (yet) defined, the lambda should not use it anyway, as it may collide with future code modifications.}. Instead, lambdas use the name \lstinline|result| for their return values.

\subsection{“case” Results}\label{sec:CaseResults}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\autocite{ORACLE_DOC_SWITCHEXPRESSIONS}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\lipsum[5]

\begin{lstlisting}
\end{lstlisting}

\section{The Ternary Operator “?”}\label{sec:TheTernaryOperator}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\lipsum[5]

\begin{lstlisting}
\end{lstlisting}

\section{Programming to the Interface}\label{sec:ProgrammingToTheInterface}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\autocite{Cymerman:SmarterJavaDevelopment}
\autocite{Fejer:ProgramToInterfaces}
\autocite{Pavlutin:ProgrammingToInterface}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\lipsum[5]

\begin{lstlisting}
\end{lstlisting}

\section{The "switch" Statement}\label{sec:TheSwitchStatement}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\lipsum[5]
\ref{sec:SwitchStatements}

\begin{lstlisting}
\end{lstlisting}

\section{Encapsulation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Encapsulation with Modules}\label{sec:EncapsulationWithModules}
\subsection{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Lambdas}\label{sec:Lambdas}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Functional Interfaces}\label{sec:FunctionalInterfaces}
\subsection{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{The Interface “java.util.Formattable”}\label{sec:FormattableInterface}
\section{-------------------------------------------- Proceed from here!}

\autocite{ORACLE_DOC_STRING_CLASS}
\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\autocite{ORACLE_DOC_STRINGJOINER_CLASS}
\autocite{ORACLE_DOC_FORMATTER_CLASS}
\autocite{ORACLE_DOC_FORMATTABLE_INTERFACE}

\lipsum[1]

\section{The Interface “java.lang.Comparable”}\label{sec:ComparableInterface}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Utility Classes}\label{sec:UtilityClasses}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{try-with-resources}\label{sec:TryWithResources}
The feature \lstinline|try-with-resources| was introduced with Java~7; it can help to make programs more stable and less error prone.

\subsection{Basics}
Basically, \lstinline|try-with-resources|\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:TryWithResources} is an extension of the previously existing \lstinline|try-catch-finally| feature.

Instead of writing
\begin{lstlisting}[numbers=left]
InputStream input = null;
try
{
    input = new FileInputStream( file );
    …
}
catch( final IOException e )
{
    // Handle the error
}
finally
{
    try
    {
        if( input != null ) input.close();
    }
    catch( final IOException e )
    {
        // Handle the error
    }
}
\end{lstlisting}

the new feature allows you to write

\begin{lstlisting}[numbers=left]
try( final var input = new FileInputStream( file ); )
{
    …
}
catch( final IOException e )
{
    // Handle the error
}
\end{lstlisting}

It works because the interface \lstinline|java.lang.AutoCloseable|\footnote{In fact, \lstinline|InputStream| will still implement just \lstinline|java.io.Closeable|, as already before Java~7, but this interface will now extend the new interface \lstinline|java.lang.AutoCloseable|.} is implemented by the class \lstinline|java.io.InputStream|. For details refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE}.

This interface defines just one method, \lstinline|close()|, that declares to throw an exception of type \lstinline|java.lang.Exception|.

\lstinline|close()| is called automatically on all instances of \lstinline|AutoClosable| that were declared and defined in the ‘arguments list’ of the new \lstinline|try| when the scope of the \lstinline|try| block is left. If there is more than one resource defined, the sequence is reversed to that of the definition: the last assigned resource will be closed first.

So a code snippet to copy data from an input stream to an output stream may look like this\footnote{This is obviously not a very good implementation, but it illustrates how to use \lstinline|try-with-resources| quite well.}:
\begin{lstlisting}[numbers=left]
try
( 
    InputStream input = new FileInputStream( infile );
    OutputStream output = new FileOutputStream( outfile ) 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
\end{lstlisting}
Both streams will be closed properly in case of a problem or the work is done.

\subsection{Error Handling}
What will happen if the code in the \lstinline|try| block throws an exception and closing the resource will throw one, too?

For the ‘traditional’ pattern this could mean that the first exception would be ‘supplanted’ by the exception from the close. For sure, in a \lstinline|catch| block the original cause could be logged, but usually only checked exceptions (and “expected“ ones) are covered this way.

Together with \lstinline|try-with-resources|, a new feature was introduced to the language: the \textit{suppressed} exception. This deals with the problem described above.

So if the \lstinline|try| block throws an exception (for our example, it would be most probably an \lstinline|IOException|) and the \lstinline|AutoCloseable.close()| will fail with an exception, too, the latter one will be added to the first one as a “suppressed exception” by the JVM.

For this purpose, the API of the class \lstinline|java.lang.Throwable| was extended by the methods \lstinline|addSuppressed()| and \lstinline|getSuppressed()|.\footnote{see \autocite{ORACLE_DOC_THROWABLE_CLASS}}

Using \lstinline|Throwable.printStackTrace()| an output like that below will be produced:
\begin{lstlisting}
java.lang.Error
  at TryWithResources.main(TryWithResources.java:175)
  Suppressed: java.lang.Exception
    at TryWithResources$Resource2.close(TryWithResources.java:103)
    at TryWithResources.main(TryWithResources.java:176)
\end{lstlisting}

\subsection{Execution Sequence}\label{sec:ExecutionSequence}
It is important to know how the execution sequence looks like when using \lstinline|try-with-resources|. For the traditional pattern it is\\
\begin{center}
\verb#try{}->[catch{}]->finally{}#
\end{center} 
for \lstinline|try-with-resources| it will be\\ 
\begin{center}
\verb#try{}->AutoCloseable.close()->[catch{}]->[finally{}]#
\end{center}

This means that the method \lstinline|close()| on the \lstinline|AutoClosable| objects will be called \textit{before} any code in an optional \lstinline|catch| and/or \lstinline|finally| block that is attached to the \lstinline|try| block. For the sample we used above this means that the \lstinline|InputStream input| is already closed when the code in the \lstinline|catch| block that handles the \lstinline|IOException| will be executed.

Therefore the code below will not work as expected in case an exception is thrown in the \lstinline|try| block:
\begin{lstlisting}
// WILL NOT WORK!
final var logStream = new FileOutputStream( logfile )
try
(   
    final var input = new FileInputStream( infile );
    final var output = new FileOutputStream( outfile );
    final var log = logStream 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
catch( final IOException e )
{
    logStream.write( "Copy failed!\n".getBytes( UTF8 ) );
    /* Fails because the log file is already closed! */
}
\end{lstlisting}

Refer also to \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ExtendedTryWithResources}.

\subsection{When to use?}
\lstinline|try-with-resources| is a very powerful feature that should be used whenever possible. Definitively it should be used with all the Java classes that already implement \lstinline|java.lang.AutoCloseable| or \lstinline|java.io.Closeable|:

\begin{itemize}
\item{The \lstinline|java.io| streams}
\item{Sockets}
\item{\lstinline|java.sql.Connection|, \lstinline|java.sql.Statement|, \lstinline|java.sql.ResultSet|}
\item{\lstinline|java.jms.Connection|}
\end{itemize}

\subsubsection{Lifecycle}\label{sec:Lifecycle}
In C++, it is a very common pattern to “wrap” the lifecycle of a resource into the lifecycle of an object:
\begin{lstlisting}[language=C++]
class Resource
{
    //---* Attributes *----------------------------------------------
    private:
        RTYPE m_Res;

    //---* Constructors *--------------------------------------------
    public:
        Resource( RTYPE &r )
        : m_Res( r )
        { m_Res.open(); }

    //---* Destructor *----------------------------------------------
    public:
        ~Resource() { m_Res.close(); }

    //---* Methods *-------------------------------------------------
    // Some methods to access the resource
    …
}
\end{lstlisting}
A use of that class might look like this:
\begin{lstlisting}[language=c++]
…
{
    Resource resource( r );

    // Do something
    …
}
…
\end{lstlisting}
The instance of \lstinline|Resource| will be constructed and \lstinline|open()| is called on \lstinline|r| on the declaration of the variable \lstinline|resource|. On leaving the scope the destructor of \lstinline|Resource| is called implicitly and \lstinline|close()| will be called on \lstinline|r|.

The C++~STL is using a very similar pattern for smart pointers.

Unfortunately, Java does not know destructors\footnote{The deprecated method \lstinline|java.lang.Object.finalizer()| that is part of each Java class is not and was never a replacement for or an alternative to a destructor as it could never be predicted when it is called (just “sometime before the JVM terminates” – if ever).}, so this pattern could not be used.

A workaround is to use a \lstinline|try-finally| block with the cleanup (usually a call to \lstinline|close()|) in the \lstinline|finally| block. But to often we have seen that in the run of modifications and/or corrections (refactorings) suddenly the \lstinline|finally| block and/or its contents had been removed (“optimised away”).

Now, with the \lstinline|try-with-resources| feature, we can have “Lifecycle” classes; they are still not that easy to use that with real destructors, but we can come close.

A sample would be the Class \lstinline|AutoLock|; for the full code, see chapter \tqfullvref{sec:AutoLock}; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

In programs that use \lstinline|java.util.concurrent.locks.Lock| or one of its implementations for thread synchronisation, you will find quite often code like this:
\begin{lstlisting}[numbers=left]
m_Lock.lock();
try
{
    // Do something
    …
}
finally { m_Lock.unlock(); }
\end{lstlisting}

This calls for a lifecycle class. Unfortunately the code below will not work, due to several reasons:
\begin{lstlisting}[numbers=left]
// Does not work!!
try( final var unused = new Lock() )
{
    // Do something
    …
}
\end{lstlisting}

First, \lstinline|java.util.concurrent.locks.Lock| will not implement \lstinline|java.lang.AutoCloseable|, and second – much more important – we cannot create a new instance of \lstinline|Lock| each time we enter the critical section.\footnote{Not to mention that \lstinline|java.util.concurrent.locks.Lock| is an interface so that \lstinline|new Lock()| cannot work at all.}

Fortunately, the \lstinline|try-with-resources| feature will not call \lstinline|close()| on the newly created object, but on the local reference (that is the reason why \lstinline|try-with-resources| will not work with anonymous instances like \lstinline|try( new Lock() )|). If we would now wrap the \lstinline|Lock| instance into a class that implements \lstinline|AutoCloseable|, we can write something like this:
\begin{lstlisting}[numbers=left]
…
AutoLock m_AutoLock = new AutoLock( m_Lock );
…
try( final var unused = m_AutoLock.lock() )
{
    // Do something
    …
}
\end{lstlisting}

\subsubsection{Post-Processing}
Together with lambdas, \lstinline|try-with-resources| can be (ab)used also to enforce a unconditional post-processing when a code block is left. This may look like this:
\begin{lstlisting}[numbers=left]
…
Runnable doAfter = …;
…
try( final var p = new PostProcessor( doAfter ) )
{
    // Do whatever necessary
    …
}
\end{lstlisting}
The \lstinline|PostProcessor| instance will call \lstinline|Runnable::run|\autocite{ORACLE_DOC_RUNNABLE:run} in its \lstinline|close()| method when the \lstinline|try| block is left. Chapter \tqfullref{sec:PostProcessor} in the Appendices provides the source for the class.

‘Unconditional’ means here that the post-processing will be executed if the block terminates regularly or by a thrown exception. Other conditions can be injected into the \lstinline|Runnable|\autocite{ORACLE_DOC_RUNNABLE_INTERFACE} implementation.

The difference between this approach and simply calling \lstinline|doAfter.run()| in a \lstinline|finally| block is that the \lstinline|close()| method of \lstinline|PostProcessor| is invoked before any code in a \lstinline|catch| block (refer to chapter \tqfullref{sec:ExecutionSequence}).

The following code snippet could be a real-life example for where this is useful:
\begin{lstlisting}[numbers=left]
final var builder = new StringBuilder();

final Runnable addTrailer = () -> builder.append( "}\n" );

…

try( final var p = new PostProcessor( addTrailer ) )
{
    …
}
\end{lstlisting}
This ensures that the string in \lstinline|builder| always terminates with a closing curly brace followed by a linefeed.

Another sample is this code snippet:
\begin{lstlisting}[numbers=left]
final List<String> list = new LinkedList();

final Runnable forceSorting = () -> list.sort();

…

try( final var p = new PostProcessor( forceSorting ) )
{
    for( final var s : loadStrings() )
    {
        list.add( s );
    }
}
\end{lstlisting}
Here the \lstinline|PostProcessor| forces that the given list is always sorted after the values had been added.

\section{Date and Time Values}\label{sec:DateAndTimeValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Unique Ids}\label{sec:UniqueIds}
Data records stored to a database require a unique identifier in most cases. Sometimes, this identifier is provided externally – a social security number, an account number, or a tax id – but usually not. 

When the database will be accessed (and updated) from different locations, this identifier has to be \textit{universally} unique; alternatively, you can introduce a global service that provides such identifiers. But usually, this does make sense only when these identifiers are not only just technical – like the already mentioned social security numbers, account numbers, or tax ids.

How to get universally unique ids (UUID) is defined in RFC~4122\autocite{Leach:RFC4122}, among others. Java provides an implementation for these UUIDs with the class \lstinline|java.util.UUID|\autocite{ORACLE_DOC_UUID_CLASS}. Unfortunately, the class provides only one method that creates new arbitrary UUIDs (\lstinline|java.util.UUID::randomUUID()|\autocite{ORACLE_DOC_UUID:randomUUID}), and these are version~3 pseudo-random UUIDs.

These are large enough that collisions are unlikely, but when used as primary keys on a database table, the database indexing can get quite inefficient (lack of locality in the indexes). This is discussed in more detail in \autocite{Mihalcea:UUID_Database_Primary_Key}.

Partially, this is addressed by timebased UUIDs (version~1), and new formats will be discussed (see \autocite{Davis:NewUUIDs, Leach:RFC4122bis}), but another issue is that these UUIDs occupy at least 128~bit – when you use the binary format. But usually, the textual representation is used (mainly because the Java class \lstinline|UUID| does not provide a method to get the binary format), and that has even 288~bit (36~bytes or characters). I provide a utility class \lstinline|UniqueIdUtils|\autocite{TQUADRAT_ORG_FOUNDATION_UNIQUEIDUTILS} that provides some tools to address these issues. So it allows you to create timebased UUIDs or to get the binary representation from a UUID.

The already mentioned article in \autocite{Mihalcea:UUID_Database_Primary_Key} suggests to use shorter unique ids that should be timebased; the article refers to a the \verb#TSID_CREATOR# library\autocite{Lima:TSID_CREATOR}, but alternatively, my \lstinline|UniqueIdUtils| do also provide a \lstinline|TSID| type with 64~bit length.

Another issue with UUIDs is that it should not be \textit{too} easy to guess a valid instance. This means that a database sequence\autocite{TOAD_WORLD_BLOG:DatabaseSequence} that just increments a counter in order to get a new identifier is the worst choice in this regard.

\section{Utilising JMX}\label{sec:UtilisingJMX}
\section{-------------------------------------------- Proceed from here!}
See \ref{sec:Logging}, and there the part about warnings! Keeping track about failed logins.!!!
\lipsum[1]


\section{Finalisation}\label{sec:Finalisation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Deprecation of Elements}\label{sec:DeprecationOfElements}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Miscellaneous}
In this chapter I collected some dos and don'ts that do not fit into one of the other chapters, but are not relevant enough for a chapter on there own.

\begin{itemize}
\item{Avoid octal numerical literals in your source code! Although this feature exists since the first versions of Java, it is not very well known.

If you do not know what I talking about: start \verb#jshell#, type in \lstinline|021 + 021| and be surprised that the result is not the ultimate answer to life, the universe, and everything.\autocite{ADAMS_HITCHHIKERS_GUIDE}

Or to summarise it: Do not prefix integer literals with \verb#0#!}

\item{Avoid using an object to access a class (static) variable or method. If you cannot use a static import, refer the element through the class name instead. For example:
\begin{lstlisting}
public final class AClass
{
    public static final void classMethod() { … }
}
//  class AClass

…

import static some.package.AClass.classMethod;

public final class MyClass
{
    public final void myMethod()
    {
        // RECOMMENDED!
        classMethod(); // Using the static import
        
        // OK
        AClass.classMethod();
        
        // AVOID!!
        final var anObject = new AClass();
        …
        anObject.classMethod();
    }   //  myMethod()
}
    //  class MyClass
\end{lstlisting}

You can configure both Eclipse and IntelliJ IDEA to report the access to a static member of a class through an instance as a warning or even as an error.}

\item{In general, static imports are preferred over using the class name as prefix for references to static class members, either to class methods or to constants.}

\item{Try to initialise local variables where they are declared. The only reason not to initialise a variable where it's declared is if the initial value depends on some computation occurring first.}

\item{Avoid the multi-line initialisation for fields; use a constructor instead:
\begin{lstlisting}
public final class MyClass
{
    private final String m_Field;
    // AVOID!!!!!
    {                                                
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }
    
    /**
     *  Creates a new instance for {@code MyClass}.
     */
    public MyClass() 
    {                                                
        // INSTEAD DO IT IN THE CONSTRUCTOR!!
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }   //  MyClass()
}
//  class MyClass    
\end{lstlisting}}

\item{Try to call a method only when its result is needed. This is even more true if the method does not return a value but has other effects.

Although this may seem to be self-evident, you may find often code like this:
\begin{lstlisting}
// AVOID!!!
final var logMessage = composeMessage( params );
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    writeLog( logMessage );
}
…
\end{lstlisting}
or
\begin{lstlisting}
// AVOID!!!
{
    final var param1 = retrieveData( data1 );
    final var param2 = retrieveData( data2 );
    if( option )
    {
        process( param1 );
    }
    else
    {
        process( param2 );
    }
}
\end{lstlisting}
Instead, the samples should look like below:
\begin{lstlisting}
// RECOMMENDED
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    final var logMessage = composeMessage( params );
    writeLog( logMessage );
}

…

// RECOMMENDED
{
    final Data param;
    if( option )
    {
        param = retrieveData( data1 );
    }
    else
    {
        param = retrieveData( data2 );
    }
    process( param );
}
// RECOMMENDED/Using the trinary operator
{
    final var param = option 
        ? retrieveData( data1 )
        : retrieveData( data2 );
    process( param );
}
\end{lstlisting}
}

\item{Avoid anonymous classes! Although it (sometimes) reduces the code to write and the number of source files, it makes the resulting code very hard to read in most cases. And the number of generated class files remains exactly the same, no matter if anonymous classes, inner classes, non-\lstinline|public| or \lstinline|public| classes are used.

In most cases, you can use a lambda instead of an anonymous class.}

\item{If you are using collections or maps, declare and define them with generics.

If a legacy interface returns a collection or map that is not declared with generics, map it. The resulting warning can be suppressed using the \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} annotation.

Sometimes this may require the introduction of a temporary helper variable, as in the last sample, below.

\begin{lstlisting}
// AVOID!!
List x = new LinkedList(); 

// RECOMMENDED!!
List<String> x = new LinkedList<String>(); 

public abstract Vector method1();
public abstract Vector method2() throws IOException;
…
public static final void main( String... args )
{
    @SuppressWarnings( "unchecked" )
    final List<String> method1Result = method1();
    List<String> method2Result = null;
    try
    {
        @SuppressWarnings( "unchecked" )
        final List<String> temporary = method2();
        method2result = temporary;
    }
    catch( final IOException e ) { … }
}   //  main()
\end{lstlisting}}

\item{Using \lstinline|java.lang.Object| as the type parameter for a generic data type is useless in most cases and should be avoided:
\begin{lstlisting}
// AVOID!!!
private final List<Object> m_List = new LinkedList<Object>();
\end{lstlisting}
If you want to declare a variable of a generic type that should work for any parameter class, you have to use the question mark:
\begin{lstlisting}
Class<?> dataClass = data.getClass();
\end{lstlisting}}

\item{The classes \lstinline|java.util.Vector|\autocite{ORACLE_DOC_VECTOR_CLASS} or \lstinline|java.util.Hashtable|\autocite{ORACLE_DOC_HASHTABLE_CLASS} should not be used! Although their implementation had been modernised already with Java~1.2, their performance is still inferior to the alternative implementations, because \lstinline|Vector| and \lstinline|Hashtable| are still synchronised.

For method arguments and return values, you should use the interfaces \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} instead of \lstinline|Vector|, and \lstinline|java.util.Map|\autocite{ORACLE_DOC_MAP_INTERFACE} instead of \lstinline|Hashtable|. Refer also to chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} that elaborates further on this topic.

If you need an implementation of the \lstinline|List| interface, you should prefer \lstinline|java.util.ArrayList|\autocite{ORACLE_DOC_ARRAYLIST_CLASS} over \lstinline|java.util.LinkedList|\autocite{ORACLE_DOC_LINKEDLIST_CLASS}. The latter is only more performant in some very rare cases, and it also has a bigger memory footprint\footnote{Internally, an \lstinline|ArrayList| uses an array for the entries, and when this gets too small, a new array with twice the size will be allocated. This means that for some time two large array will exist. For really, really large lists, this may cause an issue. In the opposite, a \lstinline|LinkedList| will grow entry by entry.}.

Instead of \lstinline|Hashtable|, you should use \lstinline|java.util.HashMap|\autocite{ORACLE_DOC_HASHMAP_CLASS} as the implementation for the \lstinline|Map| interface.

If you really need a synchronised list, you can still consider to use \lstinline|Vector| as your implementation of \lstinline|List|, but for a syncronised implementation of \lstinline|Map|, you should take \lstinline|java.util.concurrent.ConcurrentHashMap|\autocite{ORACLE_DOC_CONCURRENTHASHMAP_CLASS}.}

\item{Use the enhanced \lstinline|for-loop| when iterating over collections\footnote{Ok, only implementations of \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} provide methods for random access.}. It is also preferred when iterating over arrays.

Alternatively, you can use an iterator, the \lstinline|java.lang.Iterable::forEach| method, or the Stream API:
\begin{lstlisting}
// AVOID!
for( var i = 0; i < list.length(); ++i )
{
    process( list.get( i ) );
}

// RECOMMENDED
for( final var element : collection ) process( element );

collection.forEach( this::process );

// OK
for( final var i = collection.iterator(); i.hasNext(); ) process( i.next() );

collection.stream()
    .forEach( this::process );
\end{lstlisting}

The Stream API allows you to filter the elements in the collection.}

\item{Consider to use the varargs feature when a method takes only one single argument, but can be called repeatedly with different arguments, or when it takes an array as argument:

\begin{lstlisting}
public final void addListener( final Listener... listeners ) { … }
\end{lstlisting}

instead of
\begin{lstlisting}
public final void addListener( final Listener listener ) { … }
\end{lstlisting}

Obviously, the implementation now has to deal with multiple entries, but it allows to write
\begin{lstlisting}
addListener( listener1, listener2, listener3 );
\end{lstlisting}
instead of
\begin{lstlisting}
addListener( listener1 );
addListener( listener2 );
addListener( listener3 );
\end{lstlisting}
making the code easier to read.}

\item{Prefer \lstinline|java.lang.CharSequence|\autocite{ORACLE_DOC_CHARSEQUENCE_INTERFACE} over \lstinline|java.lang.String| for the type of method arguments. See also chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} on the topic of argument and return types.}

\item{“Forever” loops should be coded as
\begin{lstlisting}
ForeverLoop: while( true ) 
{ 
    … 
    
    //---* Terminate the loop *--------------------------------------
    if( <condition> ) break ForeverLoop;
}   //  ForeverLoop:
\end{lstlisting} }

\item{Do not use \lstinline|new String()| with a string constant or a string expression as the argument. There are only very few situations where this is useful or necessary, and most of them are related to JNI. Usually \lstinline|new String()| is a waste of memory and computing time, except you use if with a \lstinline|byte|, \lstinline|char| or \lstinline|int| array as the argument. Refer to \autocite{ORACLE_DOC_STRING_CLASS} for the details.}

\item{Some programmers do not like the Autoboxing feature that was introduced with Java~5. It is up to you to use it, or to transform the primitive types explicitly into their corresponding object types and vice versa.\footnote{Nevertheless, you should consider “\ref{lst:ZoP:ExplicitVsImplicit}.~Explicit is better than implicit, and verbosity is your friend” – see chapter \tqvref{sec:TheBasicRule}.}}

\item{If a constructor calls a method of its own class or a superclass, this method has to be \lstinline|static|, \lstinline|private|, or \lstinline|final|\footnote{The important setting is \lstinline|final|, because \lstinline|private| and \lstinline|static| methods are implicitly \lstinline|final|}.

In addition, it may call another constructor of the same or the super class, using \lstinline|this()| or \lstinline|super()|.}

\item{Ensure that the main thread (that one that executes \lstinline|main()|) always dies as the last non-deamon thread.

This means that you should keep a reference of all the threads that your code starts so that you can kill them explicitly before the program terminates.}

\item{Ensure that assertions\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert,ORACLE_DOC_ASSERTIONS} are enabled during testing and disabled in production.

To enable assertions, add \verb#-ea# or \verb#-enableassertions# to the JVM command line.}

\item{Although releasing resources when they are no longer needed is a good idea in most cases, it can cause trouble in rare occasions.

I found a code sequence like this in some real life code:
\begin{lstlisting}
…
}
catch( Exception e )
{
    PrintStream ps = new PrintStream( System.out );
    ps.println( "Error occured" );
    e.printStackTrace( ps );
    ps.close()
}
\end{lstlisting}
This will not only close the \lstinline|PrintStream| \lstinline|ps|, but also the wrapped \lstinline|System.out| stream – with the consequence, that this exception was the last that was displayed on the console (or written to the log output).

So make sure that your code will only cleans up objects that your code is responsible for, either because it created them or the responsibility was clearly delegated to it. In case of a wrapper (like most implementations of \lstinline|java.io.InputStream|, \lstinline|java.io.OutputStream| \lstinline|java.io.Reader| and \lstinline|java.io.Writer|), your code should not call methods like \lstinline|close()| if it is not responsible for the wrapped object, as in most cases the wrapper would delegate them to the wrapped object.

If your code has to provide references to resources to 3\textsuperscript{rd}~party code, you should consider to protect those resources from being freed (if required). For an instance of \lstinline|PrintStream|, this could look like this:
\begin{lstlisting}
…
final var tempStream = new PrintStream( myStream ) 
{
    /**
     *  {@inheritDoc}
     */
    @Override
    public void close() { /* Does nothing! */ }
};
externalMethodWritingToPrintStream( tempStream );
…
\end{lstlisting}}


\item{This is about the usage of “\verb#++#” and “\verb#--#”, because they have both a prefix and postfix notation.

The prefix notation will change the value first and returns the new value, while the postfix version will return the current value and change it afterwards. So the usage of prefix or postfix notation depends from the context.

In case where the return value is not used immediately, it is strongly recommended to use the prefix notation always. This is especially true in \lstinline|for| loops.

Examples:
\begin{lstlisting}
// DISCOURAGED
for( int i = 0; i < max; i++ )
{
    …
}

// RECOMMENDED
for( int i = 0; i < max; ++i )
{
    …
}
\end{lstlisting}

Confessed, this is an \textit{early} optimisation (to avoid “premature”), and most implementations of the Java compiler will translate the postfix version into the same binary code as for the prefix version if the return value is not used\footnote{If not the javac, probably the JIT will do.}. But developing the habit to prefer the prefix notation have no costs, and it may spare some cycles when using other languages than Java, or when the compiler does not optimise.}\label{item:PrefixVsPostfix}

\item{Avoid setting several variables to the same value in a single statement. It is hard to read.

Example:
\begin{lstlisting}
// AVOID!
fooBar.fChar = barFoo.lChar = 'c'; 
\end{lstlisting}
Avoid to use the assignment operator in a place where it can be easily confused with the equality operator. If you really do not see another option, make sure that it cannot be confused.

Example:
\begin{lstlisting}
// AVOID!
boolean flag;
while( flag = !isEmpty() ) { … }
\end{lstlisting}
should be written as
\begin{lstlisting}
boolean flag;
while( (flag = !isEmpty()) == true ) { … }
\end{lstlisting}
if it is really necessary to have the assignment at this place.

As Java do not allow other than boolean expression for conditions, something like
\begin{lstlisting}
// DOES NOT WORK!
while( c++ = --d ) { … }
\end{lstlisting}
is not possible. But a common pattern is
\begin{lstlisting}
BufferedReader reader = …
String line = "";
while( (line = reader.readLine()) != null ) { … }
\end{lstlisting}
Do not use embedded assignments in an attempt to improve run-time performance. This is the job of the compiler. 

Example: 
\begin{lstlisting}
// AVOID!
d = (a = b + c) + r;        
\end{lstlisting}
should be written as 
\begin{lstlisting}
a = b + c;
d = a + r;}
\end{lstlisting}}

\item{It is generally a good idea to use parentheses liberally in expressions involving mixed operators to avoid operator precedence problems. Even if the operator precedence seems clear to you, it might not be to others – you should not assume that other programmers know the precedence rules as good as you do.
\begin{lstlisting}
// AVOID!
if( a == b && c == d ) { … }

// BETTER
if( (a == b) && (c == d) ) { … }
\end{lstlisting}

If an expression containing a binary operator appears before the “\verb#?#” in the ternary “\verb#?:#” operator, it should be parenthesized.
 
Example:
\begin{lstlisting}
(x >= 0) ? x : -x;
\end{lstlisting}
}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}
\end{itemize}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{-------------------------------------------- Proceed from here!}
    • If there is a getter for a field, it should be used even by the methods of the same class. Usually the same yields for setters, but there are exceptions from that rule3, in case a field can be set internally to values that are invalid if set from the outside. In such cases the direct access to the field has to be commented accordingly.
    • 
    • A method or constructor should not have more than 7 (in words: seven) arguments. If you feel inclined to provide more arguments to construct an instance, consider to use an instance of Map instead.
    • Do not use BitFields, at least do not expose them to the API. Although the Java API is using them itself, they are still problematic.
    • Whenever you have to convert a date, time or date-time value to a String that is not primarily meant to be display, used an internal format that is independent from any locale. Our recommendation is to use the ISO 8601 format “YYYY-MM-dd'T'hh:mm:ss.SSS”, normalised to UTC, and to use the class SimpleDateFormat to format the date.4
    • 
    • …





\chapter{Summary}\label{sec:Summary}
Several rules and recommendation in this document, in particular regarding how to apply comments and how to write comments, but also those about to write a method, do require significant additional typing. Java in general has the reputation to be too verbose, and this coding conventions will even add to that.

But from my experience I found that verbosity is your friend!

And if you are afraid of the typing work: as I said already earlier (see chapter \tqref{sec:LengthOfNamesAndUseOfAbbreviations}), you should learn typewriting! For my understanding, someone who does not reach at least 100~CPM\footnote{CPM = “Characters per minute”, or, in German: „Anschläge pro Minute“} should look for a job outside of software development!

Writing code is not the only area where you would benefit from mastering that important skill; it will also help you to write all the other stuff you have to deliver in addition to your code (documentation, meeting notes, emails, specification documents,~…).

\section{How to use this Document?}
First, you can use this document as is! It should work for you, as its predecessors already worked for a bunch of project teams.

But you can also shape it closer to your particular needs, if you want! Replace the examples and the references to my libraries by some that fits better to your project and/or your company.

In particular, for your project, you should elaborate on the following topics:
\begin{itemize}
\item{Chapters \tqfullvref{sec:Projects}, \tqfullvref{sec:Modules}, \tqfullvref{sec:Packages} and \tqfullvref{sec:LibraryFiles}\\
In no particular order:
    \begin{itemize}
    \item{Specify the name your project.}
    \item{Specify format for the names of the library file(s) produced by your project.}
    \item{Specify the names for the modules and packages of your project.}
    \end{itemize}}

\item{Chapters \tqfullvref{sec:Logging} and \tqfullvref{sec:LoggerConfiguration}:
    \begin{itemize}
    \item{Specify the type of the logging framework you use in your product – if any – or if you want to code against SLF4J (or if you do not want to log at all).}
    \item{Specify the names of the loggers.}
    \item{Specify the format for the log messages, in particular for the log levels \verb#DEBUG# and \verb#TRACE# (or \verb#FINE#, \verb#FINER# and \verb#FINEST#, if you are using JDK~Logging).}
    \item{Provide a (default) logging configuration.}
    \item{Optionally, you may remove all references to the logging frameworks and APIs that you do not use in your project.}
    \end{itemize}}
    
\item{Chapter \tqfullvref{sec:TheNamingDictionary}:
    \begin{itemize}
    \item{Add verbs that are specific to your project, remove obsolete/unwanted ones.}
    \item{Adjust the description for verbs where appropriate.}
    \item{Do the same for the class name suffixes.}
    \item{Add a Glossary that explains special terms used in the context of your project (the “Domain Specific Terminology”).}
    \end{itemize}}

\item{Provide code snippets for recurring patterns that are specific to your project.}

\item{Remove this chapter \tqfullref{sec:Summary}.}
\end{itemize}

This document was compiled using \TeX/\LaTeX\footnote{In case it is relevant for you, I used ‘TexMaker’ as the editor for the \LaTeX~sources. I run it on Mac and Linux, but the software is also available for Windows; it can be downloaded from this location: \href{https://www.xm1math.net/texmaker/download.html}{https://www.xm1math.net/texmaker/download.html}.}, and its source can be found on  \href{https://github.com/tquadrat/documents}{GitHub}. Clone the repository and startover!

\chapter{Appendices}

\section{The Naming Dictionary}\label{sec:TheNamingDictionary}
The names of program elements provide an implicit contract (or at least a kind of commitment) between the original author of the program and its users/maintainers. But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts here, together with a list of suffixes for class names.

\subsection{Verbs}
This chapter provides a list of verbs\footnote{Ok, some names or prefixes are not verbs, like ‘main’, ‘from’ or ‘to’~…} to be used with method names and a description of their implicit contract. These verbs are usually prefixes to a method name, although some of them could be used as standalone names, too. The form that used more often is mentioned first.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{Verbs.tbl.tex}

That a method name is built using one of the verbs above does not free you from providing a proper JavaDoc comment that describes the purpose of the method in detail, together with the arguments, return values and exceptions.

\subsection{Suffixes for Class Names}\label{sec:SuffixesForClassNames}
This chapter lists defined suffixes for class names and their function.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{ClassNameSuffixes.tbl.tex}

\section{Configurable Errors and Warnings}\label{sec:ConfigurableErrorsAndWarnings}
A very convenient feature of most IDE's is the capability to configure additional warnings and even errors for the compilation.

\subsection{Eclipse}\label{sec:EclipseErrorsAndWarnings}
tdb

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJErrorsAndWarnings}
tdb

\section{IDE Configuration}\label{sec:IDEConfiguration}
This chapter provides samples of configuration files for some IDEs. See also the chapter \tqvref{sec:ConfigurableErrorsAndWarnings} about the errors and warnings that can be configured in Eclipse and IntelliJ IDEA.

\subsection{Eclipse}\label{sec:EclipseConfiguration}
tbd

\subsubsection{Snippets}
This chapter provides the XML code for Eclipse snippets.

\paragraph{Structuring Comments}\label{sec:SnippetStructuringComments}
The snippets for the structuring comments as defined in chapter \tqfullvref{sec:StructuringComments}.
\begin{lstlisting}[language=XML,basicstyle=\ttfamily\footnotesize]
<?xml version="1.0"
      encoding="UTF-16" 
      standalone="no"?>
<snippets>
    <category filters="*"
              id="category_1145179107125"
              initial_state="0"
              label="Structuring Comments"
              largeicon=""
              smallicon="">
        <description><![CDATA[Structuring Comments as defined by the Code Conventions]]></description>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145232938375"
              label="Enum Declaration"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the enum definition part]]></description>
            <content><![CDATA[        /*------------------*\
    ====** Enum Definitions **=================================================
        \*------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179869843"
              label="Inner Classes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the inner classes part]]></description>
            <content><![CDATA[        /*---------------*\
    ====** Inner Classes **====================================================
        \*---------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251889697104"
              label="Constants"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for constants.]]></description>
            <content><![CDATA[      /*-----------*\
    ====** Constants **========================================================
        \*-----------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251888677777"
              label="Attributes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for attributes.]]></description>
            <content><![CDATA[      /*------------*\
    ====** Attributes **=======================================================
        \*------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179436656"
              label="Static Initialisations"
              largeicon="" smallicon="">
            <description><![CDATA[The header comment for the static initialisations part]]></description>
            <content><![CDATA[        /*------------------------*\
    ====** Static Initialisations **===========================================
        \*------------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180117906"
              label="Constructors"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the constructors part]]></description>
            <content><![CDATA[    	/*--------------*\
    ====** Constructors **=====================================================
        \*--------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180168796"
              label="Methods"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the methods part]]></description>
            <content><![CDATA[    	/*---------*\
    ====** Methods **==========================================================
        \*---------*/
]]></content>
        </item>
    </category>
</snippets>
\end{lstlisting}

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJConfiguration}
tbd

\section{Embedded Code}
Sometimes, it is necessary to embed code inside the Java source code. Most often, these are SQL statements, but sometimes it could be also fragments of HTML or XML documents.

\subsection{Formatting SQL inside Java}\label{sec:FormattingSQLInsideJava}

\subsection{Formatting XML inside Java}\label{sec:FormattingXMLInsideJava}
You should embed only small fragments of an XML document into the Java source; larger fragments and full documents can be handled better when provided as resources.

\subsection{Formatting HTML inside Java}\label{sec:FormattingHTMLInsideJava}
Same as for XML, also only small HTML fragments should be embedded into the Java source code. Anything else should go into a resource file.

\section{The Reason why Prefix Notation should be preferred over Postfix Notation}
At chapter \tqvref{item:PrefixVsPostfix} I recommend to use always the prefix version of an unary operator if the result of the operation is not further used. This has its reason in the implementation for the operators \verb#++# and \verb#--#. As a C++ method, the prefix implementation may look like this:
\begin{lstlisting}[language=C++]
int prefixIncrement( int& n )
{
    n = n + 1;
    return n;
}
\end{lstlisting}
and the postfix version would look like this:
\begin{lstlisting}[language=C++]
int postfixIncrement( int& n )
{
    int oldValue = n;
    n = n + 1;
    return oldValue;
}
\end{lstlisting}
So the postfix version has an additional stack operation that is not necessary if the return value is discarded anyway. This saves only nanoseconds for a single operation, but used in a loop, and in an application server environment, these nanos will sum up to minutes over time.

I confess that there are other possible locations where one can save more CPU cycles, and I also know the advice not to begin too early with optimisations (to “avoid premature optimisation”). My opinion is that this is not an optimisation but a best practice, and that every cycle counts – especially if it is that easy to achieve.

As said also already, most Java compilers (and not only these) will optimise the particular code, but different Java compilers optimises this pattern differently (meaning some even do not touch it – for example that one for the LEGO® Mindstorms Controller~…), and even the runtime optimisation will treat it differently, so just from this point of view I would recommend this simple change of one's personal habits.

\section{Examples}\label{sec:Examples}

\subsection{AutoLock}\label{sec:AutoLock}
This class is a sample implementation of the idea described in chapter \tqfullvref{sec:Lifecycle}, like a PoC; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={AutoLock.java}]{AutoLock.java}

\subsection{Illegal Argument Exceptions}\label{sec:IllegalArgumentExceptions}
As said in chapter \tqfullvref{sec:CheckingMethodParametersAndReturnValues}, a \lstinline|NullPointerException| that is thrown from your code has to be seen as a coding bug: a value was not properly checked before it was used. Nevertheless, values can be \lstinline|null|, for various reasons, and this still can be an error that needs to be signalled.

For that, I suggested a bunch of custom exceptions that are shown here; they are also part of my Foundation Library: for \lstinline|ValidationException| see \autocite{TQUADRAT_ORG_FOUNDATION_VALIDATIONEXCEPTION}, the \lstinline|NullArgumentException| can be found at \autocite{TQUADRAT_ORG_FOUNDATION_NULLARGUMENTEXCEPTION}, the \lstinline|EmptyArgumentException| is documented at \autocite{TQUADRAT_ORG_FOUNDATION_EMPTYARGUMENTEXCEPTION}, and finally the documentation for \lstinline|BlankArgumentException| is at \autocite{TQUADRAT_ORG_FOUNDATION_BLANKARGUMENTEXCEPTION}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={ValidationException.java}]{ValidationException.java}

\lstinputlisting[numbers=left,caption={NullArgumentException.java}]{NullArgumentException.java}

\lstinputlisting[numbers=left,caption={EmptyArgumentException.java}]{EmptyArgumentException.java}

\lstinputlisting[numbers=left,caption={BlankArgumentException.java}]{BlankArgumentException.java}

\subsection{Lazy}\label{sec:Lazy}
The interface \lstinline|Lazy| and the associated implementation \lstinline|LazyImpl| provide a holder for a lazy initialised object instance. The initialisation happens on the first call to the method \lstinline|Lazy::get| through a call to the \lstinline|Supplier| instance the \lstinline|Lazy| instance was created with.

\begin{lstlisting}
public final class MyClass
{
    /**
     *  An attribute of type
     *  {@link AClass}.
     */
    private final Lazy<AClass> m_Attribute;
    
    public MyClass()
    {
        m_Attribute = Lazy.use( ()-> new AClass( this ) );
    }
    
    public final void myMethod()
    {
        m_Attribute.get().aMethod();
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

\lstinline|Lazy| is part of my Foundation Library and can be found at \autocite{TQUADRAT_ORG_FOUNDATION_LAZY}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={Lazy.java}]{Lazy.java}

\lstinputlisting[numbers=left,caption={LazyImpl.java}]{LazyImpl.java}

\subsection{MountPoint}\label{sec:MountPoint}
The annotation \lstinline|@MountPoint| and how to use it is described in the chapters \tqfullvref{sec:NonFinalClasses} and \tqfullvref{sec:NonFinalMethods}.

The annotation is part of my foundation library, refer to \autocite{TQUADRAT_ORG_FOUNDATION_MOUNTPOINT}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={MountPoint.java}]{MountPoint.java}

\subsection{Patch Identification}\label{sec:PatchIdentification}
The chapter \tqfullvref{sec:MaintenanceComments} discussed how to mark areas in the code that has been changed to fix a bug. There I suggested to use annotations for this task.

This can look like this:
\begin{lstlisting}[numbers=left]
@BUG( id  = "BUG-123456", comment = "Introduced base class MyClassBase" )
public final class MyClass extends MyClassBase
{
    @BUG( id = "BUG-100000", comment = "Made generic; added Typ 'String'" )
    @BUG( id = "BUG-100003", comment = "Changed type to 'CharSequence'" )
    private final List<CharSequence> m_Texts = new LinkedList<>();

    @BUG( id  = "BUG-123456", comment = "Introduced base class MyClassBase; calling super()" )
    public MyClass()
    {
        super();
    }   //  MyClass()
    
    @BUG( id = "BUG-100003", comment = "Changed type to 'CharSequence'" )
    @BUG( id = "BUG-100022", comment = "Made generic; changed to 'extends CharSequence'" )
    @BUG( id = "BUG-123456", comment = "Introduced base class MyClassBase; added @Override" )
    @Override
    public final <T extends Charsequence> void addText( final T text ) { … }
}
//  class MyClass
\end{lstlisting}

That the same annotation can be applied multiple times to the same element requires a “container annotation” for that annotation\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:RepeatableAnnotationInterfaces}, but the use of this annotation is implicit.

The annotations \lstinline|@BUG| and \lstinline|@FixList| (the “container annotation”) are part of the Foundation Base project\autocite{TQUADRAT_ORG_FOUNDATION_BASE, TQUADRAT_ORG_FOUNDATION_BUG, TQUADRAT_ORG_FOUNDATION_FIXLIST}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={FixList.java}]{FixList.java}

\lstinputlisting[numbers=left,caption={BUG.java}]{BUG.java}

\subsection{PostProcessor}\label{sec:PostProcessor}
This implementation is basically a PoC; currently it is not part of any library.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={PostProcessor.java}]{PostProcessor.java}

\subsection{ThreadGroup}\label{sec:ThreadGroup}
The class \lstinline|java.lang.ThreadGroup|\autocite{ORACLE_DOC_THREADGROUP_CLASS} provides a method \lstinline|uncaughtException()| that has the same signature as the \lstinline|UncaughtExceptionHandler::uncaughtException|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER:uncaughtException} method.

The method \lstinline|java.lang.ThreadGroup:uncaughtException| is called by the Java Virtual Machine when a thread in this thread group stops because of an uncaught exception, and no specific \lstinline|Thread.UncaughtExceptionHandler|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER_INTERFACE} instance was installed
to that thread.

The default implementation of that method does the following:
\begin{enumerate}
\item{If this thread group has a parent thread group, the \lstinline|uncaughtException()| method of that parent is called with the same two arguments.}
\item{Otherwise, this method checks to see if there is a default uncaught exception handler installed, and if so, its \lstinline|uncaughtException()| method is called with the same two arguments.}
\item{Otherwise, this method determines if the \lstinline|Throwable| argument is an instance of \lstinline|java.lang.ThreadDeath|. If so, nothing special is done.

Otherwise, a message containing the thread's name, as returned from the thread's \lstinline|getName()| method, and a stack backtrace, using the \lstinline|Throwable|'s \lstinline|printStackTrace()| method, is printed to the standard error stream.}
\end{enumerate}

Unfortunately, the class \lstinline|java.lang.ThreadGroup| itself does not provide an API to change the behaviour of its \lstinline|uncaughtException()| method. To do that, you have to override that method in a subclass.

Below you find an implementation of \lstinline|ThreadGroup| that fixes that. A similar class is also part of my Foundation library – see \autocite{TQUADRAT_ORG_FOUNDATION_BASE, TQUADRAT_ORG_FOUNDATION_THREADGROUP}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={ThreadGroupExt.java}]{ThreadGroupExt.java}

\subsection{UnsupportedEnumError}\label{sec:UnsupportedEnumError}
This implemenation of \lstinline|java.lang.Error| is meant to be used in the \lstinline|default| branch of a \lstinline|switch| statement (refer to \tqfullvref{sec:SwitchStatements}), in cases where the selector is an enum.

It will be used like this:
\begin{lstlisting}[numbers=left]
enum Color
{
    RED, BLUE, GREEN, YELLOW
}

Color color = …    

// Traditional switch statement
switch( color )
{
    case RED: …; break;
    case BLUE: …; break;
    case GREEN: …; break;
    case YELLOW: …; break;

    default: throw new UnsupportedEnumError( color );
}

// New switch statement
switch( color )
{
    case RED -> …;
    case BLUE -> …;
    case GREEN -> …;
    case YELLOW -> …;

    default: throw new UnsupportedEnumError( color );
}

// switch expression
var result = switch( color )
{
    case RED -> "Rot";
    case BLUE ->"Blau";
    case GREEN -> "Grün";
    case YELLOW -> "Gelb";

    default: throw new UnsupportedEnumError( color );
}
\end{lstlisting}

Also refer to \autocite{TQUADRAT_ORG_FOUNDATION_UNSUPPORTEDENUMERROR}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={UnsupportedEnumError.java}]{UnsupportedEnumError.java}

\listoftables

\lstlistoflistings

\begin{FlushLeft}
\printbibliography
\end{FlushLeft}

\printindex
\end{document}
