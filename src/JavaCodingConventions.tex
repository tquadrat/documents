%\RequirePackage{lmodern}
\documentclass[11pt,a4paper, titlepage, parskip=half, headsepline, footsepline, cleardoublepage=current, headheight=1cm]{scrbook}
%\usepackage{DejaVuSansMono}
\usepackage{dejavu}
%\usepackage[T1]{fontenc}
\usepackage{scrhack}
\usepackage{graphicx} 
\usepackage[manualmark]{scrlayer-scrpage}
%\usepackage[utf8]{inputenc}
\usepackage{tocbasic}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{eurosym}
\usepackage{ragged2e}
\usepackage{textcomp}
\usepackage{framed}
\usepackage{ltxtable}
\usepackage{filecontents}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,gray]{xcolor}
\usepackage{listings}
\usepackage[inline]{enumitem}
\usepackage{varioref}
\usepackage[iso,english]{isodate}
\usepackage{makecell}
\usepackage[english]{babel}
\usepackage[babel]{csquotes}

\usepackage{lipsum}

\usepackage[style=numeric, urldate=iso, date=iso, seconds=true, backend=biber]{biblatex}
\usepackage{nameref}
\usepackage[colorlinks=true]{hyperref}

\addbibresource{JavaCodingConventions.bib}

\automark[section]{chapter}
\lehead*[]{\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}~~\headmark}
\rohead*[\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}]{\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}}

\lstset{
language=Java,
%morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield},
morekeywords={var,yield},
backgroundcolor=\color[gray]{.9},
frame=single,
framerule=0.2pt,
basicstyle=\ttfamily\footnotesize,
commentstyle=\color[gray]{.2}\itshape,
keywordstyle=\color[gray]{.4}\bfseries,
identifierstyle=\bfseries,
stringstyle=\itshape,
xleftmargin=.2cm,
xrightmargin=.2cm,
breaklines=true,
breakatwhitespace=true,
inputencoding=utf8,
extendedchars=true,
literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
  {©}{{\copyright}}1
  {…}{{\dots }}2
  {–}{{--}}1
}

\colorlet{shadecolor}{gray!10}
\makeindex

%---* New Commands *-----------------------------------------------------------
\newcommand*{\tqfullref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”}}
\newcommand*{\tqfullvref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”} on page \pageref{#1}}
\newcommand*{\tqref}[1]{\hyperref[{#1}]{\ref*{#1}}}
\newcommand*{\tqvref}[1]{\hyperref[{#1}]{\ref*{#1}} on page \pageref{#1}}

\dedication{For Rasa Kuodienė: She deserved better~… in life and in death \newline\newline\includegraphics[height=14cm]{Rasa} \newline*1969-07-13 †2022-12-21}

\begin{document}
\isodate
\titlehead{\includegraphics[height=4cm]{Logo_gross}}
\author{Thomas Thrien\\(thomas.thrien@tquadrat.org)}
\title{Extended Coding Conventions for Java}
\subtitle{Coding and Formatting Guidelines, Recommendations and Best Practices}
\date{\today}
\maketitle
\tableofcontents

\include{1_Introduction}
\include{2_FormattingTheSourceCode}
\include{3_NamingConventions}
\include{4_WritingProperComments}

\chapter{Coding Guidelines}\label{sec:CodingRules}
These guidelines are a collection of coding standards and best practices. Obeying them should make your code better readable and less error prone. Some of them will even help to increase the program's overall performance. So perhaps you should see them not as optional, but more as obligatory rules.

As always there may be good reasons to do it different from what is recommended or even requested by the guidelines\footnote{You remember the bullet points~\ref{lst:ZoP:SpecialCases} and \ref{lst:ZoP:Practicality} from the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython, PYTHON_ORG_MAILING_LIST:ThePythonWay} that I quoted in chapter \tqvref{sec:OtherProgrammingLanguages}? If not, here are they again: “\ref{lst:ZoP:SpecialCases}~Special cases aren't special enough to break the rules~…” and “\ref{lst:ZoP:Practicality}~…~although practicality beats purity”.}. In such case a comment is required that describes that reason.\footnote{Omitting this comment is also a deviance from the rule, requiring a comment to explain it. Also known as the Catch~22\autocite{WIKIPEDIA:Catch22}.}

One basic recommendation is that you should not write the same code over and over again. This is also known as the “DRY Principle” (“Don't Repeat Yourself”) and we will discuss this later again.

And please keep in mind that not always the shortest, most compact source code is the best. Also avoid what is known as “Premature Optimization”\footnote{Donald E. Knuth made the following statement on optimisation: “We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil.”\autocite{Knuth:PrematureOptimization}}. Modern optimising compilers and run-time optimisers do a very good job to create compact object code, so in most cases the programmer can concentrate fully on writing readable and comprehensible code. In this context I would like to remind you on the quotation from Martin Fowler's book that I put in front of this document, and again to the “Zen of Python”, here the points “\ref{lst:ZoP:SimpleVsComplex}.~Simple is better than complex” and “\ref{lst:ZoP:ComplexVsComplicated}.~Complex is better than complicated”.\footnote{Yes, I know: for a document about Java Coding Conventions, there is an astonishing amount of references to Python~…}

But although optimisation still may have some limits, comments will have never any impact on the runtime performance of a program. So please refer to chapter \tqfullvref{sec:CommentsWhen} (if not done already) and see the recommendations on when to apply comments to your code.

\subsubsection{Types of Products}\label{sec:TypesOfProducts}
Some of the coding guidelines below are different for the type of product or project you are working on. Basically, we can distinguish the following types that will be explained in the following chapters\footnote{If you miss the terms ‘Framework’ and ‘Server’ on the list above: a \textit{Framework} is in this regard a \textit{Feature Library}, and a \textit{Server} is a \textit{Standalone Application} (what else could a server be?).}:
\begin{itemize}[nosep]
\item{Function Libraries}
\item{Feature Libraries}
\item{Tools}
\item{Standalone Applications}
\item{Server-based Applications}
\item{Extensions}
\end{itemize}
The individual types cannot be clearly distinguished one from another, there are some overlappings and gray areas. So when applying a guideline, you still have to use your judgement which implementation really fits for \textit{your project}.

\paragraph{Function Library}\label{sec:FunctionLibrary}
A function library is a collection of functions (often organised in utility classes – refer to chapter \tqvref{sec:UtilityClasses}) and helper classes. A function library does not have a state or requires an initialisation or configuration.

Samples are my Foundation Util library\autocite{TQUADRAT_ORG_FOUNDATION_UTIL}, the Commons Lang library from the Apache Commons project\autocite{APACHE_COMMONS_LANG}, or Google Guava\autocite{GOOGLE_GUAVA}.

My JavaComposer library\autocite{TQUADRAT_ORG_FOUNDATION_JAVACOMPOSER} is a sample for the beforementioned ‘gray area’: I decided to treat it as a function library, but it could have been a feature library, too. The various XML parsers and JSON parsers/generators will also belong to this gray area. 

\paragraph{Feature Library}\label{sec:FeatureLibrary}
A feature library adds a service or a complex functionality to your application. Quite often that functionality runs in its own thread(s) and is accessed like an external service, it has its own configuration and initialisation.

Sometimes these libraries can even be started standalone.

Samples for this are the various JDBC drivers, the H2 Database Engine\autocite{H2_DATABASE}, ActiveMQ\autocite{APACHE_ACTIVEMQ}, Jetty\autocite{ECLIPSE_JETTY}, or Hibernate\autocite{HIBERNATE_ORM}.

In the gray area here I would place JUnit\autocite{JUNIT5} and Log4j\autocite{APACHE_LOG4J}.

\paragraph{Tool}\label{sec:Tool}
A tool in this context is a program that is started, performs a single task and terminates afterwards. Most probably it will be invoked from the command line, and it will not have a UI, but takes all input data somehow from the command line. Perhaps it may even work as a filter\autocite{WIKIPEDIA:Filter}, reading from standard input and writing to standard output.

Programs like \verb#ls# or \verb#grep# belongs to this type, although they are of course not written in Java.

Gray area candidates are \verb#awk# and also \verb#sed#, but even \verb#javac#, the Java compiler, or \verb#javadoc#.

\paragraph{Standalone Application}\label{sec:StandaloneApplication}
A standalone application will run indefinitely (meaning until deliberately terminated by the user) and takes input continuously. Samples are a text editor, an IDE, an application server like WebSphere\autocite{IBM_WEBSPHERE} or a web container like Tomcat\autocite{APACHE_TOMCAT}.

\paragraph{Server-based Application}\label{sec:ServerbasedApplication}
Server-based applications are applicationn that require a special environment to be executed; the best example are JEE applications that need an application server like JBoss\autocite{REDHAT_JBOSS}, WebLogic\autocite{ORACLE_WEBLOGIC} or WebSphere\autocite{IBM_WEBSPHERE}, and web applications, requiring Tomcat\autocite{APACHE_TOMCAT} or any of the appservers mentioned before.

In this case, the program code has to follow several special rules, determined by the server environment. On the other side the enviroment provides several services that can be used by the application.

Other samples are Maillets for James\autocite{APACHE_JAMES} or the customisations (“mods”) for Minecraft\autocite{MINECRAFT} (although these could be regarded both as the gray area candidates here, because both could be seen also as extensions).

\paragraph{Extension}\label{sec:Extension}
An extension or a plugin requires also an environment to run in, but it is not an application as such. It just changes the behaviour of that environment. Annotation processors are samples for this (they change the behaviour of the Java compiler), as well as Maven\autocite{APACHE_MAVEN} plugins.

\include{5_CodingGuidelines_ErrorHandling}

\section{Checking Method Parameters and Return Values}\label{sec:CheckingMethodParametersAndReturnValues}
A \lstinline|NullPointerException| that is thrown by your code indicates a serious bug: it reveals that either a method argument or a return value was not properly checked before it was further used.

Your code should never throw a \lstinline|NullPointerException|!\footnote{And, of course, it should also never catch it. A \lstinline|NullPointerException| should be treated like an \lstinline|Error|.} Nevertheless, values can still be \lstinline|null|, for various reasons, and if this is indicating an error condition, this has to be signalled.

Consequently, you need to check the arguments for each and every method and constructor. But as these checks are not for free, it could be acceptable to omit these checks for \lstinline|private| methods and constructors, when the caller guarantees that the arguments are valid. But even then you should consider to check the arguments with assertions\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert, ORACLE_DOC_ASSERTIONS}, at least for methods (for constructors that calls to \lstinline|this()| or \lstinline|super()|, this has to be the very first statement; no \lstinline|assert| statement can be placed before it).

\begin{lstlisting}
public final class MyClass
{
    private MyClass( final String value )
    {
        assert nonNull( value ) : "value is null";
        
        m_Value = value;
    }   //  MyClass()
    
    private final void myMethod( final String value )
    {
        assert nonNull( value ) : "value is null";
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
    
    public static final MyClass myFactory( final String value1, final String value2 )
    {
    	final var retValue = nonNull( value1 ) ? new MyClass( value1 ) : null;
    	if( nonNull( retValue ) && nonNull( value2 ) ) retValue.myMethod( value2 );
    }   //  myFactory()
}
//  class MyClass
\end{lstlisting}
As said in the Java Language Specification\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert}:
\begin{quotation}
“[Because they can be disabled], assertions should not be used for argument checking in \lstinline|public| methods. Argument checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled.

A secondary problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception […]. An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate. It is intended that \lstinline|AssertionError| never be caught, but it is possible to do so, thus the rules for \lstinline|try| statements should treat assertions appearing in a \lstinline|try| block similarly to the current treatment of throw statements.”
\end{quotation}

You can also delegate the argument check to another method:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
    
    public static final MyClass myFactory( final String value1, final String value2 )
    {
    	//---* Null check is done by constructor *----------------------
    	final var retValue = new MyClass( value1 );
    	
    	//---* Null check is done by myMethod() *-----------------------
    	retValue.myMethod( value2 );
    }   //  myFactory()
}
//  class MyClass
\end{lstlisting}

In case the problematic \lstinline|null| value is an argument to a method or to a constructor, you should throw an \lstinline|java.lang.IllegalArgumentException|\autocite{ORACLE_DOC_ILLEGALARGUMENTEXCEPTION_CLASS}:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

As this check is quite common, I suggest to create a custom exception for this purpose: \lstinline|NullArgumentException|, extending \lstinline|java.lang.IllegalArgumentException|; chapter \tqvref{sec:IllegalArgumentExceptions} provides sample implementations for this and the other exceptions discussed here. With that the sample looks like this:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

You may have noticed that I always use \lstinline|isNull()|\autocite{ORACLE_DOC_OBJECTS:isNull} and \lstinline|nonNull()|\autocite{ORACLE_DOC_OBJECTS:nonNull}\footnote{Both methods are defined in the class \lstinline|java.util.Objects|\autocite{ORACLE_DOC_OBJECTS_CLASS} that will be discussed in more detail later in this chapter.} instead of \lstinline|… == null| and \lstinline|… != null|. I think that the method calls are easier to read than the \verb#==# and \verb#!0# operators.

Foreign code will still throw a \lstinline|NullPointerException| if called with \lstinline|null|, but we are not allowed to catch that …

This means that we have to check the values before we call that foreign code. That's easy for a method, we already check all arguments. But what if we have to call the constructor of a super class?
\begin{lstlisting}
public final class MyClass extends ForeignClass
{
    public MyClass( final String value )
    {
        // WILL NOT COMPILE!!
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        super( value );
    }   //  MyClass()
}
//  class MyClass
\end{lstlisting}

The solution is to have a method that is doing the \lstinline|null| and throwing the \lstinline|NullArgumentException| if that fails. Then our sample may look like this:

\begin{lstlisting}
public final class MyClass extends ForeignClass
{
    public MyClass( final String value, final Data data )
    {
        super( requireNonNullArgument( data, "data" ) );
        
        m_Value = requireNonNullArgument( value, "value" );
    }   //  MyClass()
    
    public final void myMethod( final String value, final Data data )
    {
        if( requireNonNullArgument( value, "value" ).equals( m_Value ) && requireNonNullArgument( data, "data" ).equals( getData() ) )
        {
            …
        }
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

The method \lstinline|requireNonNullArgument()| looks like this\footnote{This one and the other methods in this chapter are implemented in the class \lstinline|org.tquadrat.foundation.lang.Objects|\autocite{TQUADRAT_ORG_FOUNDATION_OBJECTS} that also provides reimplementations of the methods from \lstinline|java.util.Objects|.}:
\begin{lstlisting}[numbers=left,caption={requireNonNullArgument()}]
/**
 *  Checks if the given argument {@code a} is {@code null} and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}.
 *
 *  @param  <T> The type of the argument to check.
 *  @param  a   The argument to check.
 *  @param  name    The name of the argument; this is used for the 
 *      error message.
 *  @return The argument if it is not {@code null}.
 *  @throws NullArgumentException   {@code a} is {@code null}.
 */
public static final <T> T requireNonNullArgument( final T a, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );
    if( isNull( a ) ) throw new NullArgumentException( name );

    //---* Done *----------------------------------------------------
    return a;
}   //  requireNonNullArgument()
\end{lstlisting}

In general, it is a good idea to check the arguments for a method or a constructor is as soon as possible, but is needs to be checked latest before it is used in some way.

We can check an argument for being empty, and Strings can be even tested for being blank, in the same way as for the null check:
\begin{lstlisting}[numbers=left,caption={requireNotEmptyArgument()}]
/**
 *  <p>{@summary Checks if the given argument {@code arg} is 
 *  {@code null} or empty and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}, or an
 *  {@link EmptyArgumentException}
 *  if it is empty.}</p>
 *  <p>Strings, arrays, instances of
 *  {@link java.util.Collection} and
 *  {@link java.util.Map}
 *  as well as instances of
 *  {@link java.lang.StringBuilder},
 *  {@link java.lang.StringBuffer},
 *  and
 *  {@link java.lang.CharSequence}
 *  will be checked on being empty.</p>
 *  <p>For an instance of
 *  {@link java.util.Optional},
 *  the presence of a value is checked in order to determine whether
 *  the
 *  {@link Optional} is empty or not.</p>
 *  <p>Because the interface
 *  {@link java.util.Enumeration}
 *  does not provide an API for the check on emptiness
 *  ({@link java.util.Enumeration#hasMoreElements() hasMoreElements()}
 *  will return {@code false} after all elements have been taken from
 *  the {@code Enumeration} instance), the result for arguments of
 *  this type has to be taken with caution.</p>
 *  <p>For instances of
 *  {@link java.util.stream.Stream},
 *  this method will only check for {@code null} (like
 *  {@link #requireNonNullArgument(Object,String)}.
 *  This is because any operation on the stream itself would render 
 *  it unusable for later processing.</p>
 *  <p>In case the argument is of type
 *  {@link Optional},
 *  this method behaves different from
 *  {@link #requireNotEmptyArgument(Optional,String)};
 *  this one will return the {@code Optional} instance, while the
 *  other method will return the contents of the 
 *  {@code Optional}.</p>
 *  <p>This method will not work properly for instances of
 *  {@link java.util.StringJoiner}, because its method
 *  {@link java.util.StringJoiner#length() length()}
 *  will not return 0 when a prefix, suffix, or an
 *  &quot;{@linkplain java.util.StringJoiner#setEmptyValue(CharSequence) 
 *  empty value}&quot; was provided.</p>
 *
 *  @param  <T> The type of the argument to check.
 *  @param  arg The argument to check; may be {@code null}.
 *  @param  name    The name of the argument; this is used for the 
 *      error message.
 *  @return The argument if it is not {@code null} or empty.
 *  @throws NullArgumentException   {@code arg} is {@code null}.
 *  @throws EmptyArgumentException   {@code arg} is empty.
 */
public static final <T> T requireNotEmptyArgument( final T arg, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );

    switch( arg )
    {
        /*
         * When using guarding expressions, the code would not get
         * better to read and to understand, as the positive cases
         * will be handled all by the default case then.
         */
        case null -> throw new NullArgumentException( name );
        case CharSequence charSequence ->
        {
            if( charSequence.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Collection<?> collection ->
        {
            if( collection.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Map<?,?> map ->
        {
            if( map.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Enumeration<?> enumeration ->
        {
            /*
             * The funny thing with an Enumeration is that it could 
             * have been not empty in the beginning, but it may be 
             * empty (= having no more elements) now.
             * The good thing is that Enumeration.hasMoreElements() 
             * will not change the state of the Enumeration - at 
             * least it should not do so.
             */
            if( !enumeration.hasMoreElements() ) throw new EmptyArgumentException( name );
        }
        case Optional<?> optional ->
        {
            if( optional.isEmpty() ) throw new EmptyArgumentException( name );
        }
        default ->
        {
            if( arg.getClass().isArray() )
            {
                if( Array.getLength( arg ) == 0 ) throw new EmptyArgumentException( name );
            }
            else
            {
                /*
                 * Other data types are not further processed; in
                 * particular, instances of Stream cannot be checked 
                 * on being empty. This is because any operation on 
                 * the Stream itself will change its state and may 
                 * make the Stream unusable.
                 */
            }
        }
    }

    //---* Done *----------------------------------------------------------
    return arg;
}   //  requireNotEmptyArgument()
\end{lstlisting}

\begin{lstlisting}[numbers=left,caption={requireNotBlankArgument()}]
/**
 *  <p>{@summary Checks if the given String argument {@code arg} is
 *  {@code null}, empty or blank and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}, an
 *  {@link EmptyArgumentException}
 *  if it is empty, or a
 *  {@link BlankArgumentException}
 *  if it is blank.}</p>
 *
 *  @param  <T> The type of the argument to check.
 *  @param  arg The argument to check; may be {@code null}.
 *  @param  name    The name of the argument; this is used for the
 *      error message.
 *  @return The argument if it is not {@code null}, empty or blank.
 *  @throws NullArgumentException   {@code arg} is {@code null}.
 *  @throws EmptyArgumentException   {@code arg} is empty.
 *  @throws BlankArgumentException   {@code arg} is blank.
 *
 *  @see    String#isBlank()
 */
public static final <T extends CharSequence> T requireNotBlankArgument( final T arg, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );

    switch( arg )
    {
        case null -> throw new NullArgumentException( name );
        case String string ->
        {
            if( string.isEmpty() ) throw new EmptyArgumentException( name );
            if( string.isBlank() ) throw new BlankArgumentException( name );
        }
        case CharSequence charSequence ->
        {
            if( charSequence.isEmpty() ) throw new EmptyArgumentException( name );
            if( charSequence.toString().isBlank() ) throw new BlankArgumentException( name );
        }
    }

    //---* Done *----------------------------------------------------------
    return arg;
}   //  requireNotBlankArgument()
\end{lstlisting}

The classes \lstinline|java.util.Objects|\autocite{ORACLE_DOC_OBJECTS_CLASS} and \lstinline|org.tquadrat.foundation.lang.Objects|\autocite{TQUADRAT_ORG_FOUNDATION_OBJECTS} provide a bunch of additional methods that can help with the validation of arguments.

Beside the arguments to a method or constructor, you also have to check the values that are returned by a method call, at least that they are not \lstinline|null|. But don't be paranoid: if the specification of the called method clearly declares that the method will not return \lstinline|null|, you should trust it\footnote{Although you can still add an \lstinline|assert| statement to ensure that.}

The methods in your code should \textit{never} return \lstinline|null|, at least not those methods that are published as the API of your class.\footnote{Nevertheless, when you are implementing a (3\textsuperscript{rd} party) interface that requests a return value of \lstinline|null| under some conditions, you have to obey that requirements.} Instead, they should return an instance of \lstinline|java.util.Optional|\autocite{ORACLE_DOC_OPTIONAL_CLASS}.

Additionally, the classes \lstinline|java.util.OptionalInt|\autocite{ORACLE_DOC_OPTIONALINT_CLASS}, \lstinline|java.util.OptionalLong|\autocite{ORACLE_DOC_OPTIONALLONG_CLASS} and \lstinline|java.util.OptionalDouble|\autocite{ORACLE_DOC_OPTIONALDOUBLE_CLASS} can help you to avoid “magic numbers” as return values, indicating special results. And still no \lstinline|null|~…

\section{Extending Classes, Overriding Methods}\label{sec:ExtendingClassesOverridingMethods}
This chapter provides some hints for the design and implementation of classes and methods that should be/can be extended. This is basically relevant for libraries, but also for applications that should be customisable in some way and therefore providing an API.

\subsection{“final” for Classes and Methods}
Each non-\lstinline|private| method, that is not explicitly meant to be overridden by an extending class has to be \lstinline|final|. Each non-\lstinline|final| class is implicitly meant to be extended – even if it contains only \lstinline|final| methods.

Non-\lstinline|final| methods require a comment about when and how they can be overridden, and if the super implementation has to be called, and when. On how to write the comments for classes and methods, refer to the respective chapters \tqvref{sec:ClassComment} and \tqvref{sec:MethodComment}.

\lstinline|private| and \lstinline|static| methods are implicitly \lstinline|final|. Nevertheless, they will be marked as \lstinline|final|, too, although that is redundant.

\subsection{Non-“final” Classes}\label{sec:NonFinalClasses}
As already said above, each non-\lstinline|final| class is implicitly meant to be extended. This means, it has to be designed in a way that supports that extension, and it has to provide proper documentation on how to implement the extension and when.

Only when the class is \lstinline|sealed|\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:SealedClasses, ORACLE_DOC_LANGUAGE_SPECIFICATION:SealedInterfaces}, this is obsolete: for a \lstinline|sealed| class (and for a \lstinline|sealed| interface), all implementations has to be provided by you. This is discussed further in chapter \tqvref{sec:EncapsulationWithModules}.

Unfortunately it is difficult to provide a globally valid recipe for extensible classes. In general, such a class should provide some so called ‘mount points’ or ‘extension points’ where the behaviour could be changed or added. This could be an \lstinline|abstract| method, an empty, non-\lstinline|final| place holder method, or a non-\lstinline|final| method providing some default behaviour. Such a method should be marked with the annotation \lstinline|@Mountpoint|\footnote{Refer to chapter \tqvref{sec:MountPoint} for an implementation of the Annotation.} (if not \lstinline|abstract| or part of an interface), to indicate that you have not just forgotten to add the \lstinline|final| keyword.

An extensible class can also provide useful and/or convenience functionality as \lstinline|protected final| methods. 

Although \textit{it is not recommended}, an extensible class can even provide direct access to fields by declaring them \lstinline|protected| instead of \lstinline|private|.

\subsection{Non-“final” Methods}\label{sec:NonFinalMethods}
A method will be overridden to change the behaviour of an extended class, compared with its base class. The method either has already a behaviour, or it is empty, doing nothing\footnote{…~or it is \lstinline|abstract|, but that is another pattern.}.

In the latter case, it is very likely that this method was already added to design an extendable class.

In the other case, the new method's behaviour will completely replace that of the original one with new functionality. If this is not possible – meaning that some of the original method's functionality has to be kept, this needs to be described in the documentation comment for that method. Or, even better, you should change the design of your class to use the Template Method Pattern\autocite{Gamma:DesignPatterns}.

Assume your class has to implement the following process:
\begin{enumerate}
\item{Initialisation}
\item{Gathering data}
\item{Validate the input data}
\item{Filtering the input data}
\item{Processing the data}
\item{Formatting the output data}
\item{Cleanup and housekeeping}
\item{Writing the output}
\end{enumerate}

Your first, naïve implementation looks like this:
\begin{lstlisting}[numbers=left]
public class MyClass
{
    public String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final String inputData;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            inputData = readStream( inputFile );
        }
        
        //---* Validate and filter the data *------------------------
        final var filteredData = … // Do something with inputData
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = … // Do something with resultData
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}
Works! Job done! Until your project manager returns to you with the requirement that the input data should be taken alternatively from other source that just a file, that different filter schemes are possible, and that the output format has to be customisable. But the initialisation step, the validation and the housekeeping are fine~…

Ok, the method \lstinline|MyClass::process| is not final, you override it:

\begin{lstlisting}[numbers=left]
public class CustomClass extends MyClass
{
    public String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final String inputData;
        try( final var inputFile = new FileInputStream( new URL( "192.168.0.1" ).openStream() )
        {
            inputData = readStream( inputFile );
        }
        
        //---* Validate and filter the data *------------------------
        final var filteredData = … // Do something with inputData
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = … // Do something else with resultData
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class CustomClass
\end{lstlisting}

But obviously, this is not the solution … so you modify the original class:
\begin{lstlisting}[numbers=left]
public class MyClass // Second attempt
{
    /**
     *  Validate and filters the input data. Usually, no filtering should
     *  be required.
     *  An implementation of this method in a subclass needs to call this
     *  implementation in order to validate the data.
     *  
     *  @param  data    The raw input data.
     *  @param  context The process context.
     *  @return	The validated and filtered data.
     *  @throws IllegalArgumentException  The input data is invalid.
     */
    @MountPoint 
    protected String filterData( final String data, final ProcessContext context )
    {
        if( /* data is not valid */ ) throw new IllegalArgumentException();
        
        //---* Done *------------------------------------------------
        return data;
    }   //  filterData()
    
    /**
     *  Formats the output data.
     * 
     *  @param  data    The data to prepare for the output.
     *  @param  context The process context.
     *  @return	The formatted data.
     */
    @MountPoint
    protected String formatData( final String data, final ProcessContext context )
    {
        final var retValue = … // Do something with data
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  formatData()
    
    /**
     *  Obtains the input data from somewhere; the default 
     *  implementation reads it from the file {@code inputFileName}.
     *
     *  @return The input data.
     *  @throws IOException An I/O error occurred while gathering the 
     *      data.
     */
    @MountPoint
    protected String obtainInputData() throws IOException
    {
        final String retValue;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            retValue = readStream( inputFile );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  obtainInputData()
        
    public final String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final var inputData = obtainInputData();
        
        //---* Validate and filter the data *------------------------
        final var filteredData = filterData( inputData, context );
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = formatData( resultData, context );
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}

Looks good now! Tests were successful! Job done!

Your colleagues implemented some custom classes extending your class, and basically, all is fine. Just once in a blue moon, the programs using one of the custom classes crashes spectacularly.

When you look into the the source, you found this implementation for \lstinline|filterData()|
\begin{lstlisting}
protected final String filterData( final String data, final ProcessContext context )
{
    final var validData = super.filterData( data, context );
    
    final var retValue = … // Do some filtering on validData
        
    //---* Done *----------------------------------------------------
    return retValue;
}   //  filterData()
\end{lstlisting}

This was not what you meant! It should be, to ensure that \textit{after} filtering the data is valid:
\begin{lstlisting}
protected final String filterData( final String data, final ProcessContext context )
{
    final var filteredData = … // Do some filtering on data
    final var retValue = super.filterData( filteredData, context );
        
    //---* Done *----------------------------------------------------
    return retValue;
}   //  filterData()
\end{lstlisting}

But your colleagues says that they have to check the input data – and it seems that they are right! But the data has to be checked after the filtering again~…

So you modified your base class once more:
\begin{lstlisting}[numbers=left]
public class MyClass // Third attempt
{
    /**
     *  Filters the input data. This implementation does nothing.
     *  
     *  @param  data    The raw input data.
     *  @param  context The process context.
     *  @return	The filtered data.
     */
    @MountPoint 
    protected String filterData( final String data, final ProcessContext context )
    {
        /* Does nothing */
        
        //---* Done *------------------------------------------------
        return data;
    }   //  filterData()
    
    /**
     *  Formats the output data.
     * 
     *  @param  data    The data to prepare for the output.
     *  @param  context The process context.
     *  @return	The formatted data.
     */
    @MountPoint
    protected String formatData( final String data, final ProcessContext context )
    {
        final var retValue = … // Do something with data
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  formatData()
    
    /**
     *  Obtains the input data from somewhere; the default 
     *  implementation reads it from the file {@code inputFileName}.
     *
     *  @return The input data.
     *  @throws IOException An I/O error occurred while gathering the 
     *      data.
     */
    @MountPoint
    protected String obtainInputData() throws IOException
    {
        final String retValue;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            retValue = readStream( inputFile );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  obtainInputData()
        
    /**
     *  Validates the input data.
     *  
     *  @param  data    The input data.
     *  @param  context The process context.
     *  @throws IllegalArgumentException  The input data is invalid.
     */
    private final void validateData( final String data, final ProcessContext context )
    {
        if( /* data is not valid */ ) throw new IllegalArgumentException();
    }   //  validateData()
    
    public final String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final var inputData = obtainInputData();
        
        //---* Validate and filter the data *------------------------
        validateData( inputData );
        final var filteredData = filterData( inputData, context );
        if( !inputData.equals( filteredData ) ) validateData( filteredData );
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = formatData( resultData, context );
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}

Now \lstinline|filterData()| does only filter data, it is no longer responsible for the validation, too. And the default implementation of that method is now empty.

So you have basically the following options:
\begin{itemize}
\item{The method (and the base class) is \lstinline|abstract|; this forces that any instantiable implementation (any non-\lstinline|abstract| subclass) is required to implement that method.}
\item{The method does nothing (the method body is empty or contains only a return statement) and can be implemented to add functionality if needed/desired.}
\item{The method provides a default behaviour that can be \textit{completely} replaced in a subclass.}
\end{itemize}

You should avoid the \textit{requirement} to call the super implementation of the overriden method, by all means! But if you cannot avoid it, provide a detailed comment on how this has to be done!

That does not mean that an overriding method is not allowed to call the super implementation! Assume that in the sample above, the method \lstinline|MyClass::formatData| is more or less doing what you want, but there is just one caption that you want to have different. Then a completely legal implementation for \lstinline|CustomClass::formatData| could look like this:
\begin{lstlisting}
/**
 *  {@inheritDoc}
 */
@Override
protected final String formatData( final String data, final ProcessContext context )
{
	final var formattedData = super.formatData( data, context );
    final var retValue = formattedData.replace( "Caption:", "Description:" );
       
    //---* Done *------------------------------------------------
   return retValue;
}   //  formatData()
\end{lstlisting}

And before it gets lost: each overriding method has to be annotated with the \lstinline|@Override| annotation\autocite{ORACLE_DOC_OVERRIDE_ANNOTATION}, no matter it was declared in a class or in an interface. Usually, you can use just \verb#{@inheritDoc}# as the documentation for that method.

\subsection{Adapter Classes}\label{sec:Adapter}
An adapter class implements an interface with mainly optional methods; all methods in the class are empty. In addition, an adapter class does not define any attributes\footnote{Otherwise, it would need at least accessor and probably also mutator methods for these attributes that could not be empty.}. A sample for that pattern is the class \lstinline|java.awt.event.KeyAdapter|; it implements the interface \lstinline|java.awt.event.KeyListener|.

This is used like this:
\begin{lstlisting}
public final class MyClass 
{
    public static final void main( final String... args ) 
    {
        final var frame = new JFrame( "Key Listener" );
        final var contentPane = frame.getContentPane();
        final KeyListener listener = new KeyAdapter() 
        {
            @Override
            public void keyPressed(KeyEvent event) {
                printEventInfo("Key Pressed", event);
            }
            @Override
            public void keyReleased(KeyEvent event) {
                printEventInfo("Key Released", event);
            }
            @Override
            public void keyTyped(KeyEvent event) {
                printEventInfo("Key Typed", event);
            }
            
            private final void printEventInfo( final String str, final KeyEvent e ) 
            {
                System.out.println( str );
                int code = e.getKeyCode();
                System.out.println( "   Code: " + KeyEvent.getKeyText( code ) );
                System.out.println( "   Char: " + e.getKeyChar() );
                int mods = e.getModifiersEx();
                System.out.println( "    Mods: " + KeyEvent.getModifiersExText( mods ) );
                System.out.println( "    Location: " + keyboardLocation( e.getKeyLocation() ) );
                System.out.println( "    Action? " + e.isActionKey() );
            }   //  printEventInfo()
            
            
            private final String keyboardLocation( final int keybrd ) 
            {
                final var retValue = switch( keybrd ) 
                {
                    case KeyEvent.KEY_LOCATION_RIGHT -> "Right";
                    case KeyEvent.KEY_LOCATION_LEFT -> "Left";
                    case KeyEvent.KEY_LOCATION_NUMPAD -> "NumPad";
                    case KeyEvent.KEY_LOCATION_STANDARD -> "Standard";
                    default -> "Unknown";
                };
                
                //---* Done *----------------------------------------
                return retValue;
            }	//	keyboardLocation()
        };
        
        final var textField = new JTextField();
        textField.addKeyListener( listener );
        contentPane.add( textField, BorderLayout.NORTH );
        frame.pack();
        frame.setVisible( true );
    }   //  main()
}
//  class MyClass
\end{lstlisting}

The advantage from using \lstinline|KeyAdapter| instead of implementing the interface \lstinline|KeyListener| directly is that you do not have to implement those methods you are not interested in. Below the relevant part when using the interface:

\begin{lstlisting}
public final class MyClass 
{
    public static final void main( final String... args ) 
    {
        …
        final KeyListener listener = new KeyListener() 
        {
            @Override
            public void keyPressed( KeyEvent event ) { /* Does nothing */ }

            @Override
            public void keyReleased(KeyEvent event) { /* Does nothing */ }
            
            @Override
            public final void keyTyped( final KeyEvent event ) 
            {
                printEventInfo("Key Typed", event);
            }   //  keyTyped()
            
			…
    }   //  main()
}
//  class MyClass
\end{lstlisting}

For this interface and this adapter class, the advantage is marginal, but already the JDK knows some interfaces with much more methods that do have an adapter class, and these would benefit much more from an adapter class.

But since Java~8, interfaces may have \lstinline|default| methods\autocite{ORACLE_TUTORIALS:DefaultMethods, ORACLE_DOC_LANGUAGE_SPECIFICATION:MethodDeclarationsInterface}. Therefore, today the concept of an adapter class has got obsolete. Instead, you would define the interface differently, using \lstinline|default| methods.

For the interface \lstinline|java.awt.event.KeyListener| this would look like this:
\begin{lstlisting}
package java.awt.event;

import java.util.EventListener;

/**
 *  The listener interface for receiving keyboard events (keystrokes).
 *  […]
 *
 *  @author Carl Quinn
 *
 *  @see KeyAdapter
 *  @see KeyEvent
 */
public interface KeyListener extends EventListener 
{
    /**
     *  <p>{@summary Invoked when a key has been typed.} See the
     *  class description for 
     *  {@link KeyEvent} 
     *  for a definition of a key typed event.</p>
     *
     *  @param	e   The event to be processed.
     */
    public default void keyTyped( final KeyEvent e ) { /* Does nothing */ }

    /**
     *  <p>{@summary Invoked when a key has been pressed.} See the
     *  class description for 
     *  {@link KeyEvent}
     *  for a definition of a key pressed event.</p>
     *
     *  @param  e   The event to be processed.
     */
    public default void keyPressed( final KeyEvent e ) { /* Does nothing */ }

    /**
     *  <p>{@summary Invoked when a key has been released.} See the
     *  class description for 
     *  {@link KeyEvent} 
     *  for a definition of a key released event.</p>
     *
     *  @param  e   The event to be processed.
     */
    public default void keyReleased( final KeyEvent e ) { /* Does nothing */ }
}
//  interface KeyListener
\end{lstlisting}

This would allow to use the interface, but to implement only the method \lstinline|keyTyped()|.

\section{Types for Argument and Return Values}\label{sec:TypesForArgumentAndReturnValues}
This topic is relevant for all types of code, not only for code in a public API. Basically, it can be reduced to two questions that needs to be answered:
\begin{enumerate}
\item{Interface vs. concrete Class}
\item{Mutable vs. Immutable}
\end{enumerate}

In general, the answers are “Interface” and “Immutable”, but this is not always the best option.

\subsection{Return Types}\label{sec:ReturnTypes}
A method, in particular a non-\lstinline|private| method, should return the most general interface or class whenever possible. This means~…
\begin{itemize}[nosep]
\item{…~the interface \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} or even \lstinline|java.util.Collection|\autocite{ORACLE_DOC_COLLECTION_INTERFACE} instead of the concrete implementation \lstinline|java.util.ArrayList|\autocite{ORACLE_DOC_ARRAYLIST_CLASS}}
\item{…~the interface \lstinline|java.util.Map|\autocite{ORACLE_DOC_MAP_INTERFACE} and not the class \lstinline|java.util.HashMap|\autocite{ORACLE_DOC_HASHMAP_CLASS}}
\item{…the base class ~\lstinline|java.io.InputStream|\autocite{ORACLE_DOC_INPUTSTREAM_CLASS} and not the wrapper class \lstinline|java.io.FileInputStream|\autocite{ORACLE_DOC_FILEINPUTSTREAM_CLASS}}
\end{itemize}

Only when a concrete class or a more specialised interface provides features that are relevant to the caller, the method should be defined to return that type.

The only exception is \lstinline|java.lang.String| as the return type. Here you should really use that type, and not \lstinline|java.lang.CharSequence|. That is because this interface is implemented by immutable types (\lstinline|String|) and mutable types (e.g. \lstinline|StringBuilder|) as well.

In general, it is not evil if a method returns a mutable type, but it can get nasty under some circumstances – for example when you expose the object's internal state this way:
\begin{lstlisting}
public final class MyClass
{
    private final List<String> m_Attribute = new ArrayList<>();

    // PROBLEMATIC!!    
    public final List<String> getAttribute() { return m_Attribute; }
}
//  class MyClass    
\end{lstlisting}

This means that code like that below would modify \lstinline|myObject| – and not only the lines~3 to~5, but also the lines~9 to~11:
\begin{lstlisting}[numbers=left]
final var myObject = new MyClass();

myObject.getAttribute().add( "Some String" );
myObject.getAttribute().sort( String.CASE_INSENSITIVE_ORDER );
myObject.getAttritute().clear();

final var list = myObject.getAttribute();

list.getAttribute().add( "Some String" );
list.getAttribute().sort( String.CASE_INSENSITIVE_ORDER );
list.getAttritute().clear();
\end{lstlisting}
Usually, this is not desired! Otherwise, it should be clearly documented: 
\begin{lstlisting}
…
/**
 *  Returns a reference to the attribute.
 * 
 *  @note Any modification of the returned value will be reflected to
 *      the attribute itself and changes the state of the object.
 * 
 *  @return The reference to the attribute.
 */ 
public final List<String> getAttribute() { return m_Attribute; }
…
\end{lstlisting}

Some better implementations of \lstinline|getAttribute()| would be:
\begin{lstlisting}[numbers=left]
…
/**
 *  Returns the attribute.
 * 
 *  @return The attribute.
 */ 
public final List<String> getAttribute() 
{ 
	final var retValue = List.copyOf( m_Attribute );
	final List<String> retValue = unmodifiableList( m_Attribute );
	final List<> retValue = new ArrayList<>( m_Attribute );
	final List<String> retValue = unmodifiableList( new ArrayList<>( m_Attribute ) );
	final List<String> retValue = m_Attribute.clone();

    //---* Done *----------------------------------------------------
    return retValue;
}   //  getAttribute()
…
\end{lstlisting}

\paragraph{Line~9} creates an unmodifiable copy of \lstinline|m_Attribute|. The method \lstinline|copyOf()| exists for \lstinline|java.util.List|, \lstinline|java.util.Set|\autocite{ORACLE_DOC_SET_INTERFACE} and \lstinline|java.util.Map|. The only limitation is that \lstinline|null| is not valid as a value, and – for \lstinline|Map| – as a key.

It is important to know, that in case a \lstinline|Set| is a \lstinline|SortedSet|\autocite{ORACLE_DOC_SORTEDSET_CLASS} or a \lstinline|Map| is a \lstinline|TreeMap|\autocite{ORACLE_DOC_TREEMAP_CLASS}, the sort order gets lost for the copy.

\paragraph{Line~10} wraps \lstinline|m_Attribute| into an unmodifiable instance of \lstinline|List|. Drawback is that the returned value changes when the attribute itself will be changed.

The method \lstinline|unmodifiableList()| is part of the utility class \lstinline|java.util.Collections|\autocite{ORACLE_DOC_COLLECTIONS_CLASS}.

\paragraph{Line~11} creates a copy of \lstinline|m_Attribute|; the returned value will be mutable, but changes will not affect the attribute and therefore will not affect the state of the object instance, too. And \lstinline|null| values are no problem.

\paragraph{Line~12} creates a copy of \lstinline|m_Attribute| and wraps it into an umodifiable instance of \lstinline|List| – it combines lines~10 and 11, eliminating the shortcoming of the solutions from lines~9 and 10.

\paragraph{Line~13} ‘clones’ \lstinline|m_Attribute|; obviously this works only for instances that implement \lstinline|java.lang.Cloneable|\autocite{ORACLE_DOC_CLONEABLE_INTERFACE}, but although collections (and arrays) are cloneable themselves, they may contain elements that are not cloneable, causing a \lstinline|CloneNotSupportedException|\autocite{ORACLE_DOC_CLONENOTSUPPORTEDEXCEPTION_CLASS}.

A similar approach has to be taken for all attributes of a mutable type that will be returned by a method. The sample uses a collection, for other mutable types the details on how to create a copy or to make it immutable will differ.

If a method creates (generates, obtains, reads, loads,~…) the return value, it is part of the methods's contract whether that value is mutable or not. 

\subsection{Arguments}\label{Arguments}
Same as for a return type, the types for the formal parameters of a method should always be the most general type (interface or class) possible, but different from the return types, you should always to consider to use \lstinline|java.lang.CharSequence| instead of \lstinline|java.lang.String|.

A method must declare that it will modify an argument value. This is important because otherwise it could be called with an immutable implementation, what would cause an exception. Conversely, this also means that a method that does not specify this will not change any of the arguments, and that it would also be safe to call a method with a mutable object – safe for the caller.

But when the called method stores the provided reference in the instance, this may call for trouble:
\begin{lstlisting}
public final class MyClass
{
    private List<String> m_Attribute;
    
    public MyClass( final List<String> attribute )
    {
        // AVOID!!
        m_Attribute = attribute;
    }   //  MyClass()
}
//  classMyClass
\end{lstlisting}

If the caller holds a reference to the argument object, it can still modify it – and change the internal state of the \lstinline|MyClass| instance at the same time.

Therefore you should create a copy for the argument:
\begin{lstlisting}
…
m_Attribute = new ArrayList( attribute );
…
\end{lstlisting}
If the code of the class will not modify the attribute, you can of course use \lstinline|List::copyOf|, too.

Or you can do it like this\footnote{And do not forget the null check!}:
\begin{lstlisting}
public final class MyClass
{
    private final List<String> m_Attribute = new ArrayList<>();
    
    public MyClass( final List<String> attribute )
    {
        m_Attribute.addAll( attribute );
    }   //  MyClass()
}
//  classMyClass
\end{lstlisting}

\section{Swap Logic Errors for Compiler Errors}
From a book about Java programming:
\begin{quotation}
“One fundamental principle of programming is that, generally, it is best to swap a logic error for a compiler error. Compiler errors tend to be found in seconds and are corrected just as fast. Syntax errors are a good example […]

Logic errors, on the other hand, are the bane of all programmers. They hide and hate to reveal themselves. Logic errors seem to have minds of their own, constantly evading detection and dodging your efforts to pin down their cause. They can easily take a thousand times more effort to solve than the worst compiler errors. Worst of all, many logic errors are not found at all and occur only intermittently in sensitive places, which causes your customer to scream for a fix. Logic errors often require you to throw thousands of man-hours at them, only to finally discover that they are minor typos.”

Robert Simmons Jr.: \textit{Hardcore Java}\autocite{Simmons:HARDCORE_JAVA}
\end{quotation}

A sample for swapping a logic error for a compiler error is the recommendation to write comparisons always with the unchangeable value on the left side\footnote{This recommendation originates from C/C++ programming where \lstinline|if| conditions are checking values of type integer – and in C, nearly everything can be an integer, or at least be interpreted like one. Java forces that the type of the expression in the \lstinline|if| condition has to be \lstinline|boolean|, therefore this approach is less useful for Java code.}. So if you forget the second equal sign for a comparison on equal, the compiler will complain immediately:
\begin{lstlisting}
if( length() == len ) …
if( 5 == len ) …
\end{lstlisting}

Another sample for this is the recommendation to name fields with the “m\_” prefix (refer to chapter \tqfullvref{sec:Fields}). The compiler will never complain if you omit the \lstinline|this.| prefix when accessing a field, and it will not complain if you name a local variable in the same way as a field\footnote{Although you can configure both Eclipse and IntelliJ Idea to raise an error or a warning if you access a field without \lstinline|this.| and if you shadow a field through a local variable with the same name.} – but it will scream loudly about a non-existing reference if you forget the “m\_” prefix when accessing a field named along the rules defined here.

The best thing about compiler errors is, that they usually show up during development – and not first after deployment at customer side.

See also chapter \tqvref{sec:CompilerWarningsAndErrors} about compiler warnings and errors.

\section{Local Variable Type Inference}\label{sec:LocalVariableTypeInference}
Java~10 introduced type inference for local variables. Previously, all local variable declarations required an explicit (manifest) type on the left-hand side. With type inference, the explicit type can be replaced by the reserved type name \lstinline|var|\footnote{That \lstinline|var| was not introduced as an new \textit{keyword} for the language, it can be still used as name for local variables, fields and methods – although it is definitely discouraged to do so!} for local variable declarations that have initialisers. The type of the variable is inferred from the type of the initialiser.

There is a certain amount of controversy over this feature. Some welcome the concision it enables; others fear that it deprives readers of important type information, impairing readability. And both groups are right, to some extent. It can make code more readable by eliminating redundant information, and it can also make code less readable by eliding useful information. Another group worries that it will be overused, resulting in more bad Java code being written. This is also true, but it’s also likely to result in more good Java code being written. Like all features, it must be used with judgment. There’s no blanket rule for when it should and shouldn’t be used. 

Local variable declarations do not exist in isolation; the surrounding code can affect or even overwhelm the effects of using \lstinline|var|. The goal of this chapter is to examine the impact that surrounding code has on \lstinline|var| declarations, to explain some of the tradeoffs, and to provide guidelines for the effective use of \lstinline|var|.\footnote{This chapter is basically a summary of the article “Local Variable Type Inference – Style Guidelines”, published by Stuart~W.~Marks in March 2018\autocite{Marks:LocalVariableTypeInference}.}

\subsection{Principles}
The guidelines below are based on a few principles.

\begin{enumerate}
\item[P1.]{Reading code is more important than writing code.

Code is read much more often than it is written. Further, when writing code, you usually have the whole context in your head, and take your time; when reading code, you are often context-switching, and may be in more of a hurry. Whether and how particular language features are used ought to be determined by their impact on future readers of the program, not its original author. Shorter programs can be preferable to longer ones, but shortening a program too much can omit information that is useful for understanding the program. The central issue here is to find the right size for the program such that understandability is maximized.

You should be specifically unconcerned here with the amount of keyboarding that is necessary to input or to edit a program. While concision may be a nice bonus for the author, focusing on it misses the main goal, which is to improve the understandability of the resulting program.}

\item[P2.]{Code should be clear from local reasoning.

The reader should be able to look at a \lstinline|var| declaration, along with uses of the declared variable, and understand almost immediately what is going on. Ideally, the code should be readily understandable using only the context from a snippet or a patch. If understanding a \lstinline|var| declaration requires the reader to look at several locations around the code, it might not be a good situation in which to use \lstinline|var|. Then again, it might indicate a problem with the code itself.}

\item[P3.]{Code readability shouldn’t depend on IDEs.

Code is often written and read within an IDE, so it’s tempting to rely heavily on the code analysis features of IDEs. For type declarations, why not just use \lstinline|var| everywhere, since one can always point at a variable to determine its type?

The main reason is that code is often read outside an IDE. Code appears in many places where IDE facilities are not available, such as snippets within a document, browsing a repository on the internet, or in a patch file. It is counterproductive to have to import code into an IDE simply to understand what the code does.

Code should be self-revealing. It should be understandable on its face, without the need for assistance from tools.}

\item[P4.]{Explicit types are a tradeoff.

Java has historically required local variable declarations to include the type explicitly. While explicit types can be very helpful, they are sometimes not very important, and are sometimes just in the way. Requiring an explicit type can add clutter that crowds out useful information.

Omitting an explicit type can reduce clutter, but only if its omission does not impair understandability. The type is not the only way to convey information to the reader. Other means include the variable's name and the initialiser expression. You should take all the available channels into account when determining whether it is appropriate to mute one of these channels.}
\end{enumerate}

\subsection{Guidelines}
\begin{enumerate}
\item[G1.]{Choose variable names that provide useful information.

This is good practice in general, but it is much more important in the context of \lstinline|var|. In a \lstinline|var| declaration, information about the meaning and use of the variable can be conveyed using the variable's name. Replacing an explicit type with \lstinline|var| should often be accompanied by improving the variable name.

For example:

\begin{lstlisting}
// BAD
final List<Customer> x = dbConnection.executeQuery( query );

// BETTER
final var customerList = dbConnection.executeQuery( query );
\end{lstlisting}

In this case, a useless variable name has been replaced with a name that is evocative of the type of the variable, which is now implicit in the var declaration.

Encoding the variable's type in its name, taken to its logical conclusion, results in “Hungarian Notation”. Just as with explicit types, this is sometimes helpful, and sometimes just clutter. In this example the name \lstinline|customerList| implies that a \lstinline|List| is being returned. That might not be significant. Instead of the exact type, it’s sometimes better for a variable’s name to express the role or the nature of the variable, such as \lstinline|customers|:

\begin{lstlisting}
// BAD
try( final Stream<Customer> result = dbConnection.executeQuery( query ) ) 
{
    return result.map( … )
        .filter( … )
        .findAny();
}

// BETTER
try( final var customers = dbConnection.executeQuery( query ) ) 
{
    final var retValue = customers.map( … )
        .filter( … )
        .findAny();
    return retValue;
}
\end{lstlisting}}

\item[G2.]{Minimize the scope of local variables.

Limiting the scope of local variables is good practice in general. This practice is described in “Effective Java (3\textsuperscript{rd} Edition)”\autocite{Bloch:EffectiveJava}, Item~57. It applies with extra force if \lstinline|var| is in use.

In the following example, the \lstinline|add()| method clearly adds the special item as the last list element, so it’s processed last, as expected.

\begin{lstlisting}
final var items = new ArrayList<Item>( … );
items.add( MUST_BE_PROCESSED_LAST );
for( final var item : items ) { … }
\end{lstlisting}

Now suppose that in order to remove duplicate items, you modify this code to use a \lstinline|HashSet| instead of an \lstinline|ArrayList|, like below:

\begin{lstlisting}
final var items = new HashSet<Item>( … );
items.add( MUST_BE_PROCESSED_LAST );
for( fnial var item : items ) { … }
\end{lstlisting}

Your code now has a bug, since sets do not have a defined iteration order. However, it is likely that you will fix this bug immediately, as the uses of the \lstinline|items| variable are adjacent to its declaration.

Now suppose that this code is part of a large method, with a correspondingly large scope for the \lstinline|items| variable:

\begin{lstlisting}
final var items = new HashSet<Item>( … );

// … 100 lines of code …

items.add( MUST_BE_PROCESSED_LAST );
for( final var item : items ) { … }
\end{lstlisting}

The impact of changing from an \lstinline|ArrayList| to a \lstinline|HashSet| is no longer readily apparent, since \lstinline|items| is used so far away from its declaration. It seems likely that this bug could survive for much longer.

If \lstinline|items| had been declared explicitly as \lstinline|List<String>|, changing the initialiser would also require changing the type to \lstinline|Set<String>|. This \textit{might} prompt you to inspect the rest of the method for code that would be impacted by such a change (then again, it might not). Use of \lstinline|var| would remove this prompting, possibly increasing the risk of a bug being introduced in code like this.

This might seem like an argument against using \lstinline|var|, but it really is not. The initial example that uses \lstinline|var| is perfectly fine. The problem only occurs when the variable's scope is large. Instead of simply avoiding \lstinline|var| in these cases, you should change the code to reduce the scope of the local variables, and only then declare them with \lstinline|var|.}

\item[G3.]{Consider \lstinline|var| when the initialiser provides sufficient information to the reader.

Local variables are often initialised with constructors. The name of the class being constructed is often repeated as the explicit type on the left-hand side. If the type name is long, use of \lstinline|var| provides concision without loss of information:

\begin{lstlisting}
// ACCEPTABLE
final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();

// BETTER
final var outputStream = new ByteArrayOutputStream();
\end{lstlisting}

It is also reasonable to use \lstinline|var| in cases where the initialiser is a method call, such as a \lstinline|static| factory method, instead of a constructor, and when its name contains enough type information:

\begin{lstlisting}
// ACCEPTABLE
final BufferedReader reader = Files.newBufferedReader( … );
final List<String> stringList = List.of("a", "b", "c");

// BETTER
final var reader = Files.newBufferedReader(...);
final var stringList = List.of("a", "b", "c");
\end{lstlisting}

In these cases, the methods names strongly imply a particular return type, which is then used for inferring the type of the variable.}

\item[G4.]{Use \lstinline|var| to break up chained or nested expressions with local variables.

Consider code that takes a collection of strings and finds the string that occurs most often. This might look like the following:

\begin{lstlisting}
return strings.stream()
    .collect( groupingBy( s -> s, counting() ) )
    .entrySet()
    .stream()
    .max( Map.Entry.comparingByValue() )
    .map( Map.Entry::getKey );
\end{lstlisting}

This code is correct, but it is potentially confusing, as it looks like a single stream pipeline. In fact, it’s a short stream, followed by a second stream over the result of the first stream, followed by a mapping of the \lstinline|Optional| result of the second stream. The most readable way to express this code would have been as two or three statements; first group entries into a map, then reduce over that map, then extract the key from the result (if present), as shown below:

\begin{lstlisting}
// BETTER READABLE
final Map<String, Long> freqMap = strings.stream()
    .collect(groupingBy( s -> s, counting() ) );
final Optional<Map.Entry<String,Long>> maxEntryOpt = freqMap.entrySet()
    .stream()
    .max( Map.Entry.comparingByValue() );
return maxEntryOpt.map( Map.Entry::getKey );
\end{lstlisting}

But you probably resisted doing that because writing the types of the intermediate variables seemed too burdensome, so instead they distorted the control flow. Using \lstinline|var| here allows you to express the code more naturally without paying the high price of explicitly declaring the types of the intermediate variables:

\begin{lstlisting}
// EVEN BETTER READABLE
final var freqMap = strings.stream()
    .collect( groupingBy( s -> s, counting() ) );
final var maxEntryOpt = freqMap.entrySet()
    .stream()
    .max( Map.Entry.comparingByValue() );
final var retValue = maxEntryOpt.map( Map.Entry::getKey );
return retValue;
\end{lstlisting}

You might legitimately prefer the first snippet with its single long chain of method calls. However, in some cases it is better to break up long method chains. Using \lstinline|var| for these cases is a viable approach, whereas using full declarations of the intermediate variables as in the second snippet makes it an unpalatable alternative. As with many other situations, the correct use of \lstinline|var| might involve both taking something out (explicit types) and adding something back (better variable names, better structuring of code).}

\subsection{-------------------------------------------- Proceed from here!}
\item[G5.]{Don’t worry too much about “programming to the interface” with local variables.

A common idiom in Java programming is to construct an instance of a concrete type but to assign it to a variable of an interface type. This binds the code to the abstraction instead of the implementation, which preserves flexibility during future maintenance of the code. For example:

\begin{lstlisting}
// ORIGINAL
List<String> list = new ArrayList<>();
If var is used, however, the concrete type is inferred instead of the interface:

// Inferred type of list is ArrayList<String>
var list = new ArrayList<String>();
\end{lstlisting}

It must be reiterated here that var can only be used for local variables. It cannot be used to infer field types, method parameter types, and method return types. The principle of “programming to the interface” is still as important as ever in those contexts.

The main issue is that code that uses the variable can form dependencies on the concrete implementation. If the variable’s initialiser were to change in the future, this might cause its inferred type to change, causing errors or bugs to occur in subsequent code that uses the variable.

If, as recommended in guideline G2, the scope of the local variable is small, the risks from “leakage” of the concrete implementation that can impact the subsequent code are limited. If the variable is used only in code that’s a few lines away, it should be easy to avoid problems or to mitigate them if they arise.

In this particular case, ArrayList only contains a couple of methods that aren’t on List, namely ensureCapacity and trimToSize. These methods don’t affect the contents of the list, so calls to them don’t affect the correctness of the program. This further reduces the impact of the inferred type being a concrete implementation rather than an interface.}
\item[G6.]{Take care when using var with diamond or generic methods.

Both var and the “diamond” feature allow you to omit explicit type information when it can be derived from information already present. Can you use both in the same declaration?

Consider the following:

\begin{lstlisting}
PriorityQueue<Item> itemQueue = new PriorityQueue<Item>();
\end{lstlisting}
This can be rewritten using either diamond or var, without losing type information:

\begin{lstlisting}
// OK: both declare variables of type PriorityQueue<Item>
PriorityQueue<Item> itemQueue = new PriorityQueue<>();
var itemQueue = new PriorityQueue<Item>();
\end{lstlisting}

It is legal to use both var and diamond, but the inferred type will change:

\begin{lstlisting}
// DANGEROUS: infers as PriorityQueue<Object>
var itemQueue = new PriorityQueue<>();
\end{lstlisting}

For its inference, diamond can use the target type (typically, the left-hand side of a declaration) or the types of constructor arguments. If neither is present, it falls back to the broadest applicable type, which is often Object. This is usually not what was intended.

Generic methods have employed type inference so successfully that it’s quite rare for programmers to provide explicit type arguments. Inference for generic methods relies on the target type if there are no actual method arguments that provide sufficient type information. In a var declaration, there is no target type, so a similar issue can occur as with diamond. For example,

\begin{lstlisting}
// DANGEROUS: infers as List<Object>
var list = List.of();
\end{lstlisting}

With both diamond and generic methods, additional type information can be provided by actual arguments to the constructor or method, allowing the intended type to be inferred. Thus,

\begin{lstlisting}
// OK: itemQueue infers as PriorityQueue<String>
Comparator<String> comp = ... ;
var itemQueue = new PriorityQueue<>(comp);

// OK: infers as List<BigInteger>
var list = List.of(BigInteger.ZERO);
\end{lstlisting}

If you decide to use var with diamond or a generic method, you should ensure that method or constructor arguments provide enough type information so that the inferred type matches your intent. Otherwise, avoid using both var with diamond or a generic method in the same declaration.}
\item[G7.]{Take care when using var with literals.
Primitive literals can be used as initialisers for var declarations. It’s unlikely that using var in these cases will provide much advantage, as the type names are generally short. However, var is sometimes useful, for example, to align variable names.

There is no issue with boolean, character, long, and string literals. The type inferred from these literals is precise, and so the meaning of var is unambiguous:

\begin{lstlisting}
// ORIGINAL
boolean ready = true;
char ch = '\ufffd';
long sum = 0L;
String label = "wombat";

// GOOD
var ready = true;
var ch    = '\ufffd';
var sum   = 0L;
var label = "wombat";
\end{lstlisting}

Particular care should be taken when the initialiser is a numeric value, especially an integer literal. With an explicit type on the left-hand side, the numeric value may be silently widened or narrowed to types other than int. With var, the value will be inferred as an int, which may be unintended.

\begin{lstlisting}
// ORIGINAL
byte flags = 0;
short mask = 0x7fff;
long base = 17;

// DANGEROUS: all infer as int
var flags = 0;
var mask = 0x7fff;
var base = 17;
\end{lstlisting}

Floating point literals are mostly unambiguous:

\begin{lstlisting}
// ORIGINAL
float f = 1.0f;
double d = 2.0;

// GOOD
var f = 1.0f;
var d = 2.0;
\end{lstlisting}

Note that float literals can be widened silently to double. It is somewhat obtuse to initialise a double variable using an explicit float literal such as 3.0f, however, cases may arise where a double variable is initialised from a float field. Caution with var is advised here:

\begin{lstlisting}
// ORIGINAL
static final float INITIAL = 3.0f;
...
double temp = INITIAL;

// DANGEROUS: now infers as float
var temp = INITIAL;
\end{lstlisting}

(Indeed, this example violates guideline G3, because there isn’t enough information in the initialiser for a reader to see the inferred type.)}
\end{enumerate}

\subsection{Examples}
This section contains some examples of where var can be used to greatest benefit.

The following code removes at most max matching entries from a Map. Wildcarded type bounds are used for improving the flexibility of the method, resulting in considerable verbosity. Unfortunately, this requires the type of the Iterator to be a nested wildcard, making its declaration more verbose. This declaration is so long that the header of the for-loop no longer fits on a single line, making the code even harder to read.

\begin{lstlisting}
// ORIGINAL
void removeMatches(Map<? extends String, ? extends Number> map, int max) {
    for (Iterator<? extends Map.Entry<? extends String, ? extends Number>> iterator =
             map.entrySet().iterator(); iterator.hasNext();) {
        Map.Entry<? extends String, ? extends Number> entry = iterator.next();
        if (max > 0 && matches(entry)) {
            iterator.remove();
            max--;
        }
    }
}
\end{lstlisting}
Use of var here removes the noisy type declarations for the local variables. Having explicit types for the Iterator and Map.Entry locals in this kind of loop is largely unnecessary. This also allows the for-loop control to fit on a single line, further improving readability.

\begin{lstlisting}
// GOOD
void removeMatches(Map<? extends String, ? extends Number> map, int max) {
    for (var iterator = map.entrySet().iterator(); iterator.hasNext();) {
        var entry = iterator.next();
        if (max > 0 && matches(entry)) {
            iterator.remove();
            max--;
        }
    }
}
\end{lstlisting}

Consider code that reads a single line of text from a socket using the try-with-resources statement. The networking and I/O APIs use an object wrapping idiom. Each intermediate object must be declared as a resource variable so that it will be closed properly if an error occurs while opening a subsequent wrapper. The conventional code for this requires the class name to be repeated on the left and right sides of the variable declaration, resulting in a lot of clutter:

\begin{lstlisting}
// ORIGINAL
try (InputStream is = socket.getInputStream();
     InputStreamReader isr = new InputStreamReader(is, charsetName);
     BufferedReader buf = new BufferedReader(isr)) {
    return buf.readLine();
}
\end{lstlisting}
Using var reduces the noise considerably:

\begin{lstlisting}
// GOOD
try (var inputStream = socket.getInputStream();
     var reader = new InputStreamReader(inputStream, charsetName);
     var bufReader = new BufferedReader(reader)) {
    return bufReader.readLine();
}
\end{lstlisting}

Conclusion
Using var for declarations can improve code by reducing clutter, thereby letting more important information stand out. On the other hand, applying var indiscriminately can make things worse. Used properly, var can help improve good code, making it shorter and clearer without compromising understandability.

\section{Access to Properties}
Encapsulation is an important design principle for classes. This means that the internal state of an object can be manipulated only in a well defined manner, through the methods. Consequently, it may not be possible to modify the attributes  directly, by a direct assignment.

To achieve that, instance or class variables – also known as properties, attributes or fields – have to be \lstinline|private|.

If it is necessary to set or retrieve an instance variable (a property) directly, it mandatory to provide the appropriate methods for this (setter and/or getter, or mutator and/or accessor methods). But often attributes are set or retrieved as a side effect of method calls that modify the internal state of the object instance, or rely on it.

Programmers are inclined to use \lstinline|public| fields when the need a data structure like a \lstinline|struct| in C/C++, and not a full-fledged class. But as Java does not now that data structure, it seems to be a quick solution to have a \lstinline|class| with only \lstinline|public| fields and no methods, just to spare typing effort, and sometimes with the idea, that the direct access to the \lstinline|public| field is much faster that accessing it through a method. But modern optimising compilers will inline the code of a simple getter method, so that there is no difference in the end.

And if you want to avoid the typing, use a \lstinline|record|\autocite{ORACLE_DOC_RECORD,ORACLE_DOC_LANGUAGE_SPECIFICATION:RecordClasses} instead. Sometimes also an instance of \lstinline|java.util.Map| or another collection implementation could be an alternative to a specialised class.
 
Sometimes fields from base classes are defined as \lstinline|protected|, to make them directly accessible by methods from the derived implementations, but this is also discouraged.\footnote{The idea behind that is the same false assumption that the direct access to the \lstinline|protected| field is much faster that accessing it through a method.}

It does not matter if we talk about properties (instance variables) or \lstinline|static| field (class variables): both should always be \lstinline|private|.

Constants are the only exception, obviously, because a constant is explicitly defined as a \lstinline|public static final| field.

Regarding encapsulation in general, refer to chapter \tqvref{sec:EncapsulationWithModules}.

\section{Accessing Fields or Methods using Reflection}
First of all, you should avoid to use Reflection whenever possible. Just do not use it!\footnote{The only acceptable exception is for unit tests; we will discuss that later in this chapter.}

One reason is that accessing a field or a method via reflection causes some overhead that decreases a program’s performance. 

Next, such code is usually not easy to read or to understand, not only because of all the necessary error handling code around it.

And with modularisation, it is quite often not even possible to access methods and fields of an object via Reflection, even if they are \lstinline|public|; they are not even visible in some cases.

Of course, there are some patterns whose implementation in Java requires the use of Reflection, because any other approach is either even less performant, much more cumbersome, or will not work at all – meaning there are occasions when it is not really possible to avoid the use of Reflection. Nevertheless, you should still consider an alternative; lambdas\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:LambdaExpressions} and method references\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:MethodReference} are quite often a very good replacement for an implementation based on Reflection.

Reflection also allows you to access non-\lstinline|public| member of a class that are usually not accessible by your code. This is considered a “dirty hack” and may not be used in production code. In particular as it may not work properly with modules.

But there are useful applications for this, too: you can and should used it in unit tests for \lstinline|private| or \lstinline|protected| methods that are not \lstinline|public| for good reasons, and if these methods cannot be tested indirectly.\footnote{The alternative would be to make the method at least \lstinline|protected|, but this would make it (more) visible to the consumers of the API, and perhaps even accessible – but there was a reason why that method was originally \lstinline|private|.}

I recommend to use the following pattern if you want to access a \lstinline|private| method in your unit tests:
\begin{lstlisting}[numbers=left]
public final class MyClass
{
    /**
     *  Does something.
     *
     *  @param  value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    private final String myMethod( final CharSequence value ) throws IOException      { … }
}   
//  class MyClass

/**
 *  This class provides some unit tests for
 *  {@link MyClass}.
 */
public final class TestMyClass
{
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The reference to {@code myMethod()}.
     */
    private static final Method METHOD_myMethod;
    
    static
    {
        final var targetClass = MyClass.class;
        String methodName;
        try
        {
            methodName = "myMethod";
            METHOD_myMethod = targetClass.getDeclaredMethod( methodName, CharSequence.class );
            METHOD_myMethod.setAccessible( true );
        }
        catch( final NoSuchMethodException ignored )
        {
            throw new ExceptionInInitializerError( "Cannot find method '%s()' in class '%s'".formatted( methodName, targetClass.getName() );
        }
    }
    
        /*---------*\
    ====** Methods **================================================ 
        \*---------*/
    /**
     *  Calls
     *  {@link MyClass#myMethod(CharSequence)}
     *
     *  @param  instance    The candidate.
     *  @param	value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    protected static final String myMethod( final MyClass instance, final CharSequence value )
    {
        final String retValue;
        try
        {
            retValue = (String) METHOD_myMethod.invoke( requireNonNullArgument( instance, "instance" ), value );
        }
        catch( final IllegalAccessException | ClassCastException e )
        {
            throw new AssertionError( e );
        }
        catch( final InvocationTargetException e )
        {
            switch( e.getCause() )
            {
                case null -> throw new AssertionError( e );
                case IOException ioe -> throw ioe;
                default -> throw new AssertionError( e.getCause() );
            }
        }
    }   //  myMethod()   
    
    @Test
    final void testMyMethod() throws Exception
    {
        final var candidate = new MyClass();
        final var result = myMethod( candidate, "" );
        assertTrue( result instanceof String );
    }   // testMyMethod()
}
//  class TestMyClass  
\end{lstlisting}
This allows you to call the method \lstinline|MyClass::myMethod| nearly directly; the method \lstinline|TestMyClass::myMethod| behaves in the same way as the original method.

\lstinline|java.lang.AssertionError|\autocite{ORACLE_DOC_ASSERTIONERROR_CLASS} is the base class for the errors thrown by JUnit\autocite{JUNIT5}.

\include{5_CodingGuidelines_ImplementingTheObjectMethods}

\include{5_CodingGuidelines_StringConcatenation}

\section{The Annotation @API}\label{sec:APIAnnotation}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\lipsum[1]

\begin{lstlisting}
\end{lstlisting}

\section{“Convention over Configuration”}
The phrase “Convention over Configuration” (or “Coding by Convention”) got popular with the introduction of Ruby on Rails, but it is related to earlier ideas like the concept of “Sensible Defaults” and the “Principle of Least Astonishment” in user interface design.

Basically it means that an object instance can be created and used properly with only minimal configuration because all not absolutely mandatory settings will have meaningful – and useful! – default values.

On the other hand, there is that number~\ref{lst:ZoP:ExplicitVsImplicit} from the “Zen of Python”, saying “Explicit is better than implicit”~…

These are obviously contradictory statements – so whose right?

Both, to some extent!

Your design should support “Convention over Configuration”, but your code should rely on defaults only when a change of these defaults in unlikely, or such a change will not have an effect to your code.

So assume that you are using a 3\textsuperscript{rd}~party library that creates reports in HTML format; the default format was HTML3 with the previous version, but in the current version – that one used by you – it is HTML5. The generated reports are consumed by a tool that converts HTML5 input into PDF.

According to “Convention over Configuration”, you are fine: the convention is HTML5, you do not need to set the HTML version for the output format explicitly.

But what happens, if in a few years the next version of that report creator library will support HTML7 as the default, but your PDF generator stucks still with HTML5 for its input? Nothing happens until your successor as the maintainer of your software decides to use that new library~… afterwards you may see funny things in the generated PDF documents.

So the recommendation is: do not always rely on conventions! Whenever possible, provide an explicit configuration! At least leave a comment when you rely on the defaults, and that comment should describe what the anticipated defaults are.

\section{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{Compiler Warnings and Errors}\label{sec:CompilerWarningsAndErrors}
It is not allowed to commit any code that emits warnings or even errors on a compiler run to the SCCS. It is also not allowed to switch off any compiler warning globally.

In fact, warnings should even not show up in the development environment, also with the most aggressive settings.

It is allowed to use the annotation \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} to locally deactivate a warning. This is often necessary when dealing with legacy APIs that does not use Generics. So this sample would emit an “unchecked” warning for line 3:
\begin{lstlisting}[numbers=left]
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

To avoid this, the annotation \lstinline|@SuppressWarnings| with the value “unchecked” can be applied – preferably not to the method as a whole, but only to the problematic assignment, even if this means that an additional temporary variable is required (but not in this sample):
\begin{lstlisting}
// RECOMMENDED
public final Map<K,V> clone()
{
    @SuppressWarnings( "unchecked" ) 
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}

// AVOID!!!
@SuppressWarnings( "unchecked" ) 
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

As there is no rule without exception, here is one: I recommend to use labels to mark long code blocks (refer to the chapters \tqfullref{sec:LabelsAndBreakStatements}, \tqfullref{sec:TrailingOrEndOfLineComments}, and \tqfullref{sec:CommentsWhen}), but if those code blocks do not reference these labels, they may cause an “Unused Label” warning in your IDE. The recommendation is here to deactivate that warning – globally.

\section{Terminating a Method and returning Values}\label{sec:ReturningValues}
A method will have only \textit{one single regular} exit point, and that is (after) its last line! Irregular or \textit{exceptional} exit points are always exceptions that will be thrown as the result of an error condition.

This means that a method, that does not return something, does not have a \lstinline|return| statement.

If there is a \lstinline|return| statement in a method, it is \textit{always} the last statement of the method.

\begin{lstlisting}
// AVOID!!!
public final long myMethod( final int a )
{
    if( a < 0 ) throw new IllegalArgumentException( "a < 0" );
    if( a == 0 ) return 1;
    if( a == 1 ) return 1;
    return a * myMethod( a - 1 );
}   //  myMethod()
\end{lstlisting}

As already said in chapter \tqfullvref{sec:NamesForLocalVariables}, the name of the local variable that holds the return value is always \lstinline|retValue|; only when the method returns an attribute, the field name could be used instead. And it is also not necessary to assign \lstinline|this| to \lstinline|retValue| for method chaining. 

Then the recommended code would be:
\begin{lstlisting}
// RECOMMENDED
public final long myMethod( final int a )
{
    if( a < 0 ) throw new IllegalArgumentException( "a < 0" );
    final var retValue = (a > 1) ? myMethod( a - 1L) : 1L;
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  myMethod()

// Still OK
public final long myMethod( final int a )
{
    if( a < 0 ) throw new IllegalArgumentException( "a < 0" );
    var retValue = 1L;
    if( a > 1 ) retValue = myMethod( a - 1 );
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  myMethod()
\end{lstlisting}

It is much easier to grasp what a method is doing when the program flow is always from top to bottom, and if there are not any side exits (other than the ‘emergency exits’, marked by a \lstinline|throw| statement when issuing an exception.

This will supported by always using the same name for the return value – just that \lstinline|retValue|.

\subsection{Lambda Results}\label{sec:LambdaResults}
Most lambdas are just one liners, and if they return something, it will be the return value of that line:
\begin{lstlisting}
n -> (n + 1) * 4; 
\end{lstlisting}

If the code for the lambda will be more complex, you should consider to place it to a method and
refer to it with a method reference:
\begin{lstlisting}
public final class MyClass
{
    private final String format( final String name )
    {
        final var buffer = new StringJoiner( "}, {", "{", "}" );
        if( nonNull( name ) )
        {
            for( final var s: name.split( " " ) )
            {
                buffer.add( s );
            }
        }
        else
        {
            buffer.setEmptyValue( "No Name" );
        }
        final var retValue = buffer.toString();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  format()
    
    public final String myMethod()
    {
        final var retValue = retrieveNames().stream()
            .map( this::format )
            .filter( n -> !n.equals( "No Name" ) )
            .collect( joining( "}, Name={", "Names={Name={", "}}"
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

Only if a complex lambda needs to refer to local variables, it has to be defined locally:
\begin{lstlisting}
public final class MyClass
{
    public final String myMethod( final String longTemplate, final String shortTemplate, final String nullText )
    {
        final var retValue = retrieveNames().stream()
            .map( n ->
            {
                final var result = nullText;
                if( n != null )
                {
                    result = n.length() > 15 
                        ? longTemplate.formatted( n ) 
                        : shortTemplate.formatted( n );
                }
                return result;
            } )
            .filter( n -> !n.equals( "No Name" ) )
            .collect( joining( "}, Name={", "Names={Name={", "}}"
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}
The lambda cannot use the name \lstinline|retValue| for its return value, because that is already defined in the surrounding method\footnote{And even if it is not (yet) defined, the lambda should not use it anyway, as it may collide with future code modifications.}. Instead, lambdas use the name \lstinline|result| for their return values.

\subsection{“case” Results}\label{sec:CaseResults}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\autocite{ORACLE_DOC_SWITCHEXPRESSIONS}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\lipsum[5]

\begin{lstlisting}
\end{lstlisting}

\section{The Ternary Operator “?”}\label{sec:TheTernaryOperator}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\lipsum[5]

\begin{lstlisting}
\end{lstlisting}

\section{Programming to the Interface}\label{sec:ProgrammingToTheInterface}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\autocite{Cymerman:SmarterJavaDevelopment}
\autocite{Fejer:ProgramToInterfaces}
\autocite{Pavlutin:ProgrammingToInterface}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\autocite{}
\lipsum[5]

\begin{lstlisting}
\end{lstlisting}

\section{The "switch" Statement}\label{sec:TheSwitchStatement}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\lipsum[5]
\ref{sec:SwitchStatements}

\begin{lstlisting}
\end{lstlisting}

\section{Encapsulation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Encapsulation with Modules}\label{sec:EncapsulationWithModules}
\subsection{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Lambdas}\label{sec:Lambdas}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Functional Interfaces}\label{sec:FunctionalInterfaces}
\subsection{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{The Interface “java.util.Formattable”}\label{sec:FormattableInterface}
\section{-------------------------------------------- Proceed from here!}

\autocite{ORACLE_DOC_STRING_CLASS}
\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\autocite{ORACLE_DOC_STRINGJOINER_CLASS}
\autocite{ORACLE_DOC_FORMATTER_CLASS}
\autocite{ORACLE_DOC_FORMATTABLE_INTERFACE}

\lipsum[1]

\section{The Interface “java.lang.Comparable”}\label{sec:ComparableInterface}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Utility Classes}\label{sec:UtilityClasses}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{try-with-resources}\label{sec:TryWithResources}
The feature \lstinline|try-with-resources| was introduced with Java~7; it can help to make programs more stable and less error prone.

\subsection{Basics}
Basically, \lstinline|try-with-resources|\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:TryWithResources} is an extension of the previously existing \lstinline|try-catch-finally| feature.

Instead of writing
\begin{lstlisting}[numbers=left]
InputStream input = null;
try
{
    input = new FileInputStream( file );
    …
}
catch( final IOException e )
{
    // Handle the error
}
finally
{
    try
    {
        if( input != null ) input.close();
    }
    catch( final IOException e )
    {
        // Handle the error
    }
}
\end{lstlisting}

the new feature allows you to write

\begin{lstlisting}[numbers=left]
try( final var input = new FileInputStream( file ); )
{
    …
}
catch( final IOException e )
{
    // Handle the error
}
\end{lstlisting}

It works because the interface \lstinline|java.lang.AutoCloseable|\footnote{In fact, \lstinline|InputStream| will still implement just \lstinline|java.io.Closeable|, as already before Java~7, but this interface will now extend the new interface \lstinline|java.lang.AutoCloseable|.} is implemented by the class \lstinline|java.io.InputStream|. For details refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE}.

This interface defines just one method, \lstinline|close()|, that declares to throw an exception of type \lstinline|java.lang.Exception|.

\lstinline|close()| is called automatically on all instances of \lstinline|AutoClosable| that were declared and defined in the ‘arguments list’ of the new \lstinline|try| when the scope of the \lstinline|try| block is left. If there is more than one resource defined, the sequence is reversed to that of the definition: the last assigned resource will be closed first.

So a code snippet to copy data from an input stream to an output stream may look like this\footnote{This is obviously not a very good implementation, but it illustrates how to use \lstinline|try-with-resources| quite well.}:
\begin{lstlisting}[numbers=left]
try
( 
    InputStream input = new FileInputStream( infile );
    OutputStream output = new FileOutputStream( outfile ) 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
\end{lstlisting}
Both streams will be closed properly in case of a problem or the work is done.

\subsection{Error Handling}
What will happen if the code in the \lstinline|try| block throws an exception and closing the resource will throw one, too?

For the ‘traditional’ pattern this could mean that the first exception would be ‘supplanted’ by the exception from the close. For sure, in a \lstinline|catch| block the original cause could be logged, but usually only checked exceptions (and “expected“ ones) are covered this way.

Together with \lstinline|try-with-resources|, a new feature was introduced to the language: the \textit{suppressed} exception. This deals with the problem described above.

So if the \lstinline|try| block throws an exception (for our example, it would be most probably an \lstinline|IOException|) and the \lstinline|AutoCloseable.close()| will fail with an exception, too, the latter one will be added to the first one as a “suppressed exception” by the JVM.

For this purpose, the API of the class \lstinline|java.lang.Throwable| was extended by the methods \lstinline|addSuppressed()| and \lstinline|getSuppressed()|.\footnote{see \autocite{ORACLE_DOC_THROWABLE_CLASS}}

Using \lstinline|Throwable.printStackTrace()| an output like that below will be produced:
\begin{lstlisting}
java.lang.Error
  at TryWithResources.main(TryWithResources.java:175)
  Suppressed: java.lang.Exception
    at TryWithResources$Resource2.close(TryWithResources.java:103)
    at TryWithResources.main(TryWithResources.java:176)
\end{lstlisting}

\subsection{Execution Sequence}\label{sec:ExecutionSequence}
It is important to know how the execution sequence looks like when using \lstinline|try-with-resources|. For the traditional pattern it is\\
\begin{center}
\verb#try{}->[catch{}]->finally{}#
\end{center} 
for \lstinline|try-with-resources| it will be\\ 
\begin{center}
\verb#try{}->AutoCloseable.close()->[catch{}]->[finally{}]#
\end{center}

This means that the method \lstinline|close()| on the \lstinline|AutoClosable| objects will be called \textit{before} any code in an optional \lstinline|catch| and/or \lstinline|finally| block that is attached to the \lstinline|try| block. For the sample we used above this means that the \lstinline|InputStream input| is already closed when the code in the \lstinline|catch| block that handles the \lstinline|IOException| will be executed.

Therefore the code below will not work as expected in case an exception is thrown in the \lstinline|try| block:
\begin{lstlisting}
// WILL NOT WORK!
final var logStream = new FileOutputStream( logfile )
try
(   
    final var input = new FileInputStream( infile );
    final var output = new FileOutputStream( outfile );
    final var log = logStream 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
catch( final IOException e )
{
    logStream.write( "Copy failed!\n".getBytes( UTF8 ) );
    /* Fails because the log file is already closed! */
}
\end{lstlisting}

Refer also to \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ExtendedTryWithResources}.

\subsection{When to use?}
\lstinline|try-with-resources| is a very powerful feature that should be used whenever possible. Definitively it should be used with all the Java classes that already implement \lstinline|java.lang.AutoCloseable| or \lstinline|java.io.Closeable|:

\begin{itemize}
\item{The \lstinline|java.io| streams}
\item{Sockets}
\item{\lstinline|java.sql.Connection|, \lstinline|java.sql.Statement|, \lstinline|java.sql.ResultSet|}
\item{\lstinline|java.jms.Connection|}
\end{itemize}

\subsubsection{Lifecycle}\label{sec:Lifecycle}
In C++, it is a very common pattern to “wrap” the lifecycle of a resource into the lifecycle of an object:
\begin{lstlisting}[language=C++]
class Resource
{
    //---* Attributes *----------------------------------------------
    private:
        RTYPE m_Res;

    //---* Constructors *--------------------------------------------
    public:
        Resource( RTYPE &r )
        : m_Res( r )
        { m_Res.open(); }

    //---* Destructor *----------------------------------------------
    public:
        ~Resource() { m_Res.close(); }

    //---* Methods *-------------------------------------------------
    // Some methods to access the resource
    …
}
\end{lstlisting}
A use of that class might look like this:
\begin{lstlisting}[language=c++]
…
{
    Resource resource( r );

    // Do something
    …
}
…
\end{lstlisting}
The instance of \lstinline|Resource| will be constructed and \lstinline|open()| is called on \lstinline|r| on the declaration of the variable \lstinline|resource|. On leaving the scope the destructor of \lstinline|Resource| is called implicitly and \lstinline|close()| will be called on \lstinline|r|.

The C++~STL is using a very similar pattern for smart pointers.

Unfortunately, Java does not know destructors\footnote{The deprecated method \lstinline|java.lang.Object.finalizer()| that is part of each Java class is not and was never a replacement for or an alternative to a destructor as it could never be predicted when it is called (just “sometime before the JVM terminates” – if ever).}, so this pattern could not be used.

A workaround is to use a \lstinline|try-finally| block with the cleanup (usually a call to \lstinline|close()|) in the \lstinline|finally| block. But to often we have seen that in the run of modifications and/or corrections (refactorings) suddenly the \lstinline|finally| block and/or its contents had been removed (“optimised away”).

Now, with the \lstinline|try-with-resources| feature, we can have “Lifecycle” classes; they are still not that easy to use that with real destructors, but we can come close.

A sample would be the Class \lstinline|AutoLock|; for the full code, see chapter \tqfullvref{sec:AutoLock}; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

In programs that use \lstinline|java.util.concurrent.locks.Lock| or one of its implementations for thread synchronisation, you will find quite often code like this:
\begin{lstlisting}[numbers=left]
m_Lock.lock();
try
{
    // Do something
    …
}
finally { m_Lock.unlock(); }
\end{lstlisting}

This calls for a lifecycle class. Unfortunately the code below will not work, due to several reasons:
\begin{lstlisting}[numbers=left]
// Does not work!!
try( final var unused = new Lock() )
{
    // Do something
    …
}
\end{lstlisting}

First, \lstinline|java.util.concurrent.locks.Lock| will not implement \lstinline|java.lang.AutoCloseable|, and second – much more important – we cannot create a new instance of \lstinline|Lock| each time we enter the critical section.\footnote{Not to mention that \lstinline|java.util.concurrent.locks.Lock| is an interface so that \lstinline|new Lock()| cannot work at all.}

Fortunately, the \lstinline|try-with-resources| feature will not call \lstinline|close()| on the newly created object, but on the local reference (that is the reason why \lstinline|try-with-resources| will not work with anonymous instances like \lstinline|try( new Lock() )|). If we would now wrap the \lstinline|Lock| instance into a class that implements \lstinline|AutoCloseable|, we can write something like this:
\begin{lstlisting}[numbers=left]
…
AutoLock m_AutoLock = new AutoLock( m_Lock );
…
try( final var unused = m_AutoLock.lock() )
{
    // Do something
    …
}
\end{lstlisting}

\subsubsection{Post-Processing}
Together with lambdas, \lstinline|try-with-resources| can be (ab)used also to enforce a unconditional post-processing when a code block is left. This may look like this:
\begin{lstlisting}[numbers=left]
…
Runnable doAfter = …;
…
try( final var p = new PostProcessor( doAfter ) )
{
    // Do whatever necessary
    …
}
\end{lstlisting}
The \lstinline|PostProcessor| instance will call \lstinline|Runnable::run|\autocite{ORACLE_DOC_RUNNABLE:run} in its \lstinline|close()| method when the \lstinline|try| block is left. Chapter \tqfullref{sec:PostProcessor} in the Appendices provides the source for the class.

‘Unconditional’ means here that the post-processing will be executed if the block terminates regularly or by a thrown exception. Other conditions can be injected into the \lstinline|Runnable|\autocite{ORACLE_DOC_RUNNABLE_INTERFACE} implementation.

The difference between this approach and simply calling \lstinline|doAfter.run()| in a \lstinline|finally| block is that the \lstinline|close()| method of \lstinline|PostProcessor| is invoked before any code in a \lstinline|catch| block (refer to chapter \tqfullref{sec:ExecutionSequence}).

The following code snippet could be a real-life example for where this is useful:
\begin{lstlisting}[numbers=left]
final var builder = new StringBuilder();

final Runnable addTrailer = () -> builder.append( "}\n" );

…

try( final var p = new PostProcessor( addTrailer ) )
{
    …
}
\end{lstlisting}
This ensures that the string in \lstinline|builder| always terminates with a closing curly brace followed by a linefeed.

Another sample is this code snippet:
\begin{lstlisting}[numbers=left]
final List<String> list = new LinkedList();

final Runnable forceSorting = () -> list.sort();

…

try( final var p = new PostProcessor( forceSorting ) )
{
    for( final var s : loadStrings() )
    {
        list.add( s );
    }
}
\end{lstlisting}
Here the \lstinline|PostProcessor| forces that the given list is always sorted after the values had been added.

\section{Date and Time Values}\label{sec:DateAndTimeValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Unique Ids}\label{sec:UniqueIds}
Data records stored to a database require a unique identifier in most cases. Sometimes, this identifier is provided externally – a social security number, an account number, or a tax id – but usually not. 

When the database will be accessed (and updated) from different locations, this identifier has to be \textit{universally} unique; alternatively, you can introduce a global service that provides such identifiers. But usually, this does make sense only when these identifiers are not only just technical – like the already mentioned social security numbers, account numbers, or tax ids.

How to get universally unique ids (UUID) is defined in RFC~4122\autocite{Leach:RFC4122}, among others. Java provides an implementation for these UUIDs with the class \lstinline|java.util.UUID|\autocite{ORACLE_DOC_UUID_CLASS}. Unfortunately, the class provides only one method that creates new arbitrary UUIDs (\lstinline|java.util.UUID::randomUUID()|\autocite{ORACLE_DOC_UUID:randomUUID}), and these are version~3 pseudo-random UUIDs.

These are large enough that collisions are unlikely, but when used as primary keys on a database table, the database indexing can get quite inefficient (lack of locality in the indexes). This is discussed in more detail in \autocite{Mihalcea:UUID_Database_Primary_Key}.

Partially, this is addressed by timebased UUIDs (version~1), and new formats will be discussed (see \autocite{Davis:NewUUIDs, Leach:RFC4122bis}), but another issue is that these UUIDs occupy at least 128~bit – when you use the binary format. But usually, the textual representation is used (mainly because the Java class \lstinline|UUID| does not provide a method to get the binary format), and that has even 288~bit (36~bytes or characters). I provide a utility class \lstinline|UniqueIdUtils|\autocite{TQUADRAT_ORG_FOUNDATION_UNIQUEIDUTILS} that provides some tools to address these issues. So it allows you to create timebased UUIDs or to get the binary representation from a UUID.

The already mentioned article in \autocite{Mihalcea:UUID_Database_Primary_Key} suggests to use shorter unique ids that should be timebased; the article refers to a the \verb#TSID_CREATOR# library\autocite{Lima:TSID_CREATOR}, but alternatively, my \lstinline|UniqueIdUtils| do also provide a \lstinline|TSID| type with 64~bit length.

Another issue with UUIDs is that it should not be \textit{too} easy to guess a valid instance. This means that a database sequence\autocite{TOAD_WORLD_BLOG:DatabaseSequence} that just increments a counter in order to get a new identifier is the worst choice in this regard.

\section{Utilising JMX}\label{sec:UtilisingJMX}
\section{-------------------------------------------- Proceed from here!}
See \ref{sec:Logging}, and there the part about warnings! Keeping track about failed logins.!!!
\lipsum[1]


\section{Finalisation}\label{sec:Finalisation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Deprecation of Elements}\label{sec:DeprecationOfElements}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Miscellaneous}
In this chapter I collected some dos and don'ts that do not fit into one of the other chapters, but are not relevant enough for a chapter on there own.

\begin{itemize}
\item{Avoid octal numerical literals in your source code! Although this feature exists since the first versions of Java, it is not very well known.

If you do not know what I talking about: start \verb#jshell#, type in \lstinline|021 + 021| and be surprised that the result is not the ultimate answer to life, the universe, and everything.\autocite{ADAMS_HITCHHIKERS_GUIDE}

Or to summarise it: Do not prefix integer literals with \verb#0#!}

\item{Avoid using an object to access a class (static) variable or method. If you cannot use a static import, refer the element through the class name instead. For example:
\begin{lstlisting}
public final class AClass
{
    public static final void classMethod() { … }
}
//  class AClass

…

import static some.package.AClass.classMethod;

public final class MyClass
{
    public final void myMethod()
    {
        // RECOMMENDED!
        classMethod(); // Using the static import
        
        // OK
        AClass.classMethod();
        
        // AVOID!!
        final var anObject = new AClass();
        …
        anObject.classMethod();
    }   //  myMethod()
}
    //  class MyClass
\end{lstlisting}

You can configure both Eclipse and IntelliJ IDEA to report the access to a static member of a class through an instance as a warning or even as an error.}

\item{In general, static imports are preferred over using the class name as prefix for references to static class members, either to class methods or to constants.}

\item{Try to initialise local variables where they are declared. The only reason not to initialise a variable where it's declared is if the initial value depends on some computation occurring first.}

\item{Avoid the multi-line initialisation for fields; use a constructor instead:
\begin{lstlisting}
public final class MyClass
{
    private final String m_Field;
    // AVOID!!!!!
    {                                                
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }
    
    /**
     *  Creates a new instance for {@code MyClass}.
     */
    public MyClass() 
    {                                                
        // INSTEAD DO IT IN THE CONSTRUCTOR!!
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }   //  MyClass()
}
//  class MyClass    
\end{lstlisting}}

\item{Try to call a method only when its result is needed. This is even more true if the method does not return a value but has other effects.

Although this may seem to be self-evident, you may find often code like this:
\begin{lstlisting}
// AVOID!!!
final var logMessage = composeMessage( params );
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    writeLog( logMessage );
}
…
\end{lstlisting}
or
\begin{lstlisting}
// AVOID!!!
{
    final var param1 = retrieveData( data1 );
    final var param2 = retrieveData( data2 );
    if( option )
    {
        process( param1 );
    }
    else
    {
        process( param2 );
    }
}
\end{lstlisting}
Instead, the samples should look like below:
\begin{lstlisting}
// RECOMMENDED
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    final var logMessage = composeMessage( params );
    writeLog( logMessage );
}

…

// RECOMMENDED
{
    final Data param;
    if( option )
    {
        param = retrieveData( data1 );
    }
    else
    {
        param = retrieveData( data2 );
    }
    process( param );
}
// RECOMMENDED/Using the trinary operator
{
    final var param = option 
        ? retrieveData( data1 )
        : retrieveData( data2 );
    process( param );
}
\end{lstlisting}
}

\item{Avoid anonymous classes! Although it (sometimes) reduces the code to write and the number of source files, it makes the resulting code very hard to read in most cases. And the number of generated class files remains exactly the same, no matter if anonymous classes, inner classes, non-\lstinline|public| or \lstinline|public| classes are used.

In most cases, you can use a lambda instead of an anonymous class.}

\item{If you are using collections or maps, declare and define them with generics.

If a legacy interface returns a collection or map that is not declared with generics, map it. The resulting warning can be suppressed using the \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} annotation.

Sometimes this may require the introduction of a temporary helper variable, as in the last sample, below.

\begin{lstlisting}
// AVOID!!
List x = new LinkedList(); 

// RECOMMENDED!!
List<String> x = new LinkedList<String>(); 

public abstract Vector method1();
public abstract Vector method2() throws IOException;
…
public static final void main( String... args )
{
    @SuppressWarnings( "unchecked" )
    final List<String> method1Result = method1();
    List<String> method2Result = null;
    try
    {
        @SuppressWarnings( "unchecked" )
        final List<String> temporary = method2();
        method2result = temporary;
    }
    catch( final IOException e ) { … }
}   //  main()
\end{lstlisting}}

\item{Using \lstinline|java.lang.Object| as the type parameter for a generic data type is useless in most cases and should be avoided:
\begin{lstlisting}
// AVOID!!!
private final List<Object> m_List = new LinkedList<Object>();
\end{lstlisting}
If you want to declare a variable of a generic type that should work for any parameter class, you have to use the question mark:
\begin{lstlisting}
Class<?> dataClass = data.getClass();
\end{lstlisting}}

\item{The classes \lstinline|java.util.Vector|\autocite{ORACLE_DOC_VECTOR_CLASS} or \lstinline|java.util.Hashtable|\autocite{ORACLE_DOC_HASHTABLE_CLASS} should not be used! Although their implementation had been modernised already with Java~1.2, their performance is still inferior to the alternative implementations, because \lstinline|Vector| and \lstinline|Hashtable| are still synchronised.

For method arguments and return values, you should use the interfaces \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} instead of \lstinline|Vector|, and \lstinline|java.util.Map|\autocite{ORACLE_DOC_MAP_INTERFACE} instead of \lstinline|Hashtable|. Refer also to chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} that elaborates further on this topic.

If you need an implementation of the \lstinline|List| interface, you should prefer \lstinline|java.util.ArrayList|\autocite{ORACLE_DOC_ARRAYLIST_CLASS} over \lstinline|java.util.LinkedList|\autocite{ORACLE_DOC_LINKEDLIST_CLASS}. The latter is only more performant in some very rare cases, and it also has a bigger memory footprint\footnote{Internally, an \lstinline|ArrayList| uses an array for the entries, and when this gets too small, a new array with twice the size will be allocated. This means that for some time two large array will exist. For really, really large lists, this may cause an issue. In the opposite, a \lstinline|LinkedList| will grow entry by entry.}.

Instead of \lstinline|Hashtable|, you should use \lstinline|java.util.HashMap|\autocite{ORACLE_DOC_HASHMAP_CLASS} as the implementation for the \lstinline|Map| interface.

If you really need a synchronised list, you can still consider to use \lstinline|Vector| as your implementation of \lstinline|List|, but for a syncronised implementation of \lstinline|Map|, you should take \lstinline|java.util.concurrent.ConcurrentHashMap|\autocite{ORACLE_DOC_CONCURRENTHASHMAP_CLASS}.}

\item{Use the enhanced \lstinline|for-loop| when iterating over collections\footnote{Ok, only implementations of \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} provide methods for random access.}. It is also preferred when iterating over arrays.

Alternatively, you can use an iterator, the \lstinline|java.lang.Iterable::forEach| method, or the Stream API:
\begin{lstlisting}
// AVOID!
for( var i = 0; i < list.length(); ++i )
{
    process( list.get( i ) );
}

// RECOMMENDED
for( final var element : collection ) process( element );

collection.forEach( this::process );

// OK
for( final var i = collection.iterator(); i.hasNext(); ) process( i.next() );

collection.stream()
    .forEach( this::process );
\end{lstlisting}

The Stream API allows you to filter the elements in the collection.}

\item{Consider to use the varargs feature when a method takes only one single argument, but can be called repeatedly with different arguments, or when it takes an array as argument:

\begin{lstlisting}
public final void addListener( final Listener... listeners ) { … }
\end{lstlisting}

instead of
\begin{lstlisting}
public final void addListener( final Listener listener ) { … }
\end{lstlisting}

Obviously, the implementation now has to deal with multiple entries, but it allows to write
\begin{lstlisting}
addListener( listener1, listener2, listener3 );
\end{lstlisting}
instead of
\begin{lstlisting}
addListener( listener1 );
addListener( listener2 );
addListener( listener3 );
\end{lstlisting}
making the code easier to read.}

\item{Prefer \lstinline|java.lang.CharSequence|\autocite{ORACLE_DOC_CHARSEQUENCE_INTERFACE} over \lstinline|java.lang.String| for the type of method arguments. See also chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} on the topic of argument and return types.}

\item{“Forever” loops should be coded as
\begin{lstlisting}
ForeverLoop: while( true ) 
{ 
    … 
    
    //---* Terminate the loop *--------------------------------------
    if( <condition> ) break ForeverLoop;
}   //  ForeverLoop:
\end{lstlisting} }

\item{Do not use \lstinline|new String()| with a string constant or a string expression as the argument. There are only very few situations where this is useful or necessary, and most of them are related to JNI. Usually \lstinline|new String()| is a waste of memory and computing time, except you use if with a \lstinline|byte|, \lstinline|char| or \lstinline|int| array as the argument. Refer to \autocite{ORACLE_DOC_STRING_CLASS} for the details.}

\item{Some programmers do not like the Autoboxing feature that was introduced with Java~5. It is up to you to use it, or to transform the primitive types explicitly into their corresponding object types and vice versa.\footnote{Nevertheless, you should consider “\ref{lst:ZoP:ExplicitVsImplicit}.~Explicit is better than implicit, and verbosity is your friend” – see chapter \tqvref{sec:TheBasicRule}.}}

\item{If a constructor calls a method of its own class or a superclass, this method has to be \lstinline|static|, \lstinline|private|, or \lstinline|final|\footnote{The important setting is \lstinline|final|, because \lstinline|private| and \lstinline|static| methods are implicitly \lstinline|final|}.

In addition, it may call another constructor of the same or the super class, using \lstinline|this()| or \lstinline|super()|.}

\item{Ensure that the main thread (that one that executes \lstinline|main()|) always dies as the last non-deamon thread.

This means that you should keep a reference of all the threads that your code starts so that you can kill them explicitly before the program terminates.}

\item{Ensure that assertions\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert,ORACLE_DOC_ASSERTIONS} are enabled during testing and disabled in production.

To enable assertions, add \verb#-ea# or \verb#-enableassertions# to the JVM command line.}

\item{Although releasing resources when they are no longer needed is a good idea in most cases, it can cause trouble in rare occasions.

I found a code sequence like this in some real life code:
\begin{lstlisting}
…
}
catch( Exception e )
{
    PrintStream ps = new PrintStream( System.out );
    ps.println( "Error occured" );
    e.printStackTrace( ps );
    ps.close()
}
\end{lstlisting}
This will not only close the \lstinline|PrintStream| \lstinline|ps|, but also the wrapped \lstinline|System.out| stream – with the consequence, that this exception was the last that was displayed on the console (or written to the log output).

So make sure that your code will only cleans up objects that your code is responsible for, either because it created them or the responsibility was clearly delegated to it. In case of a wrapper (like most implementations of \lstinline|java.io.InputStream|, \lstinline|java.io.OutputStream| \lstinline|java.io.Reader| and \lstinline|java.io.Writer|), your code should not call methods like \lstinline|close()| if it is not responsible for the wrapped object, as in most cases the wrapper would delegate them to the wrapped object.

If your code has to provide references to resources to 3\textsuperscript{rd}~party code, you should consider to protect those resources from being freed (if required). For an instance of \lstinline|PrintStream|, this could look like this:
\begin{lstlisting}
…
final var tempStream = new PrintStream( myStream ) 
{
    /**
     *  {@inheritDoc}
     */
    @Override
    public void close() { /* Does nothing! */ }
};
externalMethodWritingToPrintStream( tempStream );
…
\end{lstlisting}}


\item{This is about the usage of “\verb#++#” and “\verb#--#”, because they have both a prefix and postfix notation.

The prefix notation will change the value first and returns the new value, while the postfix version will return the current value and change it afterwards. So the usage of prefix or postfix notation depends from the context.

In case where the return value is not used immediately, it is strongly recommended to use the prefix notation always. This is especially true in \lstinline|for| loops.

Examples:
\begin{lstlisting}
// DISCOURAGED
for( int i = 0; i < max; i++ )
{
    …
}

// RECOMMENDED
for( int i = 0; i < max; ++i )
{
    …
}
\end{lstlisting}

Confessed, this is an \textit{early} optimisation (to avoid “premature”), and most implementations of the Java compiler will translate the postfix version into the same binary code as for the prefix version if the return value is not used\footnote{If not the javac, probably the JIT will do.}. But developing the habit to prefer the prefix notation have no costs, and it may spare some cycles when using other languages than Java, or when the compiler does not optimise.}\label{item:PrefixVsPostfix}

\item{Avoid setting several variables to the same value in a single statement. It is hard to read.

Example:
\begin{lstlisting}
// AVOID!
fooBar.fChar = barFoo.lChar = 'c'; 
\end{lstlisting}
Avoid to use the assignment operator in a place where it can be easily confused with the equality operator. If you really do not see another option, make sure that it cannot be confused.

Example:
\begin{lstlisting}
// AVOID!
boolean flag;
while( flag = !isEmpty() ) { … }
\end{lstlisting}
should be written as
\begin{lstlisting}
boolean flag;
while( (flag = !isEmpty()) == true ) { … }
\end{lstlisting}
if it is really necessary to have the assignment at this place.

As Java do not allow other than boolean expression for conditions, something like
\begin{lstlisting}
// DOES NOT WORK!
while( c++ = --d ) { … }
\end{lstlisting}
is not possible. But a common pattern is
\begin{lstlisting}
BufferedReader reader = …
String line = "";
while( (line = reader.readLine()) != null ) { … }
\end{lstlisting}
Do not use embedded assignments in an attempt to improve run-time performance. This is the job of the compiler. 

Example: 
\begin{lstlisting}
// AVOID!
d = (a = b + c) + r;        
\end{lstlisting}
should be written as 
\begin{lstlisting}
a = b + c;
d = a + r;}
\end{lstlisting}}

\item{It is generally a good idea to use parentheses liberally in expressions involving mixed operators to avoid operator precedence problems. Even if the operator precedence seems clear to you, it might not be to others – you should not assume that other programmers know the precedence rules as good as you do.
\begin{lstlisting}
// AVOID!
if( a == b && c == d ) { … }

// BETTER
if( (a == b) && (c == d) ) { … }
\end{lstlisting}

If an expression containing a binary operator appears before the “\verb#?#” in the ternary “\verb#?:#” operator, it should be parenthesized.
 
Example:
\begin{lstlisting}
(x >= 0) ? x : -x;
\end{lstlisting}
}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}
\end{itemize}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{-------------------------------------------- Proceed from here!}
    • If there is a getter for a field, it should be used even by the methods of the same class. Usually the same yields for setters, but there are exceptions from that rule3, in case a field can be set internally to values that are invalid if set from the outside. In such cases the direct access to the field has to be commented accordingly.
    • 
    • A method or constructor should not have more than 7 (in words: seven) arguments. If you feel inclined to provide more arguments to construct an instance, consider to use an instance of Map instead.
    • Do not use BitFields, at least do not expose them to the API. Although the Java API is using them itself, they are still problematic.
    • Whenever you have to convert a date, time or date-time value to a String that is not primarily meant to be display, used an internal format that is independent from any locale. Our recommendation is to use the ISO 8601 format “YYYY-MM-dd'T'hh:mm:ss.SSS”, normalised to UTC, and to use the class SimpleDateFormat to format the date.4
    • 
    • …





\include{6_Summary}

\chapter{Appendices}

\section{The Naming Dictionary}\label{sec:TheNamingDictionary}
The names of program elements provide an implicit contract (or at least a kind of commitment) between the original author of the program and its users/maintainers. But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts here, together with a list of suffixes for class names.

\subsection{Verbs}
This chapter provides a list of verbs\footnote{Ok, some names or prefixes are not verbs, like ‘main’, ‘from’ or ‘to’~…} to be used with method names and a description of their implicit contract. These verbs are usually prefixes to a method name, although some of them could be used as standalone names, too. The form that used more often is mentioned first.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{Verbs.tbl.tex}

That a method name is built using one of the verbs above does not free you from providing a proper JavaDoc comment that describes the purpose of the method in detail, together with the arguments, return values and exceptions.

\subsection{Suffixes for Class Names}\label{sec:SuffixesForClassNames}
This chapter lists defined suffixes for class names and their function.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{ClassNameSuffixes.tbl.tex}

\section{Configurable Errors and Warnings}\label{sec:ConfigurableErrorsAndWarnings}
A very convenient feature of most IDE's is the capability to configure additional warnings and even errors for the compilation.

\subsection{Eclipse}\label{sec:EclipseErrorsAndWarnings}
tdb

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJErrorsAndWarnings}
tdb

\section{IDE Configuration}\label{sec:IDEConfiguration}
This chapter provides samples of configuration files for some IDEs. See also the chapter \tqvref{sec:ConfigurableErrorsAndWarnings} about the errors and warnings that can be configured in Eclipse and IntelliJ IDEA.

\subsection{Eclipse}\label{sec:EclipseConfiguration}
tbd

\subsubsection{Snippets}
This chapter provides the XML code for Eclipse snippets.

\paragraph{Structuring Comments}\label{sec:SnippetStructuringComments}
The snippets for the structuring comments as defined in chapter \tqfullvref{sec:StructuringComments}.
\begin{lstlisting}[language=XML,basicstyle=\ttfamily\footnotesize]
<?xml version="1.0"
      encoding="UTF-16" 
      standalone="no"?>
<snippets>
    <category filters="*"
              id="category_1145179107125"
              initial_state="0"
              label="Structuring Comments"
              largeicon=""
              smallicon="">
        <description><![CDATA[Structuring Comments as defined by the Code Conventions]]></description>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145232938375"
              label="Enum Declaration"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the enum definition part]]></description>
            <content><![CDATA[        /*------------------*\
    ====** Enum Definitions **=================================================
        \*------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179869843"
              label="Inner Classes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the inner classes part]]></description>
            <content><![CDATA[        /*---------------*\
    ====** Inner Classes **====================================================
        \*---------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251889697104"
              label="Constants"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for constants.]]></description>
            <content><![CDATA[      /*-----------*\
    ====** Constants **========================================================
        \*-----------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251888677777"
              label="Attributes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for attributes.]]></description>
            <content><![CDATA[      /*------------*\
    ====** Attributes **=======================================================
        \*------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179436656"
              label="Static Initialisations"
              largeicon="" smallicon="">
            <description><![CDATA[The header comment for the static initialisations part]]></description>
            <content><![CDATA[        /*------------------------*\
    ====** Static Initialisations **===========================================
        \*------------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180117906"
              label="Constructors"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the constructors part]]></description>
            <content><![CDATA[    	/*--------------*\
    ====** Constructors **=====================================================
        \*--------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180168796"
              label="Methods"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the methods part]]></description>
            <content><![CDATA[    	/*---------*\
    ====** Methods **==========================================================
        \*---------*/
]]></content>
        </item>
    </category>
</snippets>
\end{lstlisting}

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJConfiguration}
tbd

\section{Embedded Code}
Sometimes, it is necessary to embed code inside the Java source code. Most often, these are SQL statements, but sometimes it could be also fragments of HTML or XML documents.

\subsection{Formatting SQL inside Java}\label{sec:FormattingSQLInsideJava}

\subsection{Formatting XML inside Java}\label{sec:FormattingXMLInsideJava}
You should embed only small fragments of an XML document into the Java source; larger fragments and full documents can be handled better when provided as resources.

\subsection{Formatting HTML inside Java}\label{sec:FormattingHTMLInsideJava}
Same as for XML, also only small HTML fragments should be embedded into the Java source code. Anything else should go into a resource file.

\section{The Reason why Prefix Notation should be preferred over Postfix Notation}
At chapter \tqvref{item:PrefixVsPostfix} I recommend to use always the prefix version of an unary operator if the result of the operation is not further used. This has its reason in the implementation for the operators \verb#++# and \verb#--#. As a C++ method, the prefix implementation may look like this:
\begin{lstlisting}[language=C++]
int prefixIncrement( int& n )
{
    n = n + 1;
    return n;
}
\end{lstlisting}
and the postfix version would look like this:
\begin{lstlisting}[language=C++]
int postfixIncrement( int& n )
{
    int oldValue = n;
    n = n + 1;
    return oldValue;
}
\end{lstlisting}
So the postfix version has an additional stack operation that is not necessary if the return value is discarded anyway. This saves only nanoseconds for a single operation, but used in a loop, and in an application server environment, these nanos will sum up to minutes over time.

I confess that there are other possible locations where one can save more CPU cycles, and I also know the advice not to begin too early with optimisations (to “avoid premature optimisation”). My opinion is that this is not an optimisation but a best practice, and that every cycle counts – especially if it is that easy to achieve.

As said also already, most Java compilers (and not only these) will optimise the particular code, but different Java compilers optimises this pattern differently (meaning some even do not touch it – for example that one for the LEGO® Mindstorms Controller~…), and even the runtime optimisation will treat it differently, so just from this point of view I would recommend this simple change of one's personal habits.

\section{Examples}\label{sec:Examples}

\subsection{AutoLock}\label{sec:AutoLock}
This class is a sample implementation of the idea described in chapter \tqfullvref{sec:Lifecycle}, like a PoC; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={AutoLock.java}]{AutoLock.java}

\subsection{Illegal Argument Exceptions}\label{sec:IllegalArgumentExceptions}
As said in chapter \tqfullvref{sec:CheckingMethodParametersAndReturnValues}, a \lstinline|NullPointerException| that is thrown from your code has to be seen as a coding bug: a value was not properly checked before it was used. Nevertheless, values can be \lstinline|null|, for various reasons, and this still can be an error that needs to be signalled.

For that, I suggested a bunch of custom exceptions that are shown here; they are also part of my Foundation Library: for \lstinline|ValidationException| see \autocite{TQUADRAT_ORG_FOUNDATION_VALIDATIONEXCEPTION}, the \lstinline|NullArgumentException| can be found at \autocite{TQUADRAT_ORG_FOUNDATION_NULLARGUMENTEXCEPTION}, the \lstinline|EmptyArgumentException| is documented at \autocite{TQUADRAT_ORG_FOUNDATION_EMPTYARGUMENTEXCEPTION}, and finally the documentation for \lstinline|BlankArgumentException| is at \autocite{TQUADRAT_ORG_FOUNDATION_BLANKARGUMENTEXCEPTION}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={ValidationException.java}]{ValidationException.java}

\lstinputlisting[numbers=left,caption={NullArgumentException.java}]{NullArgumentException.java}

\lstinputlisting[numbers=left,caption={EmptyArgumentException.java}]{EmptyArgumentException.java}

\lstinputlisting[numbers=left,caption={BlankArgumentException.java}]{BlankArgumentException.java}

\subsection{Lazy}\label{sec:Lazy}
The interface \lstinline|Lazy| and the associated implementation \lstinline|LazyImpl| provide a holder for a lazy initialised object instance. The initialisation happens on the first call to the method \lstinline|Lazy::get| through a call to the \lstinline|Supplier| instance the \lstinline|Lazy| instance was created with.

\begin{lstlisting}
public final class MyClass
{
    /**
     *  An attribute of type
     *  {@link AClass}.
     */
    private final Lazy<AClass> m_Attribute;
    
    public MyClass()
    {
        m_Attribute = Lazy.use( ()-> new AClass( this ) );
    }
    
    public final void myMethod()
    {
        m_Attribute.get().aMethod();
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

\lstinline|Lazy| is part of my Foundation Library and can be found at \autocite{TQUADRAT_ORG_FOUNDATION_LAZY}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={Lazy.java}]{Lazy.java}

\lstinputlisting[numbers=left,caption={LazyImpl.java}]{LazyImpl.java}

\subsection{MountPoint}\label{sec:MountPoint}
The annotation \lstinline|@MountPoint| and how to use it is described in the chapters \tqfullvref{sec:NonFinalClasses} and \tqfullvref{sec:NonFinalMethods}.

The annotation is part of my foundation library, refer to \autocite{TQUADRAT_ORG_FOUNDATION_MOUNTPOINT}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={MountPoint.java}]{MountPoint.java}

\subsection{Patch Identification}\label{sec:PatchIdentification}
The chapter \tqfullvref{sec:MaintenanceComments} discussed how to mark areas in the code that has been changed to fix a bug. There I suggested to use annotations for this task.

This can look like this:
\begin{lstlisting}[numbers=left]
@BUG( id  = "BUG-123456", comment = "Introduced base class MyClassBase" )
public final class MyClass extends MyClassBase
{
    @BUG( id = "BUG-100000", comment = "Made generic; added Typ 'String'" )
    @BUG( id = "BUG-100003", comment = "Changed type to 'CharSequence'" )
    private final List<CharSequence> m_Texts = new LinkedList<>();

    @BUG( id  = "BUG-123456", comment = "Introduced base class MyClassBase; calling super()" )
    public MyClass()
    {
        super();
    }   //  MyClass()
    
    @BUG( id = "BUG-100003", comment = "Changed type to 'CharSequence'" )
    @BUG( id = "BUG-100022", comment = "Made generic; changed to 'extends CharSequence'" )
    @BUG( id = "BUG-123456", comment = "Introduced base class MyClassBase; added @Override" )
    @Override
    public final <T extends Charsequence> void addText( final T text ) { … }
}
//  class MyClass
\end{lstlisting}

That the same annotation can be applied multiple times to the same element requires a “container annotation” for that annotation\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:RepeatableAnnotationInterfaces}, but the use of this annotation is implicit.

The annotations \lstinline|@BUG| and \lstinline|@FixList| (the “container annotation”) are part of the Foundation Base project\autocite{TQUADRAT_ORG_FOUNDATION_BASE, TQUADRAT_ORG_FOUNDATION_BUG, TQUADRAT_ORG_FOUNDATION_FIXLIST}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={FixList.java}]{FixList.java}

\lstinputlisting[numbers=left,caption={BUG.java}]{BUG.java}

\subsection{PostProcessor}\label{sec:PostProcessor}
This implementation is basically a PoC; currently it is not part of any library.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={PostProcessor.java}]{PostProcessor.java}

\subsection{ThreadGroup}\label{sec:ThreadGroup}
The class \lstinline|java.lang.ThreadGroup|\autocite{ORACLE_DOC_THREADGROUP_CLASS} provides a method \lstinline|uncaughtException()| that has the same signature as the \lstinline|UncaughtExceptionHandler::uncaughtException|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER:uncaughtException} method.

The method \lstinline|java.lang.ThreadGroup:uncaughtException| is called by the Java Virtual Machine when a thread in this thread group stops because of an uncaught exception, and no specific \lstinline|Thread.UncaughtExceptionHandler|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER_INTERFACE} instance was installed
to that thread.

The default implementation of that method does the following:
\begin{enumerate}
\item{If this thread group has a parent thread group, the \lstinline|uncaughtException()| method of that parent is called with the same two arguments.}
\item{Otherwise, this method checks to see if there is a default uncaught exception handler installed, and if so, its \lstinline|uncaughtException()| method is called with the same two arguments.}
\item{Otherwise, this method determines if the \lstinline|Throwable| argument is an instance of \lstinline|java.lang.ThreadDeath|. If so, nothing special is done.

Otherwise, a message containing the thread's name, as returned from the thread's \lstinline|getName()| method, and a stack backtrace, using the \lstinline|Throwable|'s \lstinline|printStackTrace()| method, is printed to the standard error stream.}
\end{enumerate}

Unfortunately, the class \lstinline|java.lang.ThreadGroup| itself does not provide an API to change the behaviour of its \lstinline|uncaughtException()| method. To do that, you have to override that method in a subclass.

Below you find an implementation of \lstinline|ThreadGroup| that fixes that. A similar class is also part of my Foundation library – see \autocite{TQUADRAT_ORG_FOUNDATION_BASE, TQUADRAT_ORG_FOUNDATION_THREADGROUP}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={ThreadGroupExt.java}]{ThreadGroupExt.java}

\subsection{UnsupportedEnumError}\label{sec:UnsupportedEnumError}
This implemenation of \lstinline|java.lang.Error| is meant to be used in the \lstinline|default| branch of a \lstinline|switch| statement (refer to \tqfullvref{sec:SwitchStatements}), in cases where the selector is an enum.

It will be used like this:
\begin{lstlisting}[numbers=left]
enum Color
{
    RED, BLUE, GREEN, YELLOW
}

Color color = …    

// Traditional switch statement
switch( color )
{
    case RED: …; break;
    case BLUE: …; break;
    case GREEN: …; break;
    case YELLOW: …; break;

    default: throw new UnsupportedEnumError( color );
}

// New switch statement
switch( color )
{
    case RED -> …;
    case BLUE -> …;
    case GREEN -> …;
    case YELLOW -> …;

    default: throw new UnsupportedEnumError( color );
}

// switch expression
var result = switch( color )
{
    case RED -> "Rot";
    case BLUE ->"Blau";
    case GREEN -> "Grün";
    case YELLOW -> "Gelb";

    default: throw new UnsupportedEnumError( color );
}
\end{lstlisting}

Also refer to \autocite{TQUADRAT_ORG_FOUNDATION_UNSUPPORTEDENUMERROR}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={UnsupportedEnumError.java}]{UnsupportedEnumError.java}

\listoftables

\lstlistoflistings

\begin{FlushLeft}
\printbibliography
\end{FlushLeft}

\printindex
\end{document}
