%\RequirePackage{lmodern}
\documentclass[11pt,a4paper, titlepage, parskip=half, headsepline, footsepline, cleardoublepage=current, headheight=1cm]{scrbook}
%\usepackage{DejaVuSansMono}
\usepackage{dejavu}
%\usepackage[T1]{fontenc}
\usepackage{scrhack}
\usepackage{graphicx} 
\usepackage[manualmark]{scrlayer-scrpage}
%\usepackage[utf8]{inputenc}
\usepackage{tocbasic}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{eurosym}
\usepackage{ragged2e}
\usepackage{textcomp}
\usepackage{framed}
\usepackage{ltxtable}
\usepackage{filecontents}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,gray]{xcolor}
\usepackage{listings}
\usepackage[inline]{enumitem}
\usepackage{varioref}
\usepackage[iso,english]{isodate}
\usepackage{makecell}
\usepackage[english]{babel}
\usepackage[babel]{csquotes}

\usepackage{lipsum}

\usepackage[style=numeric, urldate=iso, date=iso, seconds=true, backend=biber]{biblatex}
\usepackage{nameref}
\usepackage[colorlinks=true]{hyperref}

\addbibresource{JavaCodingConventions.bib}

\automark[section]{chapter}
\lehead*[]{\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}~~\headmark}
\rohead*[\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}]{\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}}

\lstset{
language=Java,
%morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield},
morekeywords={var,yield},
backgroundcolor=\color[gray]{.9},
frame=single,
framerule=0.2pt,
basicstyle=\ttfamily\footnotesize,
commentstyle=\color[gray]{.2}\itshape,
keywordstyle=\color[gray]{.4}\bfseries,
identifierstyle=\bfseries,
stringstyle=\itshape,
xleftmargin=.2cm,
xrightmargin=.2cm,
breaklines=true,
breakatwhitespace=true,
inputencoding=utf8,
extendedchars=true,
literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
  {©}{{\copyright}}1
  {…}{{\dots }}2
  {–}{{--}}1
}

\colorlet{shadecolor}{gray!10}
\makeindex

%---* New Commands *-----------------------------------------------------------
\newcommand*{\tqfullref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”}}
\newcommand*{\tqfullvref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”} on page \pageref{#1}}
\newcommand*{\tqref}[1]{\hyperref[{#1}]{\ref*{#1}}}
\newcommand*{\tqvref}[1]{\hyperref[{#1}]{\ref*{#1}} on page \pageref{#1}}

\begin{document}
\isodate
\titlehead{\includegraphics[height=4cm]{Logo_gross}}
\author{Thomas Thrien\\(thomas.thrien@tquadrat.org)}
\title{Extended Coding Conventions for Java}
\subtitle{Coding and Formatting Guidelines, Recommendations and Best Practices}
\date{\today}
\maketitle
\tableofcontents

\include{1_Introduction}
\include{2_FormattingTheSourceCode}
\include{3_NamingConventions}
\include{4_WritingProperComments}

\chapter{Coding Guidelines}\label{sec:CodingRules}
These guidelines are a collection of coding standards and best practices. Obeying them should make your code better readable and less error prone. Some of them will even help to increase the program's overall performance. So perhaps you should see them not as optional, but more as obligatory rules.

As always there may be good reasons to do it different from what is recommended or even requested by the guidelines\footnote{You remember the bullet points~\ref{lst:ZoP:SpecialCases} and \ref{lst:ZoP:Practicality} from the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython, PYTHON_ORG_MAILING_LIST:ThePythonWay} that I quoted in chapter \tqvref{sec:OtherProgrammingLanguages}?}. In such case a comment is required that describes that reason.\footnote{Omitting this comment is also a deviance from the rule, requiring a comment to explain it. Also known as the Catch~22.}

One basic recommendation is that you should not write the same code over and over again. This is also known as the “DRY Principle” (“Don't Repeat Yourself”) and we will discuss this later again.

And please keep in mind that not always the shortest, most compact source code is the best. Also avoid what is known as “Premature Optimization”\footnote{Donald E. Knuth made the following statement on optimisation: “We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil.”\autocite{Knuth:PrematureOptimization}}. Modern optimising compilers and run-time optimisers do a very good job to create compact object code, so in most cases the programmer can concentrate fully on writing readable and comprehensible code. In this context I would like to remind you on the quotation from Martin Fowler's book that I put in front of this document, and again to the “Zen of Python”, here the points “\ref{lst:ZoP:SimpleVsComplex}.~Simple is better than complex” and “\ref{lst:ZoP:ComplexVsComplicated}.~Complex is better than complicated”.\footnote{Yes, I know: for a document about Java Coding Conventions, there is an astonishing amount of references to Python~…}

But although optimisation still may have some limits, comments will have never any impact on the runtime performance of a program. So please refer to chapter \tqfullvref{sec:CommentsWhen} (if not done already) and see the recommendations on when to apply comments to your code.

\subsubsection{Types of Products}\label{sec:TypesOfProducts}
Some of the coding guidelines below are different for the type of product or project you are working on. Basically, we can distinguish the following types that will be explained in the following chapters\footnote{If you miss the terms ‘Framework’ and ‘Server’ on the list above: a \textit{Framework} is in this regard a \textit{Feature Library}, and a \textit{Server} is a \textit{Standalone Application} (what else could a server be?).}:
\begin{itemize}[nosep]
\item{Function Libraries}
\item{Feature Libraries}
\item{Tools}
\item{Standalone Applications}
\item{Server-based Applications}
\item{Extensions}
\end{itemize}
The individual types cannot be clearly distinguished one from another, there are some overlappings and gray areas. So when applying a guideline, you still have to use your judgement which implementation really fits for \textit{your project}.

\paragraph{Function Library}\label{sec:FunctionLibrary}
A function library is a collection of functions (often organised in utility classes – refer to chapter \tqvref{sec:UtilityClasses}) and helper classes. A function library does not have a state or requires an initialisation or configuration.

Samples are my Foundation Util library\autocite{TQUADRAT_ORG_FOUNDATION_UTIL}, the Commons Lang library from the Apache Commons project\autocite{APACHE_COMMONS_LANG}, or Google Guava\autocite{GOOGLE_GUAVA}.

My JavaComposer library\autocite{TQUADRAT_ORG_FOUNDATION_JAVACOMPOSER} is a sample for the beforementioned ‘gray area’: I decided to treat it as a function library, but it could have been a feature library, too. The various XML parsers and JSON parsers/generators will also belong to this gray area. 

\paragraph{Feature Library}\label{sec:FeatureLibrary}
A feature library adds a service or a complex functionality to your application. Quite often that functionality runs in its own thread(s) and is accessed like an external service, it has its own configuration and initialisation.

Sometimes these libraries can even be started standalone.

Samples for this are the various JDBC drivers, the H2 Database Engine\autocite{H2_DATABASE}, ActiveMQ\autocite{APACHE_ACTIVEMQ}, Jetty\autocite{ECLIPSE_JETTY}, or Hibernate\autocite{HIBERNATE_ORM}.

In the gray area here I would place JUnit\autocite{JUNIT5} and Log4j\autocite{APACHE_LOG4J}.

\paragraph{Tool}\label{sec:Tool}
A tool in this context is a program that is started, performs a single task and terminates afterwards. Most probably it will be invoked from the command line, and it will not have a UI, but takes all input data somehow from the command line. Perhaps it may even work as a filter\autocite{WIKIPEDIA:Filter}, reading from standard input and writing to standard output.

Programs like \verb#ls# or \verb#grep# belongs to this type, although they are of course not written in Java.

Gray area candidates are \verb#awk# and also \verb#sed#, but even \verb#javac#, the Java compiler, or \verb#javadoc#.

\paragraph{Standalone Application}\label{sec:StandaloneApplication}
A standalone application will run indefinitely (meaning until deliberately terminated by the user) and takes input continuously. Samples are a text editor, an IDE, an application server like WebSphere\autocite{IBM_WEBSPHERE} or a web container like Tomcat\autocite{APACHE_TOMCAT}.

\paragraph{Server-based Application}\label{sec:ServerbasedApplication}
Server-based applications are applicationn that require a special environment to be executed; the best example are JEE applications that need an application server like JBoss\autocite{REDHAT_JBOSS}, WebLogic\autocite{ORACLE_WEBLOGIC} or WebSphere\autocite{IBM_WEBSPHERE}, and web applications, requiring Tomcat\autocite{APACHE_TOMCAT} or any of the appservers mentioned before.

In this case, the program code has to follow several special rules, determined by the server environment. On the other side the enviroment provides several services that can be used by the application.

Other samples are Maillets for James\autocite{APACHE_JAMES} or the customisations (“mods”) for Minecraft\autocite{MINECRAFT} (although these could be regarded both as the gray area candidates here, because both could be seen also as extensions).

\paragraph{Extension}\label{sec:Extension}
An extension or a plugin requires also an environment to run in, but it is not an application as such. It just changes the behaviour of that environment. Annotation processors are samples for this (they change the behaviour of the Java compiler), as well as Maven\autocite{APACHE_MAVEN} plugins.

\include{5_CodingGuidelines_ErrorHandling}

\section{Checking Method Parameters and Return Values}\label{sec:CheckingMethodParametersAndReturnValues}
A \lstinline|NullPointerException| that is thrown by your code indicates a serious bug: it reveals that either a method argument or a return value was not properly checked before it was further used.

Your code should never throw a \lstinline|NullPointerException|!\footnote{And, of course, it should also never catch it. A \lstinline|NullPointerException| should be treated like an \lstinline|Error|.} Nevertheless, values can still be \lstinline|null|, for various reasons, and if this is indicating an error condition, this has to be signalled.

Consequently, you need to check the arguments for each and every method and constructor. But as these checks are not for free, it could be acceptable to omit these checks for \lstinline|private| methods and constructors, when the caller guarantees that the arguments are valid. But even then you should consider to check the arguments with assertions\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert, ORACLE_DOC_ASSERTIONS}, at least for methods (for constructors that calls to \lstinline|this()| or \lstinline|super()|, this has to be the very first statement; no \lstinline|assert| statement can be placed before it).

\begin{lstlisting}
public final class MyClass
{
    private MyClass( final String value )
    {
        assert nonNull( value ) : "value is null";
        
        m_Value = value;
    }   //  MyClass()
    
    private final void myMethod( final String value )
    {
        assert nonNull( value ) : "value is null";
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
    
    public static final MyClass myFactory( final String value1, final String value2 )
    {
    	final var retValue = nonNull( value1 ) ? new MyClass( value1 ) : null;
    	if( nonNull( retValue ) && nonNull( value2 ) ) retValue.myMethod( value2 );
    }   //  myFactory()
}
//  class MyClass
\end{lstlisting}
As said in the Java Language Specification\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert}:
\begin{quotation}
“[Because they can be disabled], assertions should not be used for argument checking in \lstinline|public| methods. Argument checking is typically part of the contract of a method, and this contract must be upheld whether assertions are enabled or disabled.

A secondary problem with using assertions for argument checking is that erroneous arguments should result in an appropriate run-time exception […]. An assertion failure will not throw an appropriate exception. Again, it is not illegal to use assertions for argument checking on public methods, but it is generally inappropriate. It is intended that \lstinline|AssertionError| never be caught, but it is possible to do so, thus the rules for \lstinline|try| statements should treat assertions appearing in a \lstinline|try| block similarly to the current treatment of throw statements.”
\end{quotation}

You can also delegate the argument check to another method:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
    
    public static final MyClass myFactory( final String value1, final String value2 )
    {
    	//---* Null check is done by constructor *----------------------
    	final var retValue = new MyClass( value1 );
    	
    	//---* Null check is done by myMethod() *-----------------------
    	retValue.myMethod( value2 );
    }   //  myFactory()
}
//  class MyClass
\end{lstlisting}

In case the problematic \lstinline|null| value is an argument to a method or to a constructor, you should throw an \lstinline|java.lang.IllegalArgumentException|\autocite{ORACLE_DOC_ILLEGALARGUMENTEXCEPTION_CLASS}:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new IllegalArgumentException( "value is null" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

As this check is quite common, I suggest to create a custom exception for this purpose: \lstinline|NullArgumentException|, extending \lstinline|java.lang.IllegalArgumentException|; chapter \tqvref{sec:IllegalArgumentExceptions} provides sample implementations for this and the other exceptions discussed here. With that the sample looks like this:
\begin{lstlisting}
public final class MyClass
{
    public MyClass( final String value )
    {
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        
        m_Value = value;
    }   //  MyClass()
    
    public final void myMethod( final String value )
    {
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        
        if( value.equals( m_Value ) ) …
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

You may have noticed that I always use \lstinline|isNull()|\autocite{ORACLE_DOC_OBJECTS:isNull} and \lstinline|nonNull()|\autocite{ORACLE_DOC_OBJECTS:nonNull}\footnote{Both methods are defined in the class \lstinline|java.util.Objects|\autocite{ORACLE_DOC_OBJECTS_CLASS} that will be discussed in more detail later in this chapter.} instead of \lstinline|… == null| and \lstinline|… != null|. I think that the method calls are easier to read than the \verb#==# and \verb#!0# operators.

Foreign code will still throw a \lstinline|NullPointerException| if called with \lstinline|null|, but we are not allowed to catch that …

This means that we have to check the values before we call that foreign code. That's easy for a method, we already check all arguments. But what if we have to call the constructor of a super class?
\begin{lstlisting}
public final class MyClass extends ForeignClass
{
    public MyClass( final String value )
    {
        // WILL NOT COMPILE!!
        if( isNull( value ) ) throw new NullArgumentException( "value" );
        super( value );
    }   //  MyClass()
}
//  class MyClass
\end{lstlisting}

The solution is to have a method that is doing the \lstinline|null| and throwing the \lstinline|NullArgumentException| if that fails. Then our sample may look like this:

\begin{lstlisting}
public final class MyClass extends ForeignClass
{
    public MyClass( final String value, final Data data )
    {
        super( requireNonNullArgument( data, "data" ) );
        
        m_Value = requireNonNullArgument( value, "value" );
    }   //  MyClass()
    
    public final void myMethod( final String value, final Data data )
    {
        if( requireNonNullArgument( value, "value" ).equals( m_Value ) && requireNonNullArgument( data, "data" ).equals( getData() ) )
        {
            …
        }
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

The method \lstinline|requireNonNullArgument()| looks like this\footnote{This one and the other methods in this chapter are implemented in the class \lstinline|org.tquadrat.foundation.lang.Objects|\autocite{TQUADRAT_ORG_FOUNDATION_OBJECTS} that also provides reimplementations of the methods from \lstinline|java.util.Objects|.}:
\begin{lstlisting}[numbers=left,caption={requireNonNullArgument()}]
/**
 *  Checks if the given argument {@code a} is {@code null} and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}.
 *
 *  @param  <T> The type of the argument to check.
 *  @param  a   The argument to check.
 *  @param  name    The name of the argument; this is used for the 
 *      error message.
 *  @return The argument if it is not {@code null}.
 *  @throws NullArgumentException   {@code a} is {@code null}.
 */
public static final <T> T requireNonNullArgument( final T a, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );
    if( isNull( a ) ) throw new NullArgumentException( name );

    //---* Done *----------------------------------------------------
    return a;
}   //  requireNonNullArgument()
\end{lstlisting}

In general, it is a good idea to check the arguments for a method or a constructor is as soon as possible, but is needs to be checked latest before it is used in some way.

We can check an argument for being empty, and Strings can be even tested for being blank, in the same way as for the null check:
\begin{lstlisting}[numbers=left,caption={requireNotEmptyArgument()}]
/**
 *  <p>{@summary Checks if the given argument {@code arg} is 
 *  {@code null} or empty and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}, or an
 *  {@link EmptyArgumentException}
 *  if it is empty.}</p>
 *  <p>Strings, arrays, instances of
 *  {@link java.util.Collection} and
 *  {@link java.util.Map}
 *  as well as instances of
 *  {@link java.lang.StringBuilder},
 *  {@link java.lang.StringBuffer},
 *  and
 *  {@link java.lang.CharSequence}
 *  will be checked on being empty.</p>
 *  <p>For an instance of
 *  {@link java.util.Optional},
 *  the presence of a value is checked in order to determine whether
 *  the
 *  {@link Optional} is empty or not.</p>
 *  <p>Because the interface
 *  {@link java.util.Enumeration}
 *  does not provide an API for the check on emptiness
 *  ({@link java.util.Enumeration#hasMoreElements() hasMoreElements()}
 *  will return {@code false} after all elements have been taken from
 *  the {@code Enumeration} instance), the result for arguments of
 *  this type has to be taken with caution.</p>
 *  <p>For instances of
 *  {@link java.util.stream.Stream},
 *  this method will only check for {@code null} (like
 *  {@link #requireNonNullArgument(Object,String)}.
 *  This is because any operation on the stream itself would render 
 *  it unusable for later processing.</p>
 *  <p>In case the argument is of type
 *  {@link Optional},
 *  this method behaves different from
 *  {@link #requireNotEmptyArgument(Optional,String)};
 *  this one will return the {@code Optional} instance, while the
 *  other method will return the contents of the 
 *  {@code Optional}.</p>
 *  <p>This method will not work properly for instances of
 *  {@link java.util.StringJoiner}, because its method
 *  {@link java.util.StringJoiner#length() length()}
 *  will not return 0 when a prefix, suffix, or an
 *  &quot;{@linkplain java.util.StringJoiner#setEmptyValue(CharSequence) 
 *  empty value}&quot; was provided.</p>
 *
 *  @param  <T> The type of the argument to check.
 *  @param  arg The argument to check; may be {@code null}.
 *  @param  name    The name of the argument; this is used for the 
 *      error message.
 *  @return The argument if it is not {@code null} or empty.
 *  @throws NullArgumentException   {@code arg} is {@code null}.
 *  @throws EmptyArgumentException   {@code arg} is empty.
 */
public static final <T> T requireNotEmptyArgument( final T arg, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );

    switch( arg )
    {
        /*
         * When using guarding expressions, the code would not get
         * better to read and to understand, as the positive cases
         * will be handled all by the default case then.
         */
        case null -> throw new NullArgumentException( name );
        case CharSequence charSequence ->
        {
            if( charSequence.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Collection<?> collection ->
        {
            if( collection.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Map<?,?> map ->
        {
            if( map.isEmpty() ) throw new EmptyArgumentException( name );
        }
        case Enumeration<?> enumeration ->
        {
            /*
             * The funny thing with an Enumeration is that it could 
             * have been not empty in the beginning, but it may be 
             * empty (= having no more elements) now.
             * The good thing is that Enumeration.hasMoreElements() 
             * will not change the state of the Enumeration - at 
             * least it should not do so.
             */
            if( !enumeration.hasMoreElements() ) throw new EmptyArgumentException( name );
        }
        case Optional<?> optional ->
        {
            if( optional.isEmpty() ) throw new EmptyArgumentException( name );
        }
        default ->
        {
            if( arg.getClass().isArray() )
            {
                if( Array.getLength( arg ) == 0 ) throw new EmptyArgumentException( name );
            }
            else
            {
                /*
                 * Other data types are not further processed; in
                 * particular, instances of Stream cannot be checked 
                 * on being empty. This is because any operation on 
                 * the Stream itself will change its state and may 
                 * make the Stream unusable.
                 */
            }
        }
    }

    //---* Done *----------------------------------------------------------
    return arg;
}   //  requireNotEmptyArgument()
\end{lstlisting}

\begin{lstlisting}[numbers=left,caption={requireNotBlankArgument()}]
/**
 *  <p>{@summary Checks if the given String argument {@code arg} is
 *  {@code null}, empty or blank and throws a
 *  {@link NullArgumentException}
 *  if it is {@code null}, an
 *  {@link EmptyArgumentException}
 *  if it is empty, or a
 *  {@link BlankArgumentException}
 *  if it is blank.}</p>
 *
 *  @param  <T> The type of the argument to check.
 *  @param  arg The argument to check; may be {@code null}.
 *  @param  name    The name of the argument; this is used for the
 *      error message.
 *  @return The argument if it is not {@code null}, empty or blank.
 *  @throws NullArgumentException   {@code arg} is {@code null}.
 *  @throws EmptyArgumentException   {@code arg} is empty.
 *  @throws BlankArgumentException   {@code arg} is blank.
 *
 *  @see    String#isBlank()
 */
public static final <T extends CharSequence> T requireNotBlankArgument( final T arg, final String name )
{
    if( isNull( name ) ) throw new NullArgumentException( "name" );
    if( name.isEmpty() ) throw new EmptyArgumentException( "name" );

    switch( arg )
    {
        case null -> throw new NullArgumentException( name );
        case String string ->
        {
            if( string.isEmpty() ) throw new EmptyArgumentException( name );
            if( string.isBlank() ) throw new BlankArgumentException( name );
        }
        case CharSequence charSequence ->
        {
            if( charSequence.isEmpty() ) throw new EmptyArgumentException( name );
            if( charSequence.toString().isBlank() ) throw new BlankArgumentException( name );
        }
    }

    //---* Done *----------------------------------------------------------
    return arg;
}   //  requireNotBlankArgument()
\end{lstlisting}

The classes \lstinline|java.util.Objects|\autocite{ORACLE_DOC_OBJECTS_CLASS} and \lstinline|org.tquadrat.foundation.lang.Objects|\autocite{TQUADRAT_ORG_FOUNDATION_OBJECTS} provide a bunch of additional methods that can help with the validation of arguments.

Beside the arguments to a method or constructor, you also have to check the values that are returned by a method call, at least that they are not \lstinline|null|. But don't be paranoid: if the specification of the called method clearly declares that the method will not return \lstinline|null|, you should trust it\footnote{Although you can still add an \lstinline|assert| statement to ensure that.}

The methods in your code should \textit{never} return \lstinline|null|, at least not those methods that are published as the API of your class.\footnote{Nevertheless, when you are implementing a (3\textsuperscript{rd} party) interface that requests a return value of \lstinline|null| under some conditions, you have to obey that requirements.} Instead, they should return an instance of \lstinline|java.util.Optional|\autocite{ORACLE_DOC_OPTIONAL_CLASS}.

Additionally, the classes \lstinline|java.util.OptionalInt|\autocite{ORACLE_DOC_OPTIONALINT_CLASS}, \lstinline|java.util.OptionalLong|\autocite{ORACLE_DOC_OPTIONALLONG_CLASS} and \lstinline|java.util.OptionalDouble|\autocite{ORACLE_DOC_OPTIONALDOUBLE_CLASS} can help you to avoid “magic numbers” as return values, indicating special results. And still no \lstinline|null|~…

\section{Extending Classes, Overriding Methods}\label{sec:ExtendingClassesOverridingMethods}
This chapter provides some hints for the design and implementation of classes and methods that should be/can be extended. This is basically relevant for libraries, but also for applications that should be customisable in some way and therefore providing an API.

\subsection{“final” for Classes and Methods}
Each non-\lstinline|private| method, that is not explicitly meant to be overridden by an extending class has to be \lstinline|final|. Each non-\lstinline|final| class is implicitly meant to be extended – even if it contains only \lstinline|final| methods.

Non-\lstinline|final| methods require a comment about when and how they can be overridden, and if the super implementation has to be called, and when. On how to write the comments for classes and methods, refer to the respective chapters \tqvref{sec:ClassComment} and \tqvref{sec:MethodComment}.

\lstinline|private| and \lstinline|static| methods are implicitly \lstinline|final|. Nevertheless, they will be marked as \lstinline|final|, too, although that is redundant.

\subsection{Non-“final” Classes}\label{sec:NonFinalClasses}
As already said above, each non-\lstinline|final| class is implicitly meant to be extended. This means, it has to be designed in a way that supports that extension, and it has to provide proper documentation on how to implement the extension and when.

Only when the class is \lstinline|sealed|\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:SealedClasses}, this is obsolete: for a \lstinline|sealed| class (and for a \lstinline|sealed| interface), all implementations has to be provided by you. This is discussed further in chapter \tqvref{sec:EncapsulationWithModules}.

Unfortunately it is difficult to provide a globally valid recipe for extensible classes. In general, such a class should provide some so called ‘mount points’ or ‘extension points’ where the behaviour could be changed or added. This could be an \lstinline|abstract| method, an empty, non-\lstinline|final| place holder method, or a non-\lstinline|final| method providing some default behaviour. Such a method should be marked with the annotation \lstinline|@Mountpoint|\footnote{Refer to chapter \tqvref{sec:MountPoint} for an implementation of the Annotation.} (if not \lstinline|abstract| or part of an interface), to indicate that you have not just forgotten to add the \lstinline|final| keyword.

An extensible class can also provide useful and/or convenience functionality as \lstinline|protected final| methods. 

Although \textit{it is not recommended}, an extensible class can even provide direct access to fields by declaring them \lstinline|protected| instead of \lstinline|private|.

\subsection{Non-“final” Methods}\label{sec:NonFinalMethods}
A method will be overridden to change the behaviour of an extended class, compared with its base class. The method either has already a behaviour, or it is empty, doing nothing\footnote{…~or it is \lstinline|abstract|, but that is another pattern.}.

In the latter case, it is very likely that this method was already added to design an extendable class.

In the other case, the new method's behaviour will completely replace that of the original one with new functionality. If this is not possible – meaning that some of the original method's functionality has to be kept, this needs to be described in the documentation comment for that method. Or, even better, you should change the design of you class to use the Template Method Pattern.

Assume your class has to implement the following process:
\begin{enumerate}
\item{Initialisation}
\item{Gathering data}
\item{Validate the input data}
\item{Filtering the input data}
\item{Processing the data}
\item{Formatting the output data}
\item{Cleanup and housekeeping}
\item{Writing the output}
\end{enumerate}

Your first, naïve implementation looks like this:
\begin{lstlisting}[numbers=left]
public class MyClass
{
    public String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final String inputData;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            inputData = readStream( inputFile );
        }
        
        //---* Validate and filter the data *------------------------
        final var filteredData = … // Do something with inputData
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = … // Do something with resultData
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}
Works! Job done! Until your project manager returns to you with the requirement that the input data should be taken alternatively from other source that just a file, that different filter schemes are possible, and that the output format has to be customisable. But the initialisation step, the validation and the housekeeping are fine~…

Ok, the method \lstinline|MyClass::process| is not final, you override it:

\begin{lstlisting}[numbers=left]
public class CustomClass extends MyClass
{
    public String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final String inputData;
        try( final var inputFile = new FileInputStream( new URL( "192.168.0.1" ).openStream() )
        {
            inputData = readStream( inputFile );
        }
        
        //---* Validate and filter the data *------------------------
        final var filteredData = … // Do something with inputData
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = … // Do something else with resultData
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class CustomClass
\end{lstlisting}

But obviously, this is not the solution … so you modify the original class:
\begin{lstlisting}[numbers=left]
public class MyClass // Second attempt
{
    /**
     *  Validate and filters the input data. Usually, no filtering should
     *  be required.
     *  An implementation of this method in a subclass needs to call this
     *  implementation in order to validate the data.
     *  
     *  @param  data    The raw input data.
     *  @param  context The process context.
     *  @return	The validated and filtered data.
     *  @throws IllegalArgumentException  The input data is invalid.
     */
    @MountPoint 
    protected String filterData( final String data, final ProcessContext context )
    {
        if( /* data is not valid */ ) throw new IllegalArgumentException();
        
        //---* Done *------------------------------------------------
        return data;
    }   //  filterData()
    
    /**
     *  Formats the output data.
     * 
     *  @param  data    The data to prepare for the output.
     *  @param  context The process context.
     *  @return	The formatted data.
     */
    @MountPoint
    protected String formatData( final String data, final ProcessContext context )
    {
        final var retValue = … // Do something with data
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  formatData()
    
    /**
     *  Obtains the input data from somewhere; the default 
     *  implementation reads it from the file {@code inputFileName}.
     *
     *  @return The input data.
     *  @throws IOException An I/O error occurred while gathering the 
     *      data.
     */
    @MountPoint
    protected String obtainInputData() throws IOException
    {
        final String retValue;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            retValue = readStream( inputFile );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  obtainInputData()
        
    public final String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final var inputData = obtainInputData();
        
        //---* Validate and filter the data *------------------------
        final var filteredData = filterData( inputData, context );
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = formatData( resultData, context );
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}

Looks good now! Test were successful! Job done!

Your colleagues implemented some custom classes extending your class, and basically, all is fine. Just once in a blue moon, the programs using one of the custom classes crashes spectacularly.

When you look into the the source, you found this implementation for \lstinline|filterData()|
\begin{lstlisting}
protected final String filterData( final String data, final ProcessContext context )
{
    final var validData = super.filterData( data, context );
    
    final var retValue = … // Do some filtering on validData
        
    //---* Done *------------------------------------------------
    return retValue;
}   //  filterData()
\end{lstlisting}

This was not what you meant! It should be:
\begin{lstlisting}
protected final String filterData( final String data, final ProcessContext context )
{
    final var filteredData = … // Do some filtering on data
    final var retValue = super.filterData( filteredData, context );
        
    //---* Done *------------------------------------------------
    return retValue;
}   //  filterData()
\end{lstlisting}

But your colleagues says that they have have to check the input data – and it seems that they are right! But the data has to be checked after the filtering again~…

So you modified your base class once more:
\begin{lstlisting}[numbers=left]
public class MyClass // Third attempt
{
    /**
     *  Filters the input data. This implementation does nothing.
     *  
     *  @param  data    The raw input data.
     *  @param  context The process context.
     *  @return	The filtered data.
     */
    @MountPoint 
    protected String filterData( final String data, final ProcessContext context )
    {
        /* Does nothing */
        
        //---* Done *------------------------------------------------
        return data;
    }   //  filterData()
    
    /**
     *  Formats the output data.
     * 
     *  @param  data    The data to prepare for the output.
     *  @param  context The process context.
     *  @return	The formatted data.
     */
    @MountPoint
    protected String formatData( final String data, final ProcessContext context )
    {
        final var retValue = … // Do something with data
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  formatData()
    
    /**
     *  Obtains the input data from somewhere; the default 
     *  implementation reads it from the file {@code inputFileName}.
     *
     *  @return The input data.
     *  @throws IOException An I/O error occurred while gathering the 
     *      data.
     */
    @MountPoint
    protected String obtainInputData() throws IOException
    {
        final String retValue;
        try( final var inputFile = new FileInputStream( "inputFileName" ) )
        {
            retValue = readStream( inputFile );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  obtainInputData()
        
    /**
     *  Validates the input data.
     *  
     *  @param  data    The input data.
     *  @param  context The process context.
     *  @throws IllegalArgumentException  The input data is invalid.
     */
    private final void validateData( final String data, final ProcessContext context )
    {
        if( /* data is not valid */ ) throw new IllegalArgumentException();
    }   //  validateData()
    
    public final String process() throw IOException
    {
        //---* Initialise the process context *----------------------
        final var context = …
        
        //---* Gather the input data *-------------------------------
        final var inputData = obtainInputData();
        
        //---* Validate and filter the data *------------------------
        validateData( inputData );
        final var filteredData = filterData( inputData, context );
        if( !inputData.equals( filteredData ) ) validateData( filteredData );
        
        //---* Process the filtered data to the result data *--------
        final var resultData = … // Do something with filtererdData
        
        //---* Format the data *-------------------------------------
        final var retValue = formatData( resultData, context );
        
        //---* Cleanup *---------------------------------------------
        // Do whatever is necessary …
        
        //---* Done *------------------------------------------------
        /*
         * Let the caller write the data to wherever it should end up.
         */
        return retValue; 
    }   //  process()
}
//  class MyClass
\end{lstlisting}

Now \lstinline|filterData()| does only filter data, it is no longer responsible for the validation, too. And the default implementation of that method is now empty.
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}

\lipsum[1]

\begin{lstlisting}
\end{lstlisting}

\section{Swap Logic Errors for Compiler Errors}
From a book about Java programming:
\begin{quotation}
“One fundamental principle of programming is that, generally, it is best to swap a logic error for a compiler error. Compiler errors tend to be found in seconds and are corrected just as fast. Syntax errors are a good example […]

Logic errors, on the other hand, are the bane of all programmers. They hide and hate to reveal themselves. Logic errors seem to have minds of their own, constantly evading detection and dodging your efforts to pin down their cause. They can easily take a thousand times more effort to solve than the worst compiler errors. Worst of all, many logic errors are not found at all and occur only intermittently in sensitive places, which causes your customer to scream for a fix. Logic errors often require you to throw thousands of man-hours at them, only to finally discover that they are minor typos.”

Robert Simmons Jr.: \textit{Hardcore Java}\autocite{Simmons:HARDCORE_JAVA}
\end{quotation}

A sample for swapping a logic error for a compiler error is the recommendation to write comparisons always with the unchangeable value on the left side\footnote{This recommendation originates from C/C++ programming where \lstinline|if| conditions are checking values of type integer – and in C, nearly everything can be an integer, or at least be interpreted like one. Java forces that the type of the expression in the \lstinline|if| condition has to be \lstinline|boolean|, therefore this approach is less useful for Java code.}. So if you forget the second equal sign for a comparison on equal, the compiler will complain immediately:
\begin{lstlisting}
if( length() == len ) …
if( 5 == len ) …
\end{lstlisting}

Another sample for this is the recommendation to name fields with the “m\_” prefix (refer to chapter \tqfullvref{sec:Fields}). The compiler will never complain if you omit the \lstinline|this.| prefix when accessing a field, and it will not complain if you name a local variable in the same way as a field\footnote{Although you can configure both Eclipse and IntelliJ Idea to raise an error or a warning if you access a field without \lstinline|this.| and if you shadow a field through a local variable with the same name.} – but it will scream loudly about a non-existing reference if you forget the “m\_” prefix when accessing a field named along the rules defined here.

The best thing about compiler errors is, that they usually show up during development – and not first after deployment at customer side.

See also chapter \tqvref{sec:CompilerWarningsAndErrors} about compiler warnings and errors.

\section{Access to Properties}
Encapsulation is an important design principle for classes. This means that the internal state of an object can be manipulated only in a well defined manner, through the methods. Consequently, it may not be possible to modify the attributes  directly, by a direct assignment.

To achieve that, instance or class variables – also known as properties, attributes or fields – have to be \lstinline|private|.

If it is necessary to set or retrieve an instance variable (a property) directly, it mandatory to provide the appropriate methods for this (setter and/or getter, or mutator and/or accessor methods). But often attributes are set or retrieved as a side effect of method calls that modify the internal state of the object instance, or rely on it.

Programmers are inclined to use \lstinline|public| fields when the need a data structure like a \lstinline|struct| in C/C++, and not a full-fledged class. But as Java does not now that data structure, it seems to be a quick solution to have a \lstinline|class| with only \lstinline|public| fields and no methods, just to spare typing effort, and sometimes with the idea, that the direct access to the \lstinline|public| field is much faster that accessing it through a method. But modern optimising compilers will inline the code of a simple getter method, so that there is no difference in the end.

And if you want to avoid the typing, use a \lstinline|record|\autocite{ORACLE_DOC_RECORD,ORACLE_DOC_LANGUAGE_SPECIFICATION:RecordClasses} instead. Sometimes also an instance of \lstinline|java.util.Map| or another collection implementation could be an alternative to a specialised class.
 
Sometimes fields from base classes are defined as \lstinline|protected|, to make them directly accessible by methods from the derived implementations, but this is also discouraged.\footnote{The idea behind that is the same false assumption that the direct access to the \lstinline|protected| field is much faster that accessing it through a method.}

It does not matter if we talk about properties (instance variables) or \lstinline|static| field (class variables): both should always be \lstinline|private|.

Constants are the only exception, obviously, because a constant is explicitly defined as a \lstinline|public static final| field.

Regarding encapsulation in general, refer to chapter \tqvref{sec:EncapsulationWithModules}.

\section{Accessing Fields or Methods using Reflection}
First of all, you should avoid to use Reflection whenever possible. Just do not use it!\footnote{The only acceptable exception is for unit tests; we will discuss that later in this chapter.}

One reason is that accessing a field or a method via reflection causes some overhead that decreases a program’s performance. 

Next, such code is usually not easy to read or to understand, not only because of all the necessary error handling code around it.

And with modularisation, it is quite often not even possible to access methods and fields of an object via Reflection, even if they are \lstinline|public|; they are not even visible in some cases.

Of course, there are some patterns whose implementation in Java requires the use of Reflection, because any other approach is either even less performant, much more cumbersome, or will not work at all – meaning there are occasions when it is not really possible to avoid the use of Reflection. Nevertheless, you should still consider an alternative; lambdas\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:LambdaExpressions} and method references\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:MethodReference} are quite often a very good replacement for an implementation based on Reflection.

Reflection also allows you to access non-\lstinline|public| member of a class that are usually not accessible by your code. This is considered a “dirty hack” and may not be used in production code. In particular as it may not work properly with modules.

But there are useful applications for this, too: you can and should used it in unit tests for \lstinline|private| or \lstinline|protected| methods that are not \lstinline|public| for good reasons, and if these methods cannot be tested indirectly.\footnote{The alternative would be to make the method at least \lstinline|protected|, but this would make it (more) visible to the consumers of the API, and perhaps even accessible – but there was a reason why that method was originally \lstinline|private|.}

I recommend to use the following pattern if you want to access a \lstinline|private| method in your unit tests:
\begin{lstlisting}[numbers=left]
public final class MyClass
{
    /**
     *  Does something.
     *
     *  @param  value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    private final String myMethod( final CharSequence value ) throws IOException      { … }
}   
//  class MyClass

/**
 *  This class provides some unit tests for
 *  {@link MyClass}.
 */
public final class TestMyClass
{
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The reference to {@code myMethod()}.
     */
    private static final Method METHOD_myMethod;
    
    static
    {
        final var targetClass = MyClass.class;
        String methodName;
        try
        {
            methodName = "myMethod";
            METHOD_myMethod = targetClass.getDeclaredMethod( methodName, CharSequence.class );
            METHOD_myMethod.setAccessible( true );
        }
        catch( final NoSuchMethodException ignored )
        {
            throw new ExceptionInInitializerError( "Cannot find method '%s()' in class '%s'".formatted( methodName, targetClass.getName() );
        }
    }
    
        /*---------*\
    ====** Methods **================================================ 
        \*---------*/
    /**
     *  Calls
     *  {@link MyClass#myMethod(CharSequence)}
     *
     *  @param  instance    The candidate.
     *  @param	value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    protected static final String myMethod( final MyClass instance, final CharSequence value )
    {
        final String retValue;
        try
        {
            retValue = (String) METHOD_myMethod.invoke( requireNonNullArgument( instance, "instance" ), value );
        }
        catch( final IllegalAccessException | ClassCastException e )
        {
            throw new AssertionError( e );
        }
        catch( final InvocationTargetException e )
        {
            switch( e.getCause() )
            {
                case null -> throw new AssertionError( e );
                case IOException ioe -> throw ioe;
                default -> throw new AssertionError( e.getCause() );
            }
        }
    }   //  myMethod()   
    
    @Test
    final void testMyMethod() throws Exception
    {
        final var candidate = new MyClass();
        final var result = myMethod( candidate, "" );
        assertTrue( result instanceof String );
    }   // testMyMethod()
}
//  class TestMyClass  
\end{lstlisting}
This allows you to call the method \lstinline|MyClass::myMethod| nearly directly; the method \lstinline|TestMyClass::myMethod| behaves in the same way as the original method.

\lstinline|java.lang.AssertionError|\autocite{ORACLE_DOC_ASSERTIONERROR_CLASS} is the base class for the errors thrown by JUnit\autocite{JUNIT5}.

\include{5_CodingGuidelines_ImplementingTheObjectMethods}

\include{5_CodingGuidelines_StringConcatenation}

\section{The Annotation @API}\label{sec:APIAnnotation}
\section{-------------------------------------------- Proceed from here!}
\subsection{-------------------------------------------- Proceed from here!}
\subsubsection{-------------------------------------------- Proceed from here!}
\lipsum[1]

\begin{lstlisting}
\end{lstlisting}

\section{“Convention over Configuration”}
The phrase “Convention over Configuration” (or “Coding by Convention”) got popular with the introduction of Ruby on Rails, but it is related to earlier ideas like the concept of “Sensible Defaults” and the “Principle of Least Astonishment” in user interface design.

Basically it means that an object instance can be created and used properly with only minimal configuration because all not absolutely mandatory settings will have meaningful – and useful! – default values.

On the other hand, there is that number~\ref{lst:ZoP:ExplicitVsImplicit} from the “Zen of Python”, saying “Explicit is better than implicit”~…

These are obviously contradictory statements – so whose right?

Both, to some extent!

Your design should support “Convention over Configuration”, but your code should rely on defaults only when a change of these defaults in unlikely, or such a change will not have an effect to your code.

So assume that you are using a 3\textsuperscript{rd} party library that creates reports in HTML format; the default format was HTML3 with the previous version, but in the current version – that one used by you – it is HTML5. The generated reports are consumed by a tool that converts HTML5 input into PDF.

According to “Convention over Configuration”, you are fine: the convention is HTML5, you do not need to set the HTML version for the output format explicitly.

But what happens, if in a few years the next version of that report creator library will support HTML7 as the default, but your PDF generator stucks still with HTML5 for its input? Nothing happens until your successor as the maintainer of your software decides to use that new library~… afterwards you may see funny things in the generated PDF documents.

So the recommendation is: do not always rely on conventions! Whenever possible, provide an explicit configuration! At least leave a comment when you rely on the defaults, and that comment should describe what the anticipated defaults are.

\section{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{Types of Arguments and Return Values}\label{sec:TypeOfArgumentsAndReturnValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Compiler Warnings and Errors}\label{sec:CompilerWarningsAndErrors}
It is not allowed to commit any code that emits warnings or even errors on a compiler run to the SCCS. It is also not allowed to switch off any compiler warning globally.

In fact, warnings should even not show up in the development environment, also with the most aggressive settings.

It is allowed to use the annotation \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} to locally deactivate a warning. This is often necessary when dealing with legacy APIs that does not use Generics. So this sample would emit an “unchecked” warning for line 3:
\begin{lstlisting}[numbers=left]
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

To avoid this, the annotation \lstinline|@SuppressWarnings| with the value “unchecked” can be applied – preferably not to the method as a whole, but only to the problematic assignment, even if this means that an additional temporary variable is required (but not in this sample):
\begin{lstlisting}
// RECOMMENDED
public final Map<K,V> clone()
{
    @SuppressWarnings( "unchecked" ) 
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}

// AVOID!!!
@SuppressWarnings( "unchecked" ) 
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

As there is no rule without exception, here is one: I recommend to use labels to mark long code blocks (refer to the chapters \tqfullref{sec:LabelsAndBreakStatements}, \tqfullref{sec:TrailingOrEndOfLineComments}, and \tqfullref{sec:CommentsWhen}), but if those code blocks do not reference these labels, they may cause an “Unused Label” warning in your IDE. The recommendation is here to deactivate that warning – globally.

\section{Returning Values}\label{sec:ReturningValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Lambda Results}\label{sec:LambdaResults}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{The Ternary Operator “?”}\label{sec:TheTernaryOperator}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Encapsulation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Encapsulation with Modules}\label{sec:EncapsulationWithModules}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Lambdas}\label{sec:Lambdas}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Functional Interfaces}\label{sec:FunctionalInterfaces}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{The Interface “java.util.Formattable”}\label{sec:FormattableInterface}
\section{-------------------------------------------- Proceed from here!}

\autocite{ORACLE_DOC_STRING_CLASS}
\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\autocite{ORACLE_DOC_STRINGJOINER_CLASS}
\autocite{ORACLE_DOC_FORMATTER_CLASS}
\autocite{ORACLE_DOC_FORMATTABLE_INTERFACE}

\lipsum[1]

\section{The Interface “java.lang.Comparable”}\label{sec:ComparableInterface}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Utility Classes}\label{sec:UtilityClasses}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{try-with-resources}\label{sec:TryWithResources}
The feature \lstinline|try-with-resources| was introduced with Java~7; it can help to make programs more stable and less error prone.

\subsection{Basics}
Basically, \lstinline|try-with-resources|\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:TryWithResources} is an extension of the previously existing \lstinline|try-catch-finally| feature.

Instead of writing
\begin{lstlisting}[numbers=left]
InputStream input = null;
try
{
    input = new FileInputStream( file );
    …
}
catch( final IOException e )
{
    // Handle the error
}
finally
{
    try
    {
        if( input != null ) input.close();
    }
    catch( final IOException e )
    {
        // Handle the error
    }
}
\end{lstlisting}

the new feature allows you to write

\begin{lstlisting}[numbers=left]
try( final var input = new FileInputStream( file ); )
{
    …
}
catch( final IOException e )
{
    // Handle the error
}
\end{lstlisting}

It works because the interface \lstinline|java.lang.AutoCloseable|\footnote{In fact, \lstinline|InputStream| will still implement just \lstinline|java.io.Closeable|, as already before Java~7, but this interface will now extend the new interface \lstinline|java.lang.AutoCloseable|.} is implemented by the class \lstinline|java.io.InputStream|. For details refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE}.

This interface defines just one method, \lstinline|close()|, that declares to throw an exception of type \lstinline|java.lang.Exception|.

\lstinline|close()| is called automatically on all instances of \lstinline|AutoClosable| that were declared and defined in the ‘arguments list’ of the new \lstinline|try| when the scope of the \lstinline|try| block is left. If there is more than one resource defined, the sequence is reversed to that of the definition: the last assigned resource will be closed first.

So a code snippet to copy data from an input stream to an output stream may look like this\footnote{This is obviously not a very good implementation, but it illustrates how to use \lstinline|try-with-resources| quite well.}:
\begin{lstlisting}[numbers=left]
try
( 
    InputStream input = new FileInputStream( infile );
    OutputStream output = new FileOutputStream( outfile ) 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
\end{lstlisting}
Both streams will be closed properly in case of a problem or the work is done.

\subsection{Error Handling}
What will happen if the code in the \lstinline|try| block throws an exception and closing the resource will throw one, too?

For the ‘traditional’ pattern this could mean that the first exception would be ‘supplanted’ by the exception from the close. For sure, in a \lstinline|catch| block the original cause could be logged, but usually only checked exceptions (and “expected“ ones) are covered this way.

Together with \lstinline|try-with-resources|, a new feature was introduced to the language: the \textit{suppressed} exception. This deals with the problem described above.

So if the \lstinline|try| block throws an exception (for our example, it would be most probably an \lstinline|IOException|) and the \lstinline|AutoCloseable.close()| will fail with an exception, too, the latter one will be added to the first one as a “suppressed exception” by the JVM.

For this purpose, the API of the class \lstinline|java.lang.Throwable| was extended by the methods \lstinline|addSuppressed()| and \lstinline|getSuppressed()|.\footnote{see \autocite{ORACLE_DOC_THROWABLE_CLASS}}

Using \lstinline|Throwable.printStackTrace()| an output like that below will be produced:
\begin{lstlisting}
java.lang.Error
  at TryWithResources.main(TryWithResources.java:175)
  Suppressed: java.lang.Exception
    at TryWithResources$Resource2.close(TryWithResources.java:103)
    at TryWithResources.main(TryWithResources.java:176)
\end{lstlisting}

\subsection{Execution Sequence}\label{sec:ExecutionSequence}
It is important to know how the execution sequence looks like when using \lstinline|try-with-resources|. For the traditional pattern it is\\
\begin{center}
\verb#try{}->[catch{}]->finally{}#
\end{center} 
for \lstinline|try-with-resources| it will be\\ 
\begin{center}
\verb#try{}->AutoCloseable.close()->[catch{}]->[finally{}]#
\end{center}

This means that the method \lstinline|close()| on the \lstinline|AutoClosable| objects will be called \textit{before} any code in an optional \lstinline|catch| and/or \lstinline|finally| block that is attached to the \lstinline|try| block. For the sample we used above this means that the \lstinline|InputStream input| is already closed when the code in the \lstinline|catch| block that handles the \lstinline|IOException| will be executed.

Therefore the code below will not work as expected in case an exception is thrown in the \lstinline|try| block:
\begin{lstlisting}
// WILL NOT WORK!
final var logStream = new FileOutputStream( logfile )
try
(   
    final var input = new FileInputStream( infile );
    final var output = new FileOutputStream( outfile );
    final var log = logStream 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
catch( final IOException e )
{
    logStream.write( "Copy failed!\n".getBytes( UTF8 ) );
    /* Fails because the log file is already closed! */
}
\end{lstlisting}

Refer also to \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:ExtendedTryWithResources}.

\subsection{When to use?}
\lstinline|try-with-resources| is a very powerful feature that should be used whenever possible. Definitively it should be used with all the Java classes that already implement \lstinline|java.lang.AutoCloseable| or \lstinline|java.io.Closeable|:

\begin{itemize}
\item{The \lstinline|java.io| streams}
\item{Sockets}
\item{\lstinline|java.sql.Connection|, \lstinline|java.sql.Statement|, \lstinline|java.sql.ResultSet|}
\item{\lstinline|java.jms.Connection|}
\end{itemize}

\subsubsection{Lifecycle}\label{sec:Lifecycle}
In C++, it is a very common pattern to “wrap” the lifecycle of a resource into the lifecycle of an object:
\begin{lstlisting}[language=C++]
class Resource
{
    //---* Attributes *----------------------------------------------
    private:
        RTYPE m_Res;

    //---* Constructors *--------------------------------------------
    public:
        Resource( RTYPE &r )
        : m_Res( r )
        { m_Res.open(); }

    //---* Destructor *----------------------------------------------
    public:
        ~Resource() { m_Res.close(); }

    //---* Methods *-------------------------------------------------
    // Some methods to access the resource
    …
}
\end{lstlisting}
A use of that class might look like this:
\begin{lstlisting}[language=c++]
…
{
    Resource resource( r );

    // Do something
    …
}
…
\end{lstlisting}
The instance of \lstinline|Resource| will be constructed and \lstinline|open()| is called on \lstinline|r| on the declaration of the variable \lstinline|resource|. On leaving the scope the destructor of \lstinline|Resource| is called implicitly and \lstinline|close()| will be called on \lstinline|r|.

The C++~STL is using a very similar pattern for smart pointers.

Unfortunately, Java does not know destructors\footnote{The deprecated method \lstinline|java.lang.Object.finalizer()| that is part of each Java class is not and was never a replacement for or an alternative to a destructor as it could never be predicted when it is called (just “sometime before the JVM terminates” – if ever).}, so this pattern could not be used.

A workaround is to use a \lstinline|try-finally| block with the cleanup (usually a call to \lstinline|close()|) in the \lstinline|finally| block. But to often we have seen that in the run of modifications and/or corrections (refactorings) suddenly the \lstinline|finally| block and/or its contents had been removed (“optimised away”).

Now, with the \lstinline|try-with-resources| feature, we can have “Lifecycle” classes; they are still not that easy to use that with real destructors, but we can come close.

A sample would be the Class \lstinline|AutoLock|; for the full code, see chapter \tqfullvref{sec:AutoLock}; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

In programs that use \lstinline|java.util.concurrent.locks.Lock| or one of its implementations for thread synchronisation, you will find quite often code like this:
\begin{lstlisting}[numbers=left]
m_Lock.lock();
try
{
    // Do something
    …
}
finally { m_Lock.unlock(); }
\end{lstlisting}

This calls for a lifecycle class. Unfortunately the code below will not work, due to several reasons:
\begin{lstlisting}[numbers=left]
// Does not work!!
try( final var unused = new Lock() )
{
    // Do something
    …
}
\end{lstlisting}

First, \lstinline|java.util.concurrent.locks.Lock| will not implement \lstinline|java.lang.AutoCloseable|, and second – much more important – we cannot create a new instance of \lstinline|Lock| each time we enter the critical section.\footnote{Not to mention that \lstinline|java.util.concurrent.locks.Lock| is an interface so that \lstinline|new Lock()| cannot work at all.}

Fortunately, the \lstinline|try-with-resources| feature will not call \lstinline|close()| on the newly created object, but on the local reference (that is the reason why \lstinline|try-with-resources| will not work with anonymous instances like \lstinline|try( new Lock() )|). If we would now wrap the \lstinline|Lock| instance into a class that implements \lstinline|AutoCloseable|, we can write something like this:
\begin{lstlisting}[numbers=left]
…
AutoLock m_AutoLock = new AutoLock( m_Lock );
…
try( final var unused = m_AutoLock.lock() )
{
    // Do something
    …
}
\end{lstlisting}

\subsubsection{Post-Processing}
Together with lambdas, \lstinline|try-with-resources| can be (ab)used also to enforce a unconditional post-processing when a code block is left. This may look like this:
\begin{lstlisting}[numbers=left]
…
Runnable doAfter = …;
…
try( final var p = new PostProcessor( doAfter ) )
{
    // Do whatever necessary
    …
}
\end{lstlisting}
The \lstinline|PostProcessor| instance will call \lstinline|Runnable::run|\autocite{ORACLE_DOC_RUNNABLE:run} in its \lstinline|close()| method when the \lstinline|try| block is left. Chapter \tqfullref{sec:PostProcessor} in the Appendices provides the source for the class.

‘Unconditional’ means here that the post-processing will be executed if the block terminates regularly or by a thrown exception. Other conditions can be injected into the \lstinline|Runnable|\autocite{ORACLE_DOC_RUNNABLE_INTERFACE} implementation.

The difference between this approach and simply calling \lstinline|doAfter.run()| in a \lstinline|finally| block is that the \lstinline|close()| method of \lstinline|PostProcessor| is invoked before any code in a \lstinline|catch| block (refer to chapter \tqfullref{sec:ExecutionSequence}).

The following code snippet could be a real-life example for where this is useful:
\begin{lstlisting}[numbers=left]
final var builder = new StringBuilder();

final Runnable addTrailer = () -> builder.append( "}\n" );

…

try( final var p = new PostProcessor( addTrailer ) )
{
    …
}
\end{lstlisting}
This ensures that the string in \lstinline|builder| always terminates with a closing curly brace followed by a linefeed.

Another sample is this code snippet:
\begin{lstlisting}[numbers=left]
final List<String> list = new LinkedList();

final Runnable forceSorting = () -> list.sort();

…

try( final var p = new PostProcessor( forceSorting ) )
{
    for( final var s : loadStrings() )
    {
        list.add( s );
    }
}
\end{lstlisting}
Here the \lstinline|PostProcessor| forces that the given list is always sorted after the values had been added.

\section{Date and Time Values}\label{sec:DateAndTimeValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Unique Ids}\label{sec:UniqueIds}
Data records stored to a database require a unique identifier in most cases. Sometimes, this identifier is provided externally – a social security number, an account number, or a tax id – but usually not. 

When the database will be accessed (and updated) from different locations, this identifier has to be \textit{universally} unique; alternatively, you can introduce a global service that provides such identifiers. But usually, this does make sense only when these identifiers are not only just technical – like the already mentioned social security numbers, account numbers, or tax ids.

How to get universally unique ids (UUID) is defined in RFC~4122\autocite{Leach:RFC4122}, among others. Java provides an implementation for these UUIDs with the class \lstinline|java.util.UUID|\autocite{ORACLE_DOC_UUID_CLASS}. Unfortunately, the class provides only one method that creates new arbitrary UUIDs (\lstinline|java.util.UUID::randomUUID()|\autocite{ORACLE_DOC_UUID:randomUUID}), and these are version~3 pseudo-random UUIDs.

These are large enough that collisions are unlikely, but when used as primary keys on a database table, the database indexing can get quite inefficient (lack of locality in the indexes). This is discussed in more detail in \autocite{Mihalcea:UUID_Database_Primary_Key}.

Partially, this is addressed by timebased UUIDs (version~1), and new formats will be discussed (see \autocite{Davis:NewUUIDs, Leach:RFC4122bis}), but another issue is that these UUIDs occupy at least 128~bit – when you use the binary format. But usually, the textual representation is used (mainly because the Java class \lstinline|UUID| does not provide a method to get the binary format), and that has even 288~bit (36~bytes or characters). I provide a utility class \lstinline|UniqueIdUtils|\autocite{TQUADRAT_ORG_FOUNDATION_UNIQUEIDUTILS} that provides some tools to address these issues. So it allows you to create timebased UUIDs or to get the binary representation from a UUID.

The already mentioned article in \autocite{Mihalcea:UUID_Database_Primary_Key} suggests to use shorter unique ids that should be timebased; the article refers to a the \verb#TSID_CREATOR# library\autocite{Lima:TSID_CREATOR}, but alternatively, my \lstinline|UniqueIdUtils| do also provide a \lstinline|TSID| type with 64~bit length.

Another issue with UUIDs is that it should not be \textit{too} easy to guess a valid instance. This means that a database sequence\autocite{TOAD_WORLD_BLOG:DatabaseSequence} that just increments a counter in order to get a new identifier is the worst choice in this regard.

\section{Utilising JMX}\label{sec:UtilisingJMX}
\section{-------------------------------------------- Proceed from here!}
See \ref{sec:Logging}, and there the part about warnings! Keeping track about failed logins.!!!
\lipsum[1]


\section{Finalisation}\label{sec:Finalisation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Deprecation of Elements}\label{sec:DeprecationOfElements}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Miscellaneous}
In this chapter I collected some dos and don'ts that do not fit into one of the other chapters, but are not relevant enough for a chapter on there own.

\begin{itemize}
\item{Avoid octal numerical literals in your source code! Although this feature exists since the first versions of Java, it is not very well known.

If you do not know what I talking about: start \verb#jshell#, type in \lstinline|021 + 021| and be surprised that the result is not the ultimate answer to life, the universe, and everything.\autocite{ADAMS_HITCHHIKERS_GUIDE}

Or to summarise it: Do not prefix integer literals with \verb#0#!}

\item{Avoid using an object to access a class (static) variable or method. If you cannot use a static import, refer the element through the class name instead. For example:
\begin{lstlisting}
public final class AClass
{
    public static final void classMethod() { … }
}
//  class AClass

…

import static some.package.AClass.classMethod;

public final class MyClass
{
    public final void myMethod()
    {
        // RECOMMENDED!
        classMethod(); // Using the static import
        
        // OK
        AClass.classMethod();
        
        // AVOID!!
        final var anObject = new AClass();
        …
        anObject.classMethod();
    }   //  myMethod()
}
    //  class MyClass
\end{lstlisting}

You can configure both Eclipse and IntelliJ IDEA to report the access to a static member of a class through an instance as a warning or even as an error.}

\item{In general, static imports are preferred over using the class name as prefix for references to static class members, either to class methods or to constants.}

\item{Try to initialize local variables where they are declared. The only reason not to initialize a variable where it's declared is if the initial value depends on some computation occurring first.}

\item{Avoid the multi-line initialisation for fields; use a constructor instead:
\begin{lstlisting}
public final class MyClass
{
    private final String m_Field;
    // AVOID!!!!!
    {                                                
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }
    
    /**
     *  Creates a new instance for {@code MyClass}.
     */
    public MyClass() 
    {                                                
        // INSTEAD DO IT IN THE CONSTRUCTOR!!
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }   //  MyClass()
}
//  class MyClass    
\end{lstlisting}}

\item{Try to call a method only when its result is needed. This is even more true if the method does not return a value but has other effects.

Although this may seem to be self-evident, you may find often code like this:
\begin{lstlisting}
// AVOID!!!
final var logMessage = composeMessage( params );
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    writeLog( logMessage );
}
…
\end{lstlisting}
or
\begin{lstlisting}
// AVOID!!!
{
    final var param1 = retrieveData( data1 );
    final var param2 = retrieveData( data2 );
    if( option )
    {
        process( param1 );
    }
    else
    {
        process( param2 );
    }
}
\end{lstlisting}
Instead, the samples should look like below:
\begin{lstlisting}
// RECOMMENDED
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    final var logMessage = composeMessage( params );
    writeLog( logMessage );
}

…

// RECOMMENDED
{
    final Data param;
    if( option )
    {
        param = retrieveData( data1 );
    }
    else
    {
        param = retrieveData( data2 );
    }
    process( param );
}
// RECOMMENDED/Using the trinary operator
{
    final var param = option 
        ? retrieveData( data1 )
        : retrieveData( data2 );
    process( param );
}
\end{lstlisting}
}

\item{Avoid anonymous classes! Although it (sometimes) reduces the code to write and the number of source files, it makes the resulting code very hard to read in most cases. And the number of generated class files remains exactly the same, no matter if anonymous classes, inner classes, non-\lstinline|public| or \lstinline|public| classes are used.

In most cases, you can use a lambda instead of an anonymous class.}

\item{If you are using collections or maps, declare and define them with generics.

If a legacy interface returns a collection or map that is not declared with generics, map it. The resulting warning can be suppressed using the \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} annotation.

Sometimes this may require the introduction of a temporary helper variable, as in the last sample, below.

\begin{lstlisting}
// AVOID!!
List x = new LinkedList(); 

// RECOMMENDED!!
List<String> x = new LinkedList<String>(); 

public abstract Vector method1();
public abstract Vector method2() throws IOException;
…
public static final void main( String... args )
{
    @SuppressWarnings( "unchecked" )
    final List<String> method1Result = method1();
    List<String> method2Result = null;
    try
    {
        @SuppressWarnings( "unchecked" )
        final List<String> temporary = method2();
        method2result = temporary;
    }
    catch( final IOException e ) { … }
}   //  main()
\end{lstlisting}}

\item{Using \lstinline|java.lang.Object| as the type parameter for a generic data type is useless in most cases and should be avoided:
\begin{lstlisting}
// AVOID!!!
private final List<Object> m_List = new LinkedList<Object>();
\end{lstlisting}
If you want to declare a variable of a generic type that should work for any parameter class, you have to use the question mark:
\begin{lstlisting}
Class<?> dataClass = data.getClass();
\end{lstlisting}}

\item{The classes \lstinline|java.util.Vector|\autocite{ORACLE_DOC_VECTOR_CLASS} or \lstinline|java.util.Hashtable|\autocite{ORACLE_DOC_HASHTABLE_CLASS} should not be used! Although their implementation had been modernised already with Java~1.2, their performance is still inferior to the alternative implementations, because \lstinline|Vector| and \lstinline|Hashtable| are still synchronised.

For method arguments and return values, you should use the interfaces \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} instead of \lstinline|Vector|, and \lstinline|java.util.Map|\autocite{ORACLE_DOC_MAP_INTERFACE} instead of \lstinline|Hashtable|. Refer also to chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} that elaborates further on this topic.

If you need an implementation of the \lstinline|List| interface, you should prefer \lstinline|java.util.ArrayList|\autocite{ORACLE_DOC_ARRAYLIST_CLASS} over \lstinline|java.util.LinkedList|\autocite{ORACLE_DOC_LINKEDLIST_CLASS}. The latter is only more performant in some very rare cases, and it also has a bigger memory footprint\footnote{Internally, an \lstinline|ArrayList| uses an array for the entries, and when this gets too small, a new array with twice the size will be allocated. This means that for some time two large array will exist. For really, really large lists, this may cause an issue. In the opposite, a \lstinline|LinkedList| will grow entry by entry.}.

Instead of \lstinline|Hashtable|, you should use \lstinline|java.util.HashMap|\autocite{ORACLE_DOC_HASHMAP_CLASS} as the implementation for the \lstinline|Map| interface.

If you really need a synchronised list, you can still consider to use \lstinline|Vector| as your implementation of \lstinline|List|, but for a syncronised implementation of \lstinline|Map|, you should take \lstinline|java.util.concurrent.ConcurrentHashMap|\autocite{ORACLE_DOC_CONCURRENTHASHMAP_CLASS}.}

\item{Use the enhanced \lstinline|for-loop| when iterating over collections\footnote{Ok, only implementations of \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} provide methods for random access.}. It is also preferred when iterating over arrays.

Alternatively, you can use an iterator, the \lstinline|java.lang.Iterable::forEach| method, or the Stream API:
\begin{lstlisting}
// AVOID!
for( var i = 0; i < list.length(); ++i )
{
    process( list.get( i ) );
}

// RECOMMENDED
for( final var element : collection ) process( element );

collection.forEach( this::process );

// OK
for( final var i = collection.iterator(); i.hasNext(); ) process( i.next() );

collection.stream()
    .forEach( this::process );
\end{lstlisting}

The Stream API allows you to filter the elements in the collection.}

\item{Consider to use the varargs feature when a method takes only one single argument, but can be called repeatedly with different arguments, or when it takes an array as argument:

\begin{lstlisting}
public final void addListener( final Listener... listeners ) { … }
\end{lstlisting}

instead of
\begin{lstlisting}
public final void addListener( final Listener listener ) { … }
\end{lstlisting}

Obviously, the implementation now has to deal with multiple entries, but it allows to write
\begin{lstlisting}
addListener( listener1, listener2, listener3 );
\end{lstlisting}
instead of
\begin{lstlisting}
addListener( listener1 );
addListener( listener2 );
addListener( listener3 );
\end{lstlisting}
making the code easier to read.}

\item{Prefer \lstinline|java.lang.CharSequence|\autocite{ORACLE_DOC_CHARSEQUENCE_INTERFACE} over \lstinline|java.lang.String| for the type of method arguments. See also chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} on the topic of argument and return types.}

\item{“Forever” loops should be coded as
\begin{lstlisting}
ForeverLoop: while( true ) 
{ 
    … 
    
    //---* Terminate the loop *--------------------------------------
    if( <condition> ) break ForeverLoop;
}   //  ForeverLoop:
\end{lstlisting} }

\item{Do not use \lstinline|new String()| with a string constant or a string expression as the argument. There are only very few situations where this is useful or necessary, and most of them are related to JNI. Usually \lstinline|new String()| is a waste of memory and computing time, except you use if with a \lstinline|byte|, \lstinline|char| or \lstinline|int| array as the argument. Refer to \autocite{ORACLE_DOC_STRING_CLASS} for the details.}

\item{Some programmers do not like the Autoboxing feature that was introduced with Java~5. It is up to you to use it, or to transform the primitive types explicitly into their corresponding object types and vice versa.\footnote{Nevertheless, you should consider “\ref{lst:ZoP:ExplicitVsImplicit}.~Explicit is better than implicit, and verbosity is your friend” – see chapter \tqvref{sec:TheBasicRule}.}}

\item{If a constructor calls a method of its own class or a superclass, this method has to be \lstinline|static|, \lstinline|private|, or \lstinline|final|\footnote{The important setting is \lstinline|final|, because \lstinline|private| and \lstinline|static| methods are implicitly \lstinline|final|}.

In addition, it may call another constructor of the same or the super class, using \lstinline|this()| or \lstinline|super()|.}

\item{Ensure that the main thread (that one that executes \lstinline|main()|) always dies as the last non-deamon thread.

This means that you should keep a reference of all the threads that your code starts so that you can kill them explicitly before the program terminates.}

\item{Ensure that assertions\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Assert,ORACLE_DOC_ASSERTIONS} are enabled during testing and disabled in production.

To enable assertions, add \verb#-ea# or \verb#-enableassertions# to the JVM command line.}

\item{Although releasing resources when they are no longer needed is a good idea in most cases, it can cause trouble in rare occasions.

I found a code sequence like this in some real life code:
\begin{lstlisting}
…
}
catch( Exception e )
{
    PrintStream ps = new PrintStream( System.out );
    ps.println( "Error occured" );
    e.printStackTrace( ps );
    ps.close()
}
\end{lstlisting}
This will not only close the \lstinline|PrintStream| \lstinline|ps|, but also the wrapped \lstinline|System.out| stream – with the consequence, that this exception was the last that was displayed on the console (or written to the log output).

So make sure that your code will only cleans up objects that your code is responsible for, either because it created them or the responsibility was clearly delegated to it. In case of a wrapper (like most implementations of \lstinline|java.io.InputStream|, \lstinline|java.io.OutputStream| \lstinline|java.io.Reader| and \lstinline|java.io.Writer|), your code should not call methods like \lstinline|close()| if it is not responsible for the wrapped object, as in most cases the wrapper would delegate them to the wrapped object.

If your code has to provide references to resources to 3\textsuperscript{rd}~party code, you should consider to protect those resources from being freed (if required). For an instance of \lstinline|PrintStream|, this could look like this:
\begin{lstlisting}
…
final var tempStream = new PrintStream( myStream ) 
{
    /**
     *  {@inheritDoc}
     */
    @Override
    public void close() { /* Does nothing! */ }
};
externalMethodWritingToPrintStream( tempStream );
…
\end{lstlisting}}


\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}
\end{itemize}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{-------------------------------------------- Proceed from here!}
    • If there is a getter for a field, it should be used even by the methods of the same class. Usually the same yields for setters, but there are exceptions from that rule3, in case a field can be set internally to values that are invalid if set from the outside. In such cases the direct access to the field has to be commented accordingly.
    • 
    • A method or constructor should not have more than 7 (in words: seven) arguments. If you feel inclined to provide more arguments to construct an instance, consider to use an instance of Map instead.
    • Do not use BitFields, at least do not expose them to the API. Although the Java API is using them itself, they are still problematic.
    • Whenever you have to convert a date, time or date-time value to a String that is not primarily meant to be display, used an internal format that is independent from any locale. Our recommendation is to use the ISO 8601 format “YYYY-MM-dd'T'hh:mm:ss.SSS”, normalised to UTC, and to use the class SimpleDateFormat to format the date.4
    • 
    • …





\include{6_Summary}

\chapter{Appendices}

\section{The Naming Dictionary}\label{sec:TheNamingDictionary}
The names of program elements provide an implicit contract (or at least a kind of commitment) between the original author of the program and its users/maintainers. But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts here, together with a list of suffixes for class names.

\subsection{Verbs}
This chapter provides a list of verbs\footnote{Ok, some names or prefixes are not verbs, like ‘main’, ‘from’ or ‘to’~…} to be used with method names and a description of their implicit contract. These verbs are usually prefixes to a method name, although some of them could be used as standalone names, too. The form that used more often is mentioned first.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{Verbs.tbl.tex}

That a method name is built using one of the verbs above does not free you from providing a proper JavaDoc comment that describes the purpose of the method in detail, together with the arguments, return values and exceptions.

\subsection{Suffixes for Class Names}\label{sec:SuffixesForClassNames}
This chapter lists defined suffixes for class names and their function.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{ClassNameSuffixes.tbl.tex}

\section{Configurable Errors and Warnings}\label{sec:ConfigurableErrorsAndWarnings}
A very convenient feature of most IDE's is the capability to configure additional warnings and even errors for the compilation.

\subsection{Eclipse}\label{sec:EclipseErrorsAndWarnings}
tdb

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJErrorsAndWarnings}
tdb

\section{IDE Configuration}\label{sec:IDEConfiguration}
This chapter provides samples of configuration files for some IDEs. See also the chapter \tqvref{sec:ConfigurableErrorsAndWarnings} about the errors and warnings that can be configured in Eclipse and IntelliJ IDEA.

\subsection{Eclipse}\label{sec:EclipseConfiguration}
tbd

\subsubsection{Snippets}
This chapter provides the XML code for Eclipse snippets.

\paragraph{Structuring Comments}\label{sec:SnippetStructuringComments}
The snippets for the structuring comments as defined in chapter \tqfullvref{sec:StructuringComments}.
\begin{lstlisting}[language=XML,basicstyle=\ttfamily\footnotesize]
<?xml version="1.0"
      encoding="UTF-16" 
      standalone="no"?>
<snippets>
    <category filters="*"
              id="category_1145179107125"
              initial_state="0"
              label="Structuring Comments"
              largeicon=""
              smallicon="">
        <description><![CDATA[Structuring Comments as defined by the Code Conventions]]></description>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145232938375"
              label="Enum Declaration"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the enum definition part]]></description>
            <content><![CDATA[        /*------------------*\
    ====** Enum Definitions **=================================================
        \*------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179869843"
              label="Inner Classes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the inner classes part]]></description>
            <content><![CDATA[        /*---------------*\
    ====** Inner Classes **====================================================
        \*---------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251889697104"
              label="Constants"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for constants.]]></description>
            <content><![CDATA[      /*-----------*\
    ====** Constants **========================================================
        \*-----------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251888677777"
              label="Attributes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for attributes.]]></description>
            <content><![CDATA[      /*------------*\
    ====** Attributes **=======================================================
        \*------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179436656"
              label="Static Initialisations"
              largeicon="" smallicon="">
            <description><![CDATA[The header comment for the static initialisations part]]></description>
            <content><![CDATA[        /*------------------------*\
    ====** Static Initialisations **===========================================
        \*------------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180117906"
              label="Constructors"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the constructors part]]></description>
            <content><![CDATA[    	/*--------------*\
    ====** Constructors **=====================================================
        \*--------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180168796"
              label="Methods"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the methods part]]></description>
            <content><![CDATA[    	/*---------*\
    ====** Methods **==========================================================
        \*---------*/
]]></content>
        </item>
    </category>
</snippets>
\end{lstlisting}

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJConfiguration}
tbd

\section{Embedded Code}
Sometimes, it is necessary to embed code inside the Java source code. Most often, these are SQL statements, but sometimes it could be also fragments of HTML or XML documents.

\subsection{Formatting SQL inside Java}\label{sec:FormattingSQLInsideJava}

\subsection{Formatting XML inside Java}\label{sec:FormattingXMLInsideJava}
You should embed only small fragments of an XML document into the Java source; larger fragments and full documents can be handled better when provided as resources.

\subsection{Formatting HTML inside Java}\label{sec:FormattingHTMLInsideJava}
Same as for XML, also only small HTML fragments should be embedded into the Java source code. Anything else should go into a resource file.

\section{Examples}\label{sec:Examples}

\subsection{AutoLock}\label{sec:AutoLock}
This class is a sample implementation of the idea described in chapter \tqfullvref{sec:Lifecycle}, like a PoC; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={AutoLock.java}]{AutoLock.java}

\subsection{Illegal Argument Exceptions}\label{sec:IllegalArgumentExceptions}
As said in chapter \tqfullvref{sec:CheckingMethodParametersAndReturnValues}, a \lstinline|NullPointerException| that is thrown from your code has to be seen as a coding bug: a value was not properly checked before it was used. Nevertheless, values can be \lstinline|null|, for various reasons, and this still can be an error that needs to be signalled.

For that, I suggested a bunch of custom exceptions that are shown here; they are also part of my Foundation Library: for \lstinline|ValidationException| see \autocite{TQUADRAT_ORG_FOUNDATION_VALIDATIONEXCEPTION}, the \lstinline|NullArgumentException| can be found at \autocite{TQUADRAT_ORG_FOUNDATION_NULLARGUMENTEXCEPTION}, the \lstinline|EmptyArgumentException| is documented at \autocite{TQUADRAT_ORG_FOUNDATION_EMPTYARGUMENTEXCEPTION}, and finally the documentation for \lstinline|BlankArgumentException| is at \autocite{TQUADRAT_ORG_FOUNDATION_BLANKARGUMENTEXCEPTION}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={ValidationException.java}]{ValidationException.java}

\lstinputlisting[numbers=left,caption={NullArgumentException.java}]{NullArgumentException.java}

\lstinputlisting[numbers=left,caption={EmptyArgumentException.java}]{EmptyArgumentException.java}

\lstinputlisting[numbers=left,caption={BlankArgumentException.java}]{BlankArgumentException.java}

\subsection{Lazy}\label{sec:Lazy}
The interface \lstinline|Lazy| and the associated implementation \lstinline|LazyImpl| provide a holder for a lazy initialised object instance. The initialisation happens on the first call to the method \lstinline|Lazy::get| through a call to the \lstinline|Supplier| instance the \lstinline|Lazy| instance was created with.

\begin{lstlisting}
public final class MyClass
{
    /**
     *  An attribute of type
     *  {@link AClass}.
     */
    private final Lazy<AClass> m_Attribute;
    
    public MyClass()
    {
        m_Attribute = Lazy.use( ()-> new AClass( this ) );
    }
    
    public final void myMethod()
    {
        m_Attribute.get().aMethod();
    }   //  myMethod()
}
//  class MyClass
\end{lstlisting}

\lstinline|Lazy| is part of my Foundation Library and can be found at \autocite{TQUADRAT_ORG_FOUNDATION_LAZY}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={Lazy.java}]{Lazy.java}

\lstinputlisting[numbers=left,caption={LazyImpl.java}]{LazyImpl.java}

\subsection{MountPoint}\label{sec:MountPoint}
The annotation \lstinline|@MountPoint| and how to use it is described in the chapters \tqfullvref{sec:NonFinalClasses} and \tqfullvref{sec:NonFinalMethods}.

The annotation is part of my foundation library, refer to \autocite{TQUADRAT_ORG_FOUNDATION_MOUNTPOINT}.

\paragraph{The Code}\
\lstinputlisting[numbers=left,caption={MountPoint.java}]{MountPoint.java}

\subsection{Patch Identification}\label{sec:PatchIdentification}
The chapter \tqfullvref{sec:MaintenanceComments} discussed how to mark areas in the code that has been changed to fix a bug. There I suggested to use annotations for this task.

This can look like this:
\begin{lstlisting}[numbers=left]
@BUG( id  = "BUG-123456", comment = "Introduced base class MyClassBase" )
public final class MyClass extends MyClassBase
{
    @BUG( id = "BUG-100000", comment = "Made generic; added Typ 'String'" )
    @BUG( id = "BUG-100003", comment = "Changed type to 'CharSequence'" )
    private final List<CharSequence> m_Texts = new LinkedList<>();

    @BUG( id  = "BUG-123456", comment = "Introduced base class MyClassBase; calling super()" )
    public MyClass()
    {
        super();
    }   //  MyClass()
    
    @BUG( id = "BUG-100003", comment = "Changed type to 'CharSequence'" )
    @BUG( id = "BUG-100022", comment = "Made generic; changed to 'extends CharSequence'" )
    @BUG( id = "BUG-123456", comment = "Introduced base class MyClassBase; added @Override" )
    @Override
    public final <T extends Charsequence> void addText( final T text ) { … }
}
//  class MyClass
\end{lstlisting}

That the same annotation can be applied multiple times to the same element requires a “container annotation” for that annotation\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:RepeatableAnnotationInterfaces}, but the use of this annotation is implicit.

The annotations \lstinline|@BUG| and \lstinline|@FixList| (the “container annotation”) are part of the Foundation Base project\autocite{TQUADRAT_ORG_FOUNDATION_BASE, TQUADRAT_ORG_FOUNDATION_BUG, TQUADRAT_ORG_FOUNDATION_FIXLIST}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={FixList.java}]{FixList.java}

\lstinputlisting[numbers=left,caption={BUG.java}]{BUG.java}

\subsection{PostProcessor}\label{sec:PostProcessor}
This implementation is basically a PoC; currently it is not part of any library.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={PostProcessor.java}]{PostProcessor.java}

\subsection{ThreadGroup}\label{sec:ThreadGroup}
The class \lstinline|java.lang.ThreadGroup|\autocite{ORACLE_DOC_THREADGROUP_CLASS} provides a method \lstinline|uncaughtException()| that has the same signature as the \lstinline|UncaughtExceptionHandler::uncaughtException|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER:uncaughtException} method.

The method \lstinline|java.lang.ThreadGroup:uncaughtException| is called by the Java Virtual Machine when a thread in this thread group stops because of an uncaught exception, and no specific \lstinline|Thread.UncaughtExceptionHandler|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER_INTERFACE} instance was installed
to that thread.

The default implementation of that method does the following:
\begin{enumerate}
\item{If this thread group has a parent thread group, the \lstinline|uncaughtException()| method of that parent is called with the same two arguments.}
\item{Otherwise, this method checks to see if there is a default uncaught exception handler installed, and if so, its \lstinline|uncaughtException()| method is called with the same two arguments.}
\item{Otherwise, this method determines if the \lstinline|Throwable| argument is an instance of \lstinline|java.lang.ThreadDeath|. If so, nothing special is done.

Otherwise, a message containing the thread's name, as returned from the thread's \lstinline|getName()| method, and a stack backtrace, using the \lstinline|Throwable|'s \lstinline|printStackTrace()| method, is printed to the standard error stream.}
\end{enumerate}

Unfortunately, the class \lstinline|java.lang.ThreadGroup| itself does not provide an API to change the behaviour of its \lstinline|uncaughtException()| method. To do that, you have to override that method in a subclass.

Below you find an implementation of \lstinline|ThreadGroup| that fixes that. A similar class is also part of my Foundation library – see \autocite{TQUADRAT_ORG_FOUNDATION_BASE, TQUADRAT_ORG_FOUNDATION_THREADGROUP}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={ThreadGroupExt.java}]{ThreadGroupExt.java}

\subsection{UnsupportedEnumError}\label{sec:UnsupportedEnumError}
This implemenation of \lstinline|java.lang.Error| is meant to be used in the \lstinline|default| branch of a \lstinline|switch| statement (refer to \tqfullvref{sec:SwitchStatements}), in cases where the selector is an enum.

It will be used like this:
\begin{lstlisting}[numbers=left]
enum Color
{
    RED, BLUE, GREEN, YELLOW
}

Color color = …    

// Traditional switch statement
switch( color )
{
    case RED: …; break;
    case BLUE: …; break;
    case GREEN: …; break;
    case YELLOW: …; break;

    default: throw new UnsupportedEnumError( color );
}

// New switch statement
switch( color )
{
    case RED -> …;
    case BLUE -> …;
    case GREEN -> …;
    case YELLOW -> …;

    default: throw new UnsupportedEnumError( color );
}

// switch expression
var result = switch( color )
{
    case RED -> "Rot";
    case BLUE ->"Blau";
    case GREEN -> "Grün";
    case YELLOW -> "Gelb";

    default: throw new UnsupportedEnumError( color );
}
\end{lstlisting}

Also refer to \autocite{TQUADRAT_ORG_FOUNDATION_UNSUPPORTEDENUMERROR}.

\paragraph{The Code} \
\lstinputlisting[numbers=left,caption={UnsupportedEnumError.java}]{UnsupportedEnumError.java}

\listoftables

\lstlistoflistings

\begin{FlushLeft}
\printbibliography
\end{FlushLeft}

\printindex
\end{document}
