%\RequirePackage{lmodern}
\documentclass[11pt,a4paper, titlepage, parskip=half, headsepline, footsepline, cleardoublepage=current, headheight=1cm]{scrbook}
%\usepackage{DejaVuSansMono}
\usepackage{dejavu}
%\usepackage[T1]{fontenc}
\usepackage{scrhack}
\usepackage{graphicx} 
\usepackage[manualmark]{scrlayer-scrpage}
%\usepackage[utf8]{inputenc}
\usepackage{tocbasic}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{eurosym}
\usepackage{ragged2e}
\usepackage{textcomp}
\usepackage{framed}
\usepackage{ltxtable}
\usepackage{filecontents}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,gray]{xcolor}
\usepackage{listings}
\usepackage[inline]{enumitem}
\usepackage{varioref}
\usepackage[iso,english]{isodate}
\usepackage{makecell}
\usepackage[english]{babel}
\usepackage[babel]{csquotes}

\usepackage{lipsum}

\usepackage[style=numeric, urldate=iso, date=iso, seconds=true, backend=biber]{biblatex}
\usepackage{nameref}
\usepackage[colorlinks=true]{hyperref}

\addbibresource{JavaCodingConventions.bib}

\automark[section]{chapter}
\lehead*[]{\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}~~\headmark}
\rohead*[\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}]{\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}}

\lstset{
language=Java,
%morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield},
morekeywords={var,yield},
backgroundcolor=\color[gray]{.9},
frame=single,
framerule=0.2pt,
basicstyle=\ttfamily\footnotesize,
commentstyle=\color[gray]{.2}\itshape,
keywordstyle=\color[gray]{.4}\bfseries,
identifierstyle=\bfseries,
stringstyle=\itshape,
xleftmargin=.2cm,
xrightmargin=.2cm,
breaklines=true,
breakatwhitespace=true,
inputencoding=utf8,
extendedchars=true,
literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
  {©}{{\copyright}}1
  {…}{{\dots }}2
  {–}{{--}}1
}

\colorlet{shadecolor}{gray!10}
\makeindex

%---* New Commands *-----------------------------------------------------------
\newcommand*{\tqfullref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”}}
\newcommand*{\tqfullvref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”} on page \pageref{#1}}
\newcommand*{\tqref}[1]{\hyperref[{#1}]{\ref*{#1}}}
\newcommand*{\tqvref}[1]{\hyperref[{#1}]{\ref*{#1}} on page \pageref{#1}}

\begin{document}
\isodate
\titlehead{\includegraphics[height=4cm]{Logo_gross}}
\author{Thomas Thrien\\(thomas.thrien@tquadrat.org)}
\title{Extended Coding Conventions for Java}
\subtitle{Coding and Formatting Guidelines, Recommendations and Best Practices}
\date{\today}
\maketitle
\tableofcontents

\include{1_Introduction}
\include{2_FormattingTheSourceCode}
\include{3_NamingConventions}
\include{4_WritingProperComments}

\chapter{Coding Guidelines}\label{sec:CodingRules}
These guidelines are a collection of coding standards and best practices. Obeying them should make your code better readable and less error prone. Some of them will even help to increase the program's overall performance. So perhaps you should see them not as optional, but more as obligatory rules.

As always there may be good reasons to do it different from what is recommended or even requested by the guidelines\footnote{You remember the bullet points~\ref{lst:ZoP:SpecialCases} and \ref{lst:ZoP:Practicality} from the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython,PYTHON_ORG_MAILING_LIST:ThePythonWay} that I quoted in chapter \tqvref{sec:OtherProgrammingLanguages}?}. In such case a comment is required that describes that reason.\footnote{Omitting this comment is also a deviance from the rule, requiring a comment to explain it. Also known as the Catch~22.}

One basic recommendation is that you should not write the same code over and over again. This is also known as the “DRY Principle” (“Don't Repeat Yourself”) and we will discuss this later again.

And please keep in mind that not always the shortest, most compact source code is the best. Also avoid what is known as “Premature Optimization”\footnote{Donald E. Knuth made the following statement on optimisation: “We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil.”\autocite{KNUTH:PrematureOptimization}}. Modern optimising compilers and run-time optimisers do a very good job to create compact object code, so in most cases the programmer can concentrate fully on writing readable and comprehensible code. In this context I would like to remind you on the quotation from Martin Fowler's book that I put in front of this document, and again to the “Zen of Python”, here the points “\ref{lst:ZoP:SimpleVsComplex}.~Simple is better than complex” and “\ref{lst:ZoP:ComplexVsComplicated}.~Complex is better than complicated”.\footnote{Yes, I know: for a document about Java Coding Conventions, there is an astonishing amount of references to Python~…}

But although optimisation still may have some limits, comments will have never any impact on the runtime performance of a program. So please refer to chapter \tqfullvref{sec:CommentsWhen} (if not done already) and see the recommendations on when to apply comments to your code.

\subsubsection{Types of Products}\label{sec:TypesOfProducts}
Some of the coding guidelines below are different for the type of product or project you are working on. Basically, we can distinguish the following types that will be explained in the following chapters\footnote{If you miss the terms ‘Framework’ and ‘Server’ on the list above: a \textit{Framework} is in this regard a \textit{Feature Library}, and a \textit{Server} is a \textit{Standalone Application} (what else could a server be?).}:
\begin{itemize}[nosep]
\item{Function Libraries}
\item{Feature Libraries}
\item{Tools}
\item{Standalone Applications}
\item{Server-based Applications}
\item{Extensions}
\end{itemize}
The individual types cannot be clearly distinguished one from another, there are some overlappings and gray areas. So when applying a guideline, you still have to use your judgement which implementation really fits for \textit{your project}.

\paragraph{Function Library}\label{sec:FunctionLibrary}
A function library is a collection of functions (often organised in utility classes – refer to chapter \tqvref{sec:UtilityClasses}) and helper classes. A function library does not have a state or requires an initialisation or configuration.

Samples are my Foundation Util library\autocite{TQUADRAT_ORG_FOUNDATION_UTIL}, the Commons Lang library from the Apache Commons project\autocite{APACHE_COMMONS_LANG}, or Google Guava\autocite{GOOGLE_GUAVA}.

My JavaComposer library\autocite{TQUADRAT_ORG_FOUNDATION_JAVACOMPOSER} is a sample for the beforementioned ‘gray area’: I decided to treat it as a function library, but it could have been a feature library, too. The various XML parsers and JSON parsers/generators will also belong to this gray area. 

\paragraph{Feature Library}\label{sec:FeatureLibrary}
A feature library adds a service or a complex functionality to your application. Quite often that functionality runs in its own thread(s) and is accessed like an external service, it has its own configuration and initialisation.

Sometimes these libraries can even be started standalone.

Samples for this are the various JDBC drivers, the H2 Database Engine\autocite{H2_DATABASE}, ActiveMQ\autocite{APACHE_ACTIVEMQ}, Jetty\autocite{ECLIPSE_JETTY}, or Hibernate\autocite{HIBERNATE_ORM}.

In the gray area here I would place JUnit\autocite{JUNIT5} and Log4J\autocite{APACHE_LOG4J}.

\paragraph{Tool}\label{sec:Tool}
A tool in this context is a program that is started, performs a single task and terminates afterwards. Most probably it will be invoked from the command line, and it will not have a UI, but takes all input data somehow from the command line. Perhaps it may even work as a filter\autocite{WIKIPEDIA:Filter}, reading from standard input and writing to standard output.

Programs like \verb#ls# or \verb#grep# belongs to this type, although they are of course not written in Java.

Gray area candidates are \verb#awk# and also \verb#sed#, but even \verb#javac#, the Java compiler, or \verb#javadoc#.

\paragraph{Standalone Application}\label{sec:StandaloneApplication}
A standalone application will run indefinitely (meaning until deliberately terminated by the user) and takes input continuously. Samples are a text editor, an IDE, an application server like WebSphere\autocite{IBM_WEBSPHERE} or a web container like Tomcat\autocite{APACHE_TOMCAT}.

\paragraph{Serverbased Application}\label{sec:ServerbasedApplication}
Serverbased applications are applicationn that require a special environment to be executed; the best example are JEE applications that need an application server like JBoss\autocite{REDHAT_JBOSS}, WebLogic\autocite{ORACLE_WEBLOGIC} or WebSphere\autocite{IBM_WEBSPHERE}, and web applications, requiring Tomcat\autocite{APACHE_TOMCAT} or any of the appservers mentioned before.

In this case, the program code has to follow several special rules, determined by the server environment. On the other side the enviroment provides several services that can be used by the application.

Other samples are Maillets for James\autocite{APACHE_JAMES} or the customisations (“mods”) for Minecraft\autocite{MINECRAFT} (although these could be regarded both as the gray area candidates here, because both could be seen also as extensions).

\paragraph{Extension}\label{sec:Extension}
An extension or a plugin requires also an environment to run in, but it is not an application as such. It just changes the behaviour of that environment. Annotation processors are samples for this (they change the behaviour of the Java compiler), as well as Maven\autocite{APACHE_MAVEN} plugins.

\section{Error Handling}\label{sec:ErrorHandling}
A proper error handling is crucial for any code, no matter in which type of program it lives – but the definition of \textit{proper} depends significantly on the type of the final product, as it was defined above.

Basically, we have to deal with only a very limited set of possible error categories:
\begin{enumerate}[nosep]
\item{An exception is thrown by an operation triggered by our code.}
\item{An operation returns an error state.}
\item{The result of an operation is an unexpected or an unwanted value.}
\item{A method is called with an invalid argument.}
\item{Input data is invalid or corrupted.}
\item{A command line argument is invalid.}
\item{An external resource is not or no longer available.}
\end{enumerate}

Of course, all those categories are possible triggers for an exception in Java. This means that we can quite simply generalise the response to an error: \textit{in case of an error condition, throw an exception}!

Consequently, we can also simplify \textit{error} handling to \textit{exception} handling. And there are only a few options on how to respond to an exception:
\begin{itemize}
\item{Throw an exception and make it an S.E.P.\footnote{S.E.P~=~Someone Else's Problem (refer to \autocite{ADAMS_HITCHHIKERS_GUIDE}).} – particularly suitable (no irony!) for libraries.}
\item{Perform an alternate operation or provide a default value.}
\item{Retry/repeat the operation.}
\item{Abort the current operation – either the current thread or the whole program.}
\end{itemize}

As said, throwing an exception will always work, but at some point exceptions need to be handled in some way.

The other alternatives are feasible only in some special contexts:
\begin{itemize}
\item{Repeating or retrying a failed operation depends on the kind of operation, and not that much on the type of the product. This also should not be done indefinitely; at some point, it gets useless to repeat or retry a constantly failing operation.}

\item{Same for an alternate operation that will be executed in case of an error.}

\item{Providing a default value demands that this default value makes sense in the current context. It should be obvious that this is not always the case.}

\item{To abort a Java program (in fact, to abort the JVM that executes that Java program), you call the method \lstinline|java.lang.System::exit|\autocite{ORACLE_DOC_SYSTEM_CLASS:exit} with a negative integer as the argument. But this is only acceptable for a tool and, with some limitations, for a standalone application. Libraries, extensions and especially server-based applications are not allowed to call \lstinline|System.exit()|! Never!

A thread will be aborted automatically when an exception is thrown and not caught. If this thread is the last non-deamon thread, the JVM will go down, too. So usually the best thing to abort the current operation is to throw an \lstinline|Error| – for the details, refer to chapter \tqref{sec:GeneralExceptionHandling}.}
\end{itemize}

Only these four options do exist for handling an exception! This means that afterwards the error condition is fixed, or that it persists.

I bet that you now ask yourself why the actions below are missing from my list above:
\begin{itemize}
\item{Log an error message.}
\item{Write an error message to the console, a message window or status bar.}
\item{Display an error dialog.}
\end{itemize}

That is because \textit{none of these are handling the error}! Of course you should log an error, of course you should inform the user about an error condition. But none of these actions will change the state of the system!

Far too often you find code like this:
\begin{lstlisting}
…
try
{
    writeStatusToBillingSystem( invoice );
}
catch( final TimeOutException e )
{
    m_Logger.error( e );
}
invoice.markAsPaid();
…
\end{lstlisting}

Looks good, right?

Really?

You mark the invoice as paid, despite the writing to the billing system failed?

You think that this cannot happen, because you have logged the exception?

I think that the accountants are no longer your friend when they find out that this piece of code was written by you~…

The chapters \tqvref{sec:ThrowingExceptions} and \tqvref{sec:GeneralExceptionHandling} discuss throwing and handling exception. More about reporting the various error conditions can be found in chapter \tqvref{sec:ReportingErrors} and the chapter \tqvref{sec:Logging} deals with logging in particular.

\subsection{Throwing Exceptions}\label{sec:ThrowingExceptions}
Your code will emit an exception when it encounters an error condition of some kind. Exceptions are discussed in detail in the Java Language Specification\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Exceptions}; I just repeat the basics here.

For the Java programming language, an exception is an instance of a class that is derived from \lstinline|java.lang.Throwable|\autocite{ORACLE_DOC_THROWABLE_CLASS}, or – more precise – from one of the child classes of \lstinline|Throwable|:
\begin{itemize}[nosep]
\item{\lstinline|java.lang.Exception|\autocite{ORACLE_DOC_EXCEPTION_CLASS}}
\item{\lstinline|java.lang.RuntimeException|\autocite{ORACLE_DOC_RUNTIMEEXCEPTION_CLASS}}
\item{\lstinline|java.lang.Error|\autocite{ORACLE_DOC_ERROR_CLASS}}
\end{itemize}

The different kinds of exceptions are discussed in \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:KindsOfExceptions}.

Exception classes that extend \lstinline|java.lang.Exception| are so-called \textit{checked} exceptions; if a method wants to throw one of these, it has to declare that with the \lstinline|throws| clause. \lstinline|java.lang.RuntimeException| is a direct subclass of \lstinline|java.lang.Exception| and the superclass of all \textit{runtime} exceptions – declaring these is not mandatory.

While an ordinary program can potentially recover from an error condition signalled by an \lstinline|Exception| instance, it is assumed that instances of \lstinline|java.lang.Error| and its subclasses will indicate unrecoverable error conditions.

The class of the thrown exception should be chosen appropriate to the error condition it indicates. So throwing just an instance  \lstinline|java.lang.Exception| or \lstinline|java.lang.RuntimeException| is usually not a good idea – same if throwing a \lstinline|java.lang.NullPointerException| in case a divisor is 0.

When selecting the exception class, your first look should be to the already existing exception implementations if there is already one that fits your needs.\footnote{Although sometimes the name of an exception looks good, you should also consider which package it lives in; throwing an exception from a JNDI related package like \lstinline|javax.naming.OperationNotSupportedException| in a code segment that does nothing with the “Java Naming and Directory Interface” at all will cause more confusion than it helps. Not to mention that it may require an additional module.} If none of the existing ones fit, implement your one exception class by extending one of \lstinline|Exception|, \lstinline|RuntimeException|, or \lstinline|Error|, depending on your needs\footnote{You can create your own exception class that extends \lstinline|Throwable| directly, but so far I have not found a use case for that.}. This is always useful in the case of a feature library to simplify its API\footnote{All methods will only throw one exception especially created for that library, or exceptions derived from that. Samples for this pattern are the Servlet API (throwing only instances of \lstinline|IOException| and \lstinline|ServletException|) or JDBC (throwing only \lstinline|SQLException| instances).}, and it can be also helpful for an application.

When implementing an extension or a server-based application (or when using a particular framework), you have to implement quite often methods that declare only one, sometimes two exceptions. Nevertheless, it may happen that a method call in your code throws an exception that cannot be handled by the current code, but it cannot be delegated also, because the interface for the method does not declare that particular exception. In such a case, you have to catch the exception and to wrap it into an instance of the declared exception that will be thrown afterwards. For a servlet implementation\autocite{JAKARTA_EE_HTTPSERVLET_CLASS}, this may look like this:
\begin{lstlisting}
protected final void doGet( HttpServletRequest request, HttpServletResponse response )
    throws ServletException, IOException
{
    …
    try
    {
        …
    }
    catch( final TimeOutException e )
    {
        throw new ServletException( e );
    }

    …
}  //  doGet()
\end{lstlisting}

When instantiating an exception instance, you should always provide a textual message that describes the error condition and/or provides additional information, like the name of the file that cannot be found, or the SQL statement with the invalid syntax.\footnote{In this regard, the sample above is bad, because it does not provide such an explanation.} These text have to be in English language, for the same reason why the names and the comments are in English.

Of course, messages that will be presented to the end user in a UI have to be localised, but the UI should not display the raw exception message anyway at all.

Some exception classes do not have a constructor that allows to provide a cause, or they have constructors that allow either a message or a cause, but not both. A sample for that is \lstinline|java.lang.ExceptionInInitializerError|\autocite{ORACLE_DOC_EXCEPTIONININITIALIZERERROR_CLASS}.

Below you will find a workaround that allows you to still provide both, cause and message, with these exceptions\footnote{For the method \lstinline|initCause()| refer to \autocite{ORACLE_DOC_THROWABLE_CLASS:initCause}.}: 
\begin{lstlisting}
static
{
    try
    {
        …    
    }
    catch( final Exception e )
    {
        throw new ExceptionInInitializerError( "Message" )
            .initCause( e );    
    }
}
\end{lstlisting}

\subsection{General Exception Handling}\label{sec:GeneralExceptionHandling}
A method is only allowed to handle an exception if it is able to restore the program state, otherwise it has to delegate it. Delegation can be done either by ignoring the exception – in this case it will be propagated to the caller automatically (it “bubbles up”) – or by catching and wrapping it, as described in chapter \tqfullref{sec:ThrowingExceptions}.

To handle an exception you first have to catch it.

Catching \lstinline|java.lang.Exception| is discouraged in most cases; it \textit{can} be acceptable when you need to wrap all checked exceptions into a runtime exception or an error:
\begin{lstlisting}
public final void run()
{
    try
    {
        …
    }
    catch( final Exception e )
    {
        throw new WrapperException( e );
    }
}   // run()
\end{lstlisting}

You should absolutely avoid to catch \lstinline|java.lang.Error| and all of its subclasses, \lstinline|java.lang.RuntimeException|, and of course, you should not never ever catch \lstinline|java.lang.Throwable|!\footnote{But no rule without an exception: refer to chapter \tqvref{sec:ExceptionHandlingInThreads}.}

Provide a \lstinline|catch| block for each and every exception that you want to handle:
\begin{lstlisting}
public final void run()
{
    try
    {
        …
    }
    catch( final FileNotFoundException e )
    {
        throw new ApplicationError( "Cannot find file", e );
    }
    catch( final IOException e )
    {
        throw new ApplicationError( "An error occurred on processing the input file", e );
    }
    catch( final NumberFormatException e )
    {
        throw new ApplicationError( "Input Data is corrupted", e );
    }
    catch( final PatternSyntaxException e )
    {
        throw new ApplicationError( "Pattern invalid", e );
    }
}   // run()
\end{lstlisting}

Sometimes when a large number of exceptions has to be handled with all the same code, you may be tempted to just catch \lstinline|java.lang.Exception|. As already said: don't do it! This approach will definitely cause problems as it may handle runtime exceptions in the same \lstinline|catch|-block as the checked exceptions, and usually this is not intended.

A simplificatin for the sample above could look like this:
\begin{lstlisting}
public final void run()
{
    try
    {
        …
    }
    catch( final IOException | NumberFormatException | PatternSyntaxException e )
    {
        throw new ApplicationError( "Processing failed", e );
    }
}   // run()
\end{lstlisting}
Still only the declared exceptions will be handled in the \lstinline|catch|-block, but unexpected exceptions will now bubble up\footnote{The exception class \lstinline|java.io.FileNotFoundException| is not listed because the class \lstinline|java.io.IOException| is its superclass.}.

Sometimes an exception indicates a regular program state (although this would indicate poor design in most cases)\footnote{Nevertheless, you can find this even in the Java Runtime Library~… but no one has ever said that the authors of the JDK had never made doubtful decisions.}. Usually you will avoid this situation by e.g. checking the operands before an operation, but a very popular example where this is not practicable is the conversion of a string into a numerical value:
\begin{lstlisting}
…
var amount = 0.0;
final var requestParam = request.getParameter( "amount" );
try
{
    if( nonNull( requestParam ) )
    {
        amount = Double.parseDouble( requestParam );
    }
}
catch( final NumberFormatException ignored )
{
    //---* If amount in request is not numeric, set it to 0.0 *------
    amount = 0.0;
}
…
\end{lstlisting}

As shown in the example, a comment is required in the catch clause, because you do not further propagate the exception neither do you log it.

It is also possible that you checked the preconditions, but you still have to deal with some checked exceptions:
\begin{lstlisting}
…
final var file = new File( … );
if( file.exists() )
{
    try( final var input = new FileInputStream( file ) )
    {
        …
    }
    catch( final FileNotFoundException e )
    {
        throw new UnexpectedExceptionError( "File was there when checked!", e );
    }
}
…
\end{lstlisting}

A sample for the class \lstinline|UnexpectedExceptionError| can be found in \autocite{TQUADRAT_ORG_FOUNDATION_UNEXPECTEDEXCEPTIONERROR}.

Some APIs in the JDK declares a checked exception, but that will never be thrown for the given arguments by any means. Most famous for this are the conversions from byte arrays to Strings and back:
\begin{lstlisting}
…
final String s;
try
{
    s = new String( byteArray, "UTF-8" );
}
catch( final UnsupportedEncodingException e )
{
    throw new ImpossibleExceptionError( "UTF-8 must exist!", e );
}
…
\end{lstlisting}

According to \autocite{ORACLE_DOC_CHARSET:StandardCharsets}, the UTF-8 encoding is mandatory for each JDK/JVM implementation, therefore the code sequence above will \textit{never} throw an \lstinline|UnsupportedEncodingException|. Nevertheless, it is not allowed to swallow the exception; instead an error should be thrown in the \lstinline|catch| clause, indicating the error condition. In the improbable case UTF-8 is not supported by the current Java runtime environment, the problem will surface, and the program will not die silently without any hint about the reason.\footnote{If, of course, there is no catch for \lstinline|Throwable| somewhere on the path.} It also protects you from malicious changes to the name of the character encoding: a none existing \lstinline|Charset| will cause noise.

Of course, the problem could be solved differently, by using an instance of \lstinline|java.nio.charset.Charset|\autocite{ORACLE_DOC_CHARSET_CLASS} as the argument to the \lstinline|String| constructor, instead of the name of the character encoding. For this case, the constructor does not declare an \lstinline|UnsupportedEncodingException|. 

Another example is the interface \lstinline|java.lang.Appendable|\autocite{ORACLE_DOC_APPENDABLE_INTERFACE}: it is implemented by \lstinline|java.io.Writer| and \lstinline|java.io.PrintStream|, but also by \lstinline|java.lang.StringBuilder| (and a few more). The method \lstinline|java.lang.Appendable::append| declares to throw an \lstinline|IOException|, but the implementation of that method for \lstinline|StringBuilder| will never throw it and does not even declare it.
\begin{lstlisting}
…
final Appendable appendable = new StringBuilder();
try
{
    appendable.append( "Some Text" );
}
catch( final IOException e )
{
    throw new ImpossibleExceptionError( "Append to StringBuilder", e );
}
…
\end{lstlisting}

Again, a sample for \lstinline|ImpossibleExceptionError| can be found in \autocite{TQUADRAT_ORG_FOUNDATION_IMPOSSIBLEEXCEPTIONERROR}.

Sometimes a method wants to act upon an error condition without handling the exception. In this case, it may catch the exception, does whatever necessary, then throw it again. An example:
\begin{lstlisting}
public final void myMethod() throw IOException
{
    final Predicate<String> isNetworkError = m_NetworkErrorPattern.asMatchPredicate();
    …
    try
    {
        …
    }
    catch( final IOException e )
    {
        final var message = e.getMessage();
        if( nonNull( message ) && isNetworkError.test( message ) ) ++networkErrors;
        throw e;
    }
    …
}   // myMethod()
\end{lstlisting}

It is usually not a good idea to log an exception and to rethrow or to wrap it afterwards, because this might cause the exception to be logged twice (or even more often). More details about logging can be found in chapter \tqvref{sec:Logging}.

Finally, you handle the exception somehow, by assigning a default value\footnote{see the sample about the conversion from string to number, above.}, or by performing an alternative action. In any case, you need to provide a comment in the \lstinline|catch| why you do not further delegate the handling of the exception.

If an exception was not caught in your code, it ”bubbles up” until it reaches the main method for the current thread (that is \lstinline|main()| for the main or program thread, and \lstinline|run()|\autocite{ORACLE_DOC_RUNNABLE:run} for any other thread). If this method will not handle the exception, the thread will be aborted. If this thread is the last non-deamon thread, the JVM will be terminated, too.

\subsection{Exceptions in Threads}\label{sec:ExceptionHandlingInThreads}
When we execute the Java program below, the \lstinline|Error| is printed to the console:
\lstinputlisting[numbers=left,caption={Test Abort main()}]{TestAbortMain.java}

\begin{verbatim}
$ java TestAbortMain.java
Exception in thread "main" java.lang.Error: Aborted
    at TestAbortMain.main(TestAbortMain.java:5)
$ 
\end{verbatim}

In the sample below, we abort a secondary thread:
\lstinputlisting[numbers=left,caption={Test Abort run()}]{TestAbortRun.java}

The output looks like this\footnote{When using an older version of Java, no output from the thread would be shown.}
\begin{verbatim}
$ java TestAbortRun.java
Exception in thread "Thread-0" java.lang.Error: run() aborted!
    at TestAbortRun.run(TestAbortRun.java:5)
    at java.base/java.lang.Thread.run(Thread.java:833)
Exception in thread "main" java.lang.Error: main() aborted!
    at TestAbortRun.main(TestAbortRun.java:20)
$ 
\end{verbatim}

This behaviour is sufficient for a tool in most cases, but not for a standalone application and not for a feature library. A function library usually relies on the a caller, while serverbase applications and extensions use the facilities provided by the host applications.

For both a standalone application and for a feature library, you want that error conditions will be logged, under all circumstances.

For the main thread of an application this can be achieved quite easily, by implementing the method \lstinline|main()| like this:
\begin{lstlisting}
/**
 *  The program entry method.
 *
 *  @param  args    The command line arguments.
 */
public static final void main( final String... args )
{
    try
    {
        final var application = new MyClass();
        applicaton.execute( … );
    }
    catch( final Throwable t )
    {
        //---* Log the previously unhandled exceptions *-------------
        m_Logger.error( "Unhandled Exception/Error", e );
    }
}   //  main()
\end{lstlisting}
In this case, the \lstinline|catch| statement catches \lstinline|Throwable| and the 
\lstinline|catch|-block does nothing else but logging the exception!

This is acceptable here only because the program ends immediately after the closing curly brace of the \lstinline|catch|-block!\footnote{Ok, technically only the main thread ends here because other non-deamon threads may still run at this point. But the goal should be that the main thread dies always at last.}

Theoretically, you can do the same thing for threads:
\begin{lstlisting}
public final void run()
{
    try
    {
        //---* The thread's payload *--------------------------------
        …
    }
    // NOT Recommended
    catch( final Throwable t )
    {
        //---* Log the previously unhandled exceptions *-------------
        m_Logger.error( "Unhandled Exception/Error", e );
    }
}   //  run()
\end{lstlisting}

One reason is that the method \lstinline|Runnable::run|\autocite{ORACLE_DOC_RUNNABLE:run} can be called also in other contexts than just as the main method of a thread; swallowing the exception like shown in the example is a bad idea in that case.

Another reason is that when the method is implemented as part of a library, an extension or even a serverbased application, different facilities may be used to report the error.

But the main reason is that there is a much better mechanism that handles those otherwise unhandled exceptions: the “Uncaught Exception Handler”\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER_INTERFACE}.

The interface \lstinline|java.lang.Thread.UncaughtExceptionHandler| is a functional interface\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:FunctionalInterfaces, ORACLE_DOC_LANGUAGE_SPECIFICATION:FunctionalInterface, ORACLE_DOC_FUNCTIONALINTERFACE_ANNOTATION} providing the method \lstinline|uncaughtException()|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER:uncaughtException}.

There are basically two ways\footnote{In fact, three ways. But as you should avoid anonymous classes, this option is omitted here.} to implement an uncaught exception handler; the classical way would be to create a new class:
\begin{lstlisting}[numbers=left,caption={class UncaughtExceptionHandlerImpl}]
/**
 *  The implementation of the interface
 *  {@link java.lang.Thread.UncaughtExceptionHandler}
 *  that is used by this project.
 */
public final class UncaughtExceptionHandlerImpl implements Thread.UncaughtExceptionHandler
{
    /**
     *  The logger that is used to report the uncaught exceptions.
     */
    private static final Logger m_Logger = getLogger( UncaughtExceptionHandlerImpl.class );
     
    /**
     *  {@inheritDoc}
     */
    @Override
    public final void uncaughtException( final Thread t, final Throwable e )
    {
        m_Logger.error( "Unhandled Exception/Error in Thread '%s'".formatted( t.getName(), e );
    }   //  uncaughtException()
}
//  class UncaughtExceptionHandlerImpl 
\end{lstlisting}

Otherwise you can benefit from \lstinline|java.lang.Thread.UncaughtExceptionHandler| being a functional interface and implement the uncaught exception handler as a method in your class:
\begin{lstlisting}
public final class MyClass
{
    /**
     *  The logger that is used by this class.
     */
    private static final Logger m_Logger = getLogger( MyClass.class );
     
    /**
     *  <p>{@summary This method will be invoked when the given
     *  thread terminates due to the given uncaught exception.}</p>
     *  <p>Any exception thrown by this method will be ignored by
     *  the Java Virtual Machine.</p>
     *
     *  @param  t   The thread that terminated.
     *  @param  e   The exception that caused the termination.
     *     
     *  @see UncaughtExceptionHandler#uncaughtException(Thread,Throwable)
     */
    private final void uncaughtException( final Thread t, final Throwable e )
    {
        m_Logger.error( "Unhandled Exception/Error in Thread '%s'".formatted( t.getName(), e );
    }   //  uncaughtException()
}
//  class MyClass
\end{lstlisting}
In the second case, the uncaught exception handler uses the resources provided by the class it lives in. This may be desired or not.

A thread can be configured with the uncaught exception handler in three ways:
\begin{enumerate}
\item{Each single thread can get its own uncaught exception handler by calling \lstinline|setUncaughtExceptionHandler()|\autocite{ORACLE_DOC_THREAD:setUncaughtExceptionHandler} on it, with an instance of an implementation of \lstinline|Thread.UncaughtExceptionHandler| as the argument:
\begin{lstlisting}
public final class MyClass
{
    /**
     *  Does the program's work.
     *
     *  @throws InterruptedException   The worker thread was
     *      interrupted.
     */
    private final void execute() throws InterruptedException
    {
        final var thread = new Thread( this::run, "MyWorkerThread" );
        thread.setUncaughtExceptionHandler( this::uncaughtException );
        thread.start();
        thread.join();
    }   //  execute()
     
    /**
     *  The thread's main method.
     */
    private final void run() { … }
}
//  class MyClass
\end{lstlisting}
}
\item{On creation of a thread, a \lstinline|ThreadGroup|\autocite{ORACLE_DOC_THREADGROUP_CLASS} instance will be assigned to it; if none is explicitly set, it will be the group of the current thread.

The instance has a method \lstinline|uncaughtException()|\autocite{ORACLE_DOC_THREADGROUP:uncaughtException} method is called in the case the thread itself does not have an uncaught exception handler assigned to it. To change the behaviour of the handler from the thread group it is necessary to derive a new class from \lstinline|ThreadGroup| and to overwrite the \lstinline|uncaughtException()|.

Chapter \tqvref{sec:ThreadGroup} shows an implementation for \lstinline|ThreadGroup| that allows to configure the uncaught exception handler; when using that, the configuration can look like this:
\begin{lstlisting}
public final class MyClass
{
    /**
     *  The thread group for all threads used by this program.
     */
    private final ThreadGroup m_ThreadGroup;
    
    /**
     *  Creates a new instance of {@code MyClass}.
     */
    public MyClass()
    {
        m_ThreadGroup = new ThreadGroupExt( "MyWorkerThreads", this::uncaughtException );
    }   //  MyClass()
    
    /**
     *  Does the program's work.
     *
     *  @throws InterruptedException   The worker thread was
     *      interrupted.
     */
    private final void execute() throws InterruptedException
    {
        final var thread = new Thread( m_ThreadGroup, this::run, "MyWorkerThread" );
        thread.start();
        thread.join();
    }   //  execute()
     
    /**
     *  The thread's main method.
     */
    private final void run() { … }
}
//  class MyClass
\end{lstlisting}
}
\item{By calling \lstinline|java.lang.Thread::setDefaultUncaughtExceptionHandler|\autocite{ORACLE_DOC_THREAD:setDefaultUncaughtExceptionHandler} it is possible to install an instance of \lstinline|Thread.UncaughtExceptionHandler| for all threads that does neither have their own handler nor got one from their thread group. This uncaught exception will be called as a last resort.
\begin{lstlisting}
public final class MyClass
{
    /**
     *  Does the program's work.
     *
     *  @throws InterruptedException   The worker thread was
     *      interrupted.
     */
    private final void execute() throws InterruptedException
    {
        //---* Install the default uncaught exception handler *------
        Thread.setDefaultUncaughtExceptionHandler( new UncaughtExceptionHandlerImpl() );
        
        final var thread = new Thread( this::run, "MyWorkerThread" );
        thread.start();
        thread.join();
    }   //  execute()
     
    /**
     *  The thread's main method.
     */
    private final void run() { … }
}
//  class MyClass
\end{lstlisting}
}
\end{enumerate}

The last option can be used only from standalone applications and from tools. The environments for serverbased applications and extensions do quite often restrict the creation of additional threads. A feature library should accept an uncaught exception handler and/or a thread group as a configuration value.

If a function library creates new threads, the respective methods must accept at least an uncaught exception handler and optionally a thread group. Alternatively, a thread factory\autocite{ORACLE_DOC_THREADFACTORY_INTERFACE} can be injected.
 
\subsection{Reporting Errors}\label{sec:ReportingErrors}
\subsection{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

, although these can combined with each other, to some extent:

\begin{itemize}
\item{Code in a function library, in a server-based application and in an extension should never write to the console or display an error dialog. The code of a feature library can use a message window, status bar or error dialog, if it provides these resources itself (basically, when it provides the UI).

Application servers, frameworks and the hosts for extensions usually provides a facility for error reporting that can be used; this may result in updating a message window or status bar, but for your code, this is transparent.}

\item{With a log message much more information can be provided to the user than through printing to the console or to a message window. But logging subsystems like Log4J\autocite{APACHE_LOG4J} are usually configured only for feature libraries and standalone applications. Application servers provides a logging facility, too.

If present, extensions can use the logging facility of their host. Tools usually do not use logging when they will be terminated at the first error condition.

If a library needs to issue log messages, you should consider to use SLF4J\autocite{SLF4J} instead of any other logging subsystem.

 More details about logging are discussed in chapter \tqvref{sec:Logging}.}
\end{itemize}

\subsection{Signalling an Error}\label{sec:SignallingAnError}
\begin{itemize}
\item{An exception is thrown by an operation triggered by our code. This is covered in detail in chapter \tqvref{sec:GeneralExceptionHandling}.}
\item{An operation returns an unexpected or unwanted value, and the current code is unable to cope with that situation.

Usually, we will throw an exception in that case, but for a tool, it might be also possible to immediately terminate the program, after printing an appropriate message to standard out or standard err.}
\item{Again we will throw an exception if the arguments for a method call are invalid, usually an \lstinline|java.lang.IllegalArgumentException|\autocite{ORACLE_DOC_ILLEGALARGUMENTEXCEPTION_CLASS}.}
\item{In case input data is wrong, corrupted, or missing, we have several options.

As always, we can throw an exception and let someone else solve the problem. A tool can be terminated immediately, and an extension or a serverbased application can signal the problem to the environment, as this is in most cases the source of the input data.

A standalone application may return to the user (if it has a UI) and request new data, or it may retry to get the data.

The code in a feature library may also try to get new data from the caller or from an external resource.}
\end{itemize}

\subsection{Logging}\label{sec:Logging}
\subsection{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\autocite{ORACLE_DOC_STRING_CLASS}
\autocite{ORACLE_DOC_FORMATTER_CLASS}
\autocite{ORACLE_DOC_FORMATTABLE_INTERFACE}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

Every important method has to have a trace statement that logs the method entry. If a method logs method entry, it also has to log method exit, or it has to log an exception.
For Chordiant code from the Foundation product, this will look like the sample below:
\begin{lstlisting}
public final void method()
{
    final String METHOD_NAME = "method";
    LogHelper.methodEntry( PACKAGE_NAME, CLASS_NAME, METHOD_NAME );
    …
    try
    {
        …
    }
    catch( <SomeException> e )
    {
        LogHelper.error( PACKAGE_NAME, CLASS_NAME, METHOD_NAME, "<A Message>", e );
        throw e;
    }

    //---* Done *----------------------------------------------------
    LogHelper.methodExit( PACKAGE_NAME, CLASS_NAME, METHOD_NAME );
}  // method()
\end{lstlisting}
Code from Chordiant's Marketing Director 7.0 (“Project Thunder”) would look like this:
\begin{lstlisting}
public final void method()
{
    entering();
    …
    try
    {
        …
    }
    catch( <SomeException> e )
    {
        m_Logger.log( ERROR, "<A Message>", e );
        throw e;
    }

    //---* Done *----------------------------------------------------
    exiting();
}  // method()
\end{lstlisting}
If an error conditions is to be logged that was indicated by a caught exception, that exception has to be logged including its stack trace. If the caught exception is just a wrapper for another exception (the “cause”), this exception is to be logged also, including its stack trace and its cause.
The stack trace provides vital information about the location of the problem, and sometimes also for the reason.
Any additional information that is available when the exception is caught (and relevant for the cause) should be logged also. This could be call parameters or the values of fields that are affected by a method call.
Refer to the classes in the package java.util.logging (LOGGING\_PACKAGE) to see a sample how this should look. See also chapter 5.6 below for details on exceptions.



It was said in chapter \tqref{sec:GeneralExceptionHandling} that it is usually not a good idea to log an exception and to rethrow or to wrap it afterwards. But there is on exception on this rule: sometimes you want to know about an exception that will be handled later and will be not logged then. In this case, you can log it for debugging: 
\begin{lstlisting}
public final void myMethod() throw IOException
{
    …
    try
    {
        …
    }
    catch( final IOException e )
    {
        m_Logger.debug( e );
        throw e;
    }
    …
}   // myMethod()
\end{lstlisting}

In this case, you also accept that the same exception might be logged twice.




\subsection{Exceptions}
\subsection{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\lipsum[1]

\section{Swap Logic Errors for Compiler Errors}
From a book about Java programming :
\begin{quotation}
“One fundamental principle of programming is that, generally, it is best to swap a logic error for a compiler error. Compiler errors tend to be found in seconds and are corrected just as fast. Syntax errors are a good example […]

Logic errors, on the other hand, are the bane of all programmers. They hide and hate to reveal themselves. Logic errors seem to have minds of their own, constantly evading detection and dodging your efforts to pin down their cause. They can easily take a thousand times more effort to solve than the worst compiler errors. Worst of all, many logic errors are not found at all and occur only intermittently in sensitive places, which causes your customer to scream for a fix. Logic errors often require you to throw thousands of man-hours at them, only to finally discover that they are minor typos.”

Robert Simmons Jr.: \textit{Hardcore Java}\autocite{HARDCORE_JAVA}
\end{quotation}

A sample for swapping a logic error for a compiler error is the recommendation to write comparisons always with the unchangeable value on the left side\footnote{This recommendation originates from C/C++ programming where \lstinline|if| conditions are checking values of type integer – and in C, nearly everything can be an integer, or at least be interpreted like one. Java forces that the type of the expression in the \lstinline|if| condition has to be \lstinline|boolean|, therefore this approach is less useful for Java code.}. So if you forget the second equal sign for a comparison on equal, the compiler will complain immediately:
\begin{lstlisting}
if( length() == len ) …
if( 5 == len ) …
\end{lstlisting}

Another sample for this is the recommendation to name fields with the “m\_” prefix (refer to chapter \tqfullvref{sec:Fields}). The compiler will never complain if you omit the \lstinline|this.| prefix when accessing a field, and it will not complain if you name a local variable in the same way as a field\footnote{Although you can configure both Eclipse and IntelliJ Idea to raise an error or a warning if you access a field without \lstinline|this.| and if you shadow a field through a local variable with the same name.} – but it will scream loudly about a non-existing reference if you forget the “m\_” prefix when accessing a field named along the rules defined here.

The best thing about compiler errors is, that they usually show up during development – and not first after deployment at customer side.

See also chapter \tqvref{sec:CompilerWarningsAndErrors} about compiler warnings and errors.

\section{Access to Properties}
Encapsulation is an important design principle for classes. This means that the internal state of an object can be manipulated only in a well defined manner, through the methods. Consequently, it may not be possible to modify the attributes  directly, by a direct assignment.

To achieve that, instance or class variables – also known as properties, attributes or fields – have to be \lstinline|private|.

If it is necessary to set or retrieve an instance variable (a property) directly, it mandatory to provide the appropriate methods for this (setter and/or getter, or mutator and/or accessor methods). But often attributes are set or retrieved as a side effect of method calls that modify the internal state of the object instance, or rely on it.

Programmers are inclined to use \lstinline|public| fields when the need a data structure like a \lstinline|struct| in C/C++, and not a full-fledged class. But as Java does not now that data structure, it seems to be a quick solution to have a \lstinline|class| with only \lstinline|public| fields and no methods, just to spare typing effort, and sometimes with the idea, that the direct access to the \lstinline|public| field is much faster that accessing it through a method. But modern optimising compilers will inline the code of a simple getter method, so that there is no difference in the end.

And if you want to avoid the typing, use a \lstinline|record|\autocite{ORACLE_DOC_RECORD,ORACLE_DOC_LANGUAGE_SPECIFICATION:RecordClasses} instead. Sometimes also an instance of \lstinline|java.util.Map| or another collection implementation could be an alternative to a specialised class.
 
Sometimes fields from base classes are defined as \lstinline|protected|, to make them directly accessible by methods from the derived implementations, but this is also discouraged.\footnote{The idea behind that is the same false assumption that the direct access to the \lstinline|protected| field is much faster that accessing it through a method.}

It does not matter if we talk about properties (instance variables) or \lstinline|static| field (class variables): both should always be \lstinline|private|.

Constants are the only exception, obviously, because a constant is explicitly defined as a \lstinline|public static final| field.

Regarding encapsulation in general, refer to chapter \tqvref{sec:EncapsulationWithModules}.

\section{Accessing Fields or Methods using Reflection}
First of all, you should avoid to use Reflection whenever possible. Just do not use it!\footnote{The only acceptable exception is for unit tests; we will discuss that later in this chapter.}

One reason is that accessing a field or a method via reflection causes some overhead that decreases a program’s performance. 

Next, such code is usually not easy to read or to understand, not only because of all the necessary error handling code around it.

And with modularisation, it is quite often not even possible to access methods and fields of an object via Reflection, even if they are \lstinline|public|; they are not even visible in some cases.

Of course, there are some patterns whose implementation in Java requires the use of Reflection, because any other approach is either even less performant, much more cumbersome, or will not work at all – meaning there are occasions when it is not really possible to avoid the use of Reflection. Nevertheless, you should still consider an alternative; lambdas\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:LambdaExpressions} and method references\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:MethodReference} are quite often a very good replacement for an implementation based on Reflection.

Reflection also allows you to access non-\lstinline|public| member of a class that are usually not accessible by your code. This is considered a “dirty hack” and may not be used in production code. In particular as it may not work properly with modules.

But there are useful applications for this, too: you can and should used it in unit tests for \lstinline|private| or \lstinline|protected| methods that are not \lstinline|public| for good reasons, and if these methods cannot be tested indirectly.\footnote{The alternative would be to make the method at least \lstinline|protected|, but this would make it (more) visible to the consumers of the API, and perhaps even accessible – but there was a reason why that method was originally \lstinline|private|.}

I recommend to use the following pattern if you want to access a \lstinline|private| method in your unit tests:
\begin{lstlisting}[numbers=left]
public final class MyClass
{
    /**
     *  Does something.
     *
     *  @param  value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    private final String myMethod( final CharSequence value ) throws IOException      { … }
}   
//  class MyClass

/**
 *  This class provides some unit tests for
 *  {@link MyClass}.
 */
public final class TestMyClass
{
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The reference to {@code myMethod()}.
     */
    private static final Method METHOD_myMethod;
    
    static
    {
        final var targetClass = MyClass.class;
        String methodName;
        try
        {
            methodName = "myMethod";
            METHOD_myMethod = targetClass.getDeclaredMethod( methodName, CharSequence.class );
            METHOD_myMethod.setAccessible( true );
        }
        catch( final NoSuchMethodException e )
        {
            throw new ExceptionInInitializerError( "Cannot find method '%s()' in class '%s'".formatted( methodName, targetClass.getName() ).initCause( e );
        }
    }
    
        /*---------*\
    ====** Methods **================================================ 
        \*---------*/
    /**
     *  Calls
     *  {@link MyClass#myMethod(CharSequence)}
     *
     *  @param  instance    The candidate.
     *  @param	value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    protected static final String myMethod( final MyClass instance, final CharSequence value )
    {
        final String retValue;
        try
        {
            retValue = (String) METHOD_myMethod.invoke( requireNonNullArgument( instance, "instance" ), value );
        }
        catch( final IllegalAccessException | ClassCastException e )
        {
            throw new AssertionError( e );
        }
        catch( final InvocationTargetException e )
        {
            switch( e.getCause() )
            {
                case null -> throw new AssertionError( e );
                case IOException ioe -> throw ioe;
                default -> throw new AssertionError( e.getCause() );
            }
        }
    }   //  myMethod()   
    
    @Test
    final void testMyMethod() throws Exception
    {
        final var candidate = new MyClass();
        final var result = myMethod( candidate, "" );
        assertTrue( result instanceof String );
    }   // testMyMethod()
}
//  class TestMyClass  
\end{lstlisting}
This allows you to call the method \lstinline|MyClass::myMethod| nearly directly; the method \lstinline|TestMyClass::myMethod| behaves in the same way as the original method.

\lstinline|java.lang.AssertionError|\autocite{ORACLE_DOC_ASSERTIONERROR_CLASS} is the base class for the errors thrown by JUnit\autocite{JUNIT5}.

\section{Implementing the Object Methods}
In Java all \textit{classes} are somehow extending the class \lstinline|java.lang.Object|\autocite{ORACLE_DOC_OBJECT_CLASS}, and therefore, they inherit several methods from it. Four of these methods\footnote{In fact, it is five methods, but the method \lstinline|finalize()|\autocite{ORACLE_DOC_OBJECT_CLASS:finalize} is deprecated and should not be used anymore. Refer to chapter \tqfullvref{sec:Finalisation} for more details on this topic.} can be overridden to adjust the behaviour of your class to your needs:
\begin{itemize}[nosep]
\item{\lstinline|clone()|\autocite{ORACLE_DOC_OBJECT_CLASS:clone}}
\item{\lstinline|equals()|\autocite{ORACLE_DOC_OBJECT_CLASS:equals}}
\item{\lstinline|hashCode()|\autocite{ORACLE_DOC_OBJECT_CLASS:hashCode}}
\item{\lstinline|toString()|\autocite{ORACLE_DOC_OBJECT_CLASS:toString}}
\end{itemize}

The chapters below will provide some guidelines on how to code new implementations for these methods.

\subsection{equals() and hashCode()}\label{sec:EqualsAndHashCode}
Overriding the method \lstinline|java.lang.Object::equals|\autocite{ORACLE_DOC_OBJECT_CLASS:equals} always requires to override the method \lstinline|java.lang.Object::hashCode|\autocite{ORACLE_DOC_OBJECT_CLASS:hashCode}, too – and vice versa.

\textit{This is not optional!}

The method \lstinline|equals()| returns \lstinline|true| if the given reference to refers to an object to is equals to the current one, according to \textit{your criteria what “being equal” means} in this context, and – obviously – \lstinline| false| otherwise.

So two objects can be considered to be equal when they both have the same unique id, or you require for equality that all attributes do have the same values (are also equal), or something in between. The default implementation of \lstinline|java.lang.Object.equals()| returns \lstinline|true| only if the two objects are identical\footnote{This means that both objects are the \textit{same}; the given reference points to the current object itself.}.

If two objects are equal, the result of \lstinline|hashCode()| has to be the same for both objects, but that the hash values for two objects are the same does not necessarily imply that the two objects are equal.

An implementation for the two methods should look like this:
\begin{lstlisting}[numbers=left,caption={Methods equals() and hashCode()}]
public class MyClass
{
    /**
     *  {@inheritDoc}
     */
    public boolean equals( final Object o )
    {
        var retValue = o == this;
        if( !retValue && o instanceof MyClass other
            && getClass().equals( other.getClass() ) )
        {
            retValue = Objects.equals( <attribute>, other.<attribute> )
                && Objects.equals( < … >, other.< … > );
        }
            
        //---* Done *------------------------------------------------
        return retValue;
    }   //  equals()
    
    /**
     *  {@inheritDoc}
     */
    public int hashCode()
    {
        final var retValue = Objects.hash( <attribute>, < … > );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  hashCode()    
}
//  class MyClass
\end{lstlisting}
The check in line~10 can be omitted if \lstinline|MyClass| is \lstinline|final|. If that check is omitted for a non-\lstinline|final| class, it means that instances of derived classes can be equal to an instance of the superclass – something that is rarely wanted, especially because it would break the rule that any implementation of \lstinline|equals()| has to guarantee that
\begin{lstlisting}
a.equals( b ) == b.equals( a )
\end{lstlisting}
is always valid.

The attributes that are compared in the lines~12 and following have all to be used in \lstinline|hashCode()| to calculate the hash value.

When both a superclass and its derived classes implement \lstinline|java.lang.Object::equals| and \lstinline|java.lang.Object::hashCode|, the implementation of the derived class may call the superclass implementations of \lstinline|equals()| and \lstinline|hashCode()|:
\begin{lstlisting}[numbers=left]
public class OtherClass extends MyClass
{
    /**
     *  {@inheritDoc}
     */
    public boolean equals( final Object o )
    {
        var retValue = o == this;
        if( !retValue && o instanceof OtherClass other
            && super.equals( other ) )
        {
            retValue = Objects.equals( <attribute>, other.<attribute> )
                && Objects.equals( < … >, other.< … > );
        }
            
        //---* Done *------------------------------------------------
        return retValue;
    }   //  equals()
    
    /**
     *  {@inheritDoc}
     */
    public int hashCode()
    {
        final var retValue = Objects.hash( Integer.valueOf( super.hashCode ), <attribute>, < … > );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  hashCode()    
}
//  class OtherClass
\end{lstlisting}
Obviously, both methods consider only the attributes that comes with the definition of the derived class; the attributes of the superclass are already covered.

\subsection{toString()}\label{sec:ToString}
According to \autocite{ORACLE_DOC_OBJECT_CLASS:toString}, the method \lstinline|toString()|
\begin{quotation}
“Returns a string representation of the object.

In general, the \lstinline|toString()| method returns a string that ‘textually represents’ this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. […]”
\end{quotation}

What does “textually represents” mean?

The implementation for \lstinline|java.lang.Object::toString|~…
\begin{quotation}
“[…] returns a string consisting of the name of the class of which the object is an instance, the at-sign character ‘@’, and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:\
\lstinline|getClass().getName() + '@' + Integer.toHexString( hashCode() )|”
\end{quotation}
But for an instance of \lstinline|java.lang.Integer|\autocite{ORACLE_DOC_INTEGER_CLASS}, that ‘string representation’ is just a string containing the digits for the numerical value of that object, and for an instance of \lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}, it is the current contents of the buffer.

For the class \lstinline|java.util.StringJoiner|\autocite{ORACLE_DOC_STRINGJOINER_CLASS}, \lstinline|toString()| is even the method that provides the result.

Originally, the textual representation of an object as provided by the \lstinline|toString()| method was meant only for debugging purposes, but soon it was also used for the conversion of the object's value to a string, like for the class \lstinline|java.lang.Integer|.

So how to implement the method \lstinline|toString()| for your method?

If your class represents objects that can be easily written as a string, you should implement \lstinline|toString()| accordingly:
\begin{lstlisting}
public final class PhoneNumber
{
    private final int m_AreaCode;
    private final int m_CountryCode;
    private final int m_SubscriberNumber;
    
    …
    
    /**
     *  {@inheritDoc}
     */
    @Override 
    public final String toString()
    {
        final var retValue = "+%d %d %d".formatted( m_CountryCode, m_AreaCode, m_SubscriberNumber );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  toString()
}   
//  class PhoneNumber
\end{lstlisting}

Some samples for this from the Java Runtime Library are the classes below:
\begin{itemize}
\item\lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\item\lstinline|java.lang.StringBuffer|\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\item\lstinline|java.util.UUID|\autocite{ORACLE_DOC_UUID_CLASS}
\item\lstinline|java.time.Instant|\autocite{ORACLE_DOC_INSTANT_CLASS} and the other classes representing time/date values from the \lstinline|java.time| package\autocite{ORACLE_DOC_TIME_PACKAGE}
\item\lstinline|java.io.File|\autocite{ORACLE_DOC_FILE_CLASS}
\item\lstinline|java.lang.Integer|\autocite{ORACLE_DOC_INTEGER_CLASS} and the other wrapper classes for the primitives
\end{itemize}

In all these cases, you can use a call to \lstinline|toString()| to embed the value of the instance into a regular text:
\begin{lstlisting}
final var phoneNumber = new PhoneNumber( … );
out.printf( "The customer's phonenumber is %s.", phoneNumber.toString() );
\end{lstlisting}

If your class is more complex and/or an output makes only sense for debugging purposes or requires additional formatting instructions, you should consider a different implementation of \lstinline|toString()|:
\begin{lstlisting}
public final class EmailMessage
{
    private final String m_Body;
    private final Map<RecipientType,List<EmailAddress>> m_Recipients;
    private final EmailAddress m_Sender;
    private final ZonedDateTime m_SentWhen;
    private final String m_Subject;
    
    …
    
    /**
     *  {@inheritDoc}
     */
    @Override 
    public final String toString()
    {
        final var buffer = new StringJoiner( ", ", "%s[".formatted( getClass().getName(), "]" )
            .add( "Body='%s'".formatted( m_Body ) )
            .add( "Recipients=%s".formatted( Objects.toString( m_Recipients ) ) )
            .add( "Sender='%s'".formatted( Objects.toString( m_EmailAddress ) ) )
            .add( "Sent_when=%s".formatted( Objects.toString( m_SentWhen ) ) )
            .add( "Subject='%s'".formatted( m_Subject ) );
            
        //---* Compose the return value *----------------------------    
        final var retValue = buffer.toString();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  toString()
}
//  class EmailMessage
\end{lstlisting}

This is basically how the IDEs will generate the \lstinline|toString()| method. The output may look like this\footnote{The backslash indicates where I inserted a linebreak so that it looks fine in this document; otherwise it would be just one long line.}:
\begin{verbatim}
org.tquadrat.sample.EmailMessage[Body='This is the body of the\
email', Recipients=[a.b@c.de], Sender='thomas.thrien@tquadrat.\
org', Sent_when=2022-11-26T20:31:17.884636950+01:00[Europe/Ber\
lin], Subject='Ping!']
\end{verbatim}

This will work fine for a debug log, but to get it ‘pretty printed’, you may have to provide another method. Refer to chapter \tqvref{sec:FormattableInterface} for how
this could look like.

If your class is not \lstinline|final|, the method \lstinline|toString()| should not be \lstinline|final| as well. 

\subsection{clone()}\label{sec:Clone}
Per \autocite{ORACLE_DOC_OBJECT_CLASS:clone}, the method \lstinline|java.lang.Object::clone| returns a copy of the current object.

Usually, this method is \lstinline|protected| and the default implementation throws a \lstinline|java.lang.CloneNotSupportedException|\autocite{ORACLE_DOC_CLONENOTSUPPORTEDEXCEPITON_CLASS} when called.

When instances of your class should support to be cloned, it first has to implement the interface \lstinline|java.lang.Cloneable|\autocite{ORACLE_DOC_CLONEABLE_INTERFACE}, and then you need to override the method \lstinline|clone()|.

The simpliest implementation looks like this:
\begin{lstlisting}[numbers=left,caption={A simple clone() Method}]
public final MyClass implements Cloneable
{
    /**
     *  {@inheritDoc}
     */
    @Override
    public final MyClass clone()
    {
        final MyClass retValue;
        try
        {
            retValue = (MyClass) super.clone();
        }    
        catch( final CloneNotSupportedException e )
        {
            throw new UnexpectedExceptionError( e );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  clone() 
}
//  class MyClass
\end{lstlisting}
This works despite the fact that the class \lstinline|java.lang.Object| \textit{does not} implement \lstinline|java.lang.Cloneable|!

But it fails in case your class extends a class (other than \lstinline|java.lang.Object|) that does not implement \lstinline|java.lang.Cloneable|.

The implementation of \lstinline|java.lang.Object::clone| uses native code to make a shallow copy of the current object. If all attributes of the class are either immutable or primitives, the implementation shown above is sufficient.

But if any of the attributes are collections, arrays or mutable types, there is some
more work to do; in this case, your implementation of \lstinline|clone()| should declare the \lstinline|java.lang.CloneNotSupportedException|.

Such an extended implementation of \lstinline|clone()| may look like below; it is assumed that \lstinline|T| is not immutable\footnote{If \lstinline|T| will not implement  \lstinline|java.lang.Cloneable|, we can reduce the implementation of \lstinline|clone()| to just throw \lstinline|java.lang.CloneNotSupportedException|. But even if \lstinline|T| implements \lstinline|java.lang.Cloneable|, \lstinline|T::clone| can still throw that exception.}.
\begin{lstlisting}[numbers=left,caption={An extended clone() Method}]
public final MyClass<T extends Cloneable> implements Cloneable
{
    private final T [] m_Array;
    private final Collection<T> m_Collection;
    private T m_Mutable; // MAY NOT BE FINAL!!
    
    /**
     *  {@inheritDoc}
     */
    @Override
    public final MyClass clone() throws CloneNotSupportedException
    {
        final var retValue = (MyClass) super.clone();
        for( var i = 0; i < m_Array.size; ++i )
        {
            retValue.m_Array [i] = nonNull( m_Array [i] ) 
                ? m_Array [i].clone() 
                : null;
        }
        retValue.m_Collection.clear();
        for( final var t : m_Collection ) retValue.m_Collection.add( t.clone() );
        retValue.m_Mutable = m_Mutable.clone();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  clone() 
}
//  class MyClass
\end{lstlisting}

The code in line~21 supposes that the collection does not contain any \lstinline|null| values. And obviously, the collection has to be mutable, otherwise already the attempt to clear it in line~20 would throw an exception.

Unfortunately, the interface \lstinline|java.lang.Cloneable| does not declare the method \lstinline|clone()|, therefore the code below will not work:
\begin{lstlisting}
// WILL NOT WORK!!
CloneLoop: for( final var t : m_Collection ) 
{
    if( isNull( t ) ) continue CloneLoop;
    if( t instanceof Cloneable c )
    {
        retValue.m_Collection.add( c.clone() );
    }
    else
    {
        throw new CloneNotSupportedException( t.toString() );
    }    
}   //  CloneLoop:
\end{lstlisting}

So in case a collection (or an array) may contain components that can or cannot be cloned, the test is a bit more complex:
\begin{lstlisting}
CloneLoop: for( final var t : m_Collection ) 
{
    if( isNull( t ) ) continue CloneLoop;
    boolean isCloneable = false;
    if( t instanceof Cloneable )
    {
    	isCloneable = stream( getClass().getMethods() )
    	    .filter( m -> m.getParameterCount() == 0 )
    	    .map( Method::getName )
    	    .filter( n -> n.equals( "clone" ) )
    	    .count() == 1;
    }
    
    if( isCloneable )
    {
        retValue.m_Collection.add( c.clone() );
    }
    else
    {
        throw new CloneNotSupportedException( t.toString() );
    }    
}   //  CloneLoop:
\end{lstlisting}
Instead of the stream operation, you can also use \lstinline|java.lang.Class::getMethod| and respond to the \lstinline|java.lang.NoSuchMethodException| for the check.

If you have to implement the method \lstinline|java.lang.Object::clone| for lots of classes, it could make sense to implement your own \lstinline|Cloneable| interface that then can be used with the \lstinline|instanceof| operator and the pattern:
\begin{lstlisting}
public interface Cloneable<T> extends java.lang.Cloneable
{
    /**
     *  Forces the implementation of
     *  {@link Object#clone()}
     *
     *  @returns The cloned object.
     *  @throws  CloneNotSupportedException One of the mutable
     *      attributes is not cloneable.
     */
    public T clone() throws CloneNotSupportedException; 
}
//  interface Cloneable
\end{lstlisting}

There are several ongoing discussions whether the API that was defined through the \lstinline|java.lang.Object::clone| is generally usefull or more a pain in the ass, and as far as I am aware, these discussions will last for some more time.

I am not a friend of \lstinline|clone()| and I try to avoid its implementation whenever possible. This means that sometimes it is not possible to circumvent the implementation of that method.

My recommendation is to ignore the method \lstinline|java.lang.Object::clone| unless there is a strict requirement to use it.

\section{String Concatenation}
How to concatenate strings has been a topic of discussion since the very beginning of Java. And the truth has changed with nearly each version of the language, not making it easier to decide how it is done correctly. This chapter provides some recommendations and best practices for the current versions of Java (Java~17 and later).

\subsection{The Basics}
The implementation of the concatenation of two (or more) strings – or other data types to create their representation as a text – is a trade off between readability and performance. This is due to one important characteristic of the class \lstinline|java.lang.String|\autocite{ORACLE_DOC_STRING_CLASS}: it is immutable. This means that
\begin{lstlisting}
String a = "part1";
String b = "part2";
a += b;
\end{lstlisting}
will not modify \lstinline|a| but returns a new \lstinline|String| object with the concatenated contents of \lstinline|a| and \lstinline|b| and assigns a reference to that new object to \lstinline|a|.

Older sources described the internal implementation of the \lstinline|+| operator for \lstinline|java.lang.String| like this:
\begin{lstlisting}
// NOT THE REAL IMPLEMENTATION!!
private final String operatorPlus( String a, String b )
{
    final var buffer = new StringBuffer( a )
        .append( b );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  operatorPlus()
\end{lstlisting}

This means that an intermediate object of type \lstinline|java.lang.StringBuffer|\autocite{ORACLE_DOC_STRINGBUFFER_CLASS} has to be created for each concatenation. This gets even worse if you want to append a numerical value to the String, like this:
\begin{lstlisting}
String a = "part1";
a += 42;
\end{lstlisting}

The implementation for this was described as
\begin{lstlisting}
// NOT THE REAL IMPLEMENTATION!!
private final String operatorPlus( String a, int b )
{
    StringBuffer buffer = new StringBuffer( a );
    String bString = Integer.toString( b );
    buffer.append( bString );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  operatorPlus()
\end{lstlisting}
meaning that two intermediate objects are created.

Knowing this, the recommendation was always to write
\begin{lstlisting}
String a = new StringBuffer( b )
    .append( c )
    .toString();
\end{lstlisting}
instead of
\begin{lstlisting}
String a = b + c;
\end{lstlisting}
and
\begin{lstlisting}
String a = new StringBuffer( a )
    .append( b )
    .toString();
\end{lstlisting}
instead of
\begin{lstlisting}
a += b;
\end{lstlisting}
in order to increase performance.\footnote{These recommendations origin from a time when the class \lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS} did not yet exist. Java~5 introduced \lstinline|StringBuilder| as the successor/replacement for \lstinline|StringBuffer|; it is more perfomant than \lstinline|StringBuffer| because its operations are not synchronised and therefore have less overhead than that of \lstinline|StringBuffer|.}

But with each Java version the \textit{real} implementation of \lstinline|+| and \lstinline|+=| for \lstinline|String| changed, so that today there is no longer just only one recommendation.

\subsection{Concatenating String Constants}
In your code, string literals will be always concatenated with the \verb#plus# operator:
\begin{lstlisting}
String a = "StringOne" + "StringTwo";
\end{lstlisting}
because this way, they will already be concatenated \textit{during compile time}; using \lstinline|StringBuilder| here would cause negative effects on both performance and readability. This is also true when \lstinline|static final String| variables, initialised with a literal, are concatenated with each other or with another string literal:
\begin{lstlisting}
public static final String constantA = "StringOne";
public static final String constantB = "StringTwo";
String a = constantA + constantB;
String b = constantA + "StringThree";
\end{lstlisting}
The compiler replaces each reference to the \lstinline|static final String| variables by either the literal itself or a reference to the literal and concatenates them if required.

\subsection{Concatenating String Variables}
Benchmark tests showed that beginning with one of the later versions of Java~1.4 the variant
\begin{lstlisting}
String a = "part1";
String b = "part2";
String s = a + b;
\end{lstlisting}
is significantly faster than
\begin{lstlisting}
String a = "part1";
String b = "part2";
String s = new StringBuffer( a )
    .append( b );
\end{lstlisting}
Even using \lstinline|StringBuilder| in Java~5 instead of \lstinline|StringBuffer| is slower than the \verb#+# operator.

Appending non-string values to a \lstinline|String| can be done as
\begin{lstlisting}
String a = "part1";
int b = 42;
String s = a + Integer.toString( b );
\end{lstlisting}
and that is still being faster than the \lstinline|StringBu*er| versions.

\subsection{Concatenating Strings in Loops}
The picture changes if strings are extended permanently in a loop:
\begin{lstlisting}
// AVOID!!!
public final String buildSentence( String... words )
{
    var retValue = "";
    for( final var s : words )
    {
        if( !retValue.isEmpty() ) retValue += " ";
        retValue += s;
    }
    retValue += ".";
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()
\end{lstlisting}

Here it is the better option to use \lstinline|StringBuilder| or even \lstinline|java.util.StringJoiner|\autocite{ORACLE_DOC_STRINGJOINER_CLASS}:
\begin{lstlisting}
// BETTER
public final String buildSentence( String... words )
{
    final var buffer = new StringBuilder()
    for( final var s : words )
    {
        if( buffer.length() > 0 ) buffer.append( " " );
        buffer.append( s );
    }
    buffer.append( "." );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()

// RECOMMENDED
public final String buildSentence( String... words )
{
    final var buffer = new StringJoiner( " ", "", "." );
    for( final var s : words )
    {
        buffer.add( s );
    }
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()
\end{lstlisting}

This is faster than the first version, although the concatenation with \verb#+# is usually faster than using \lstinline|StringBuilder|, because it will definitely create much less objects that has to be garbage collected later – what will have a negative impact on performance.

\subsection{Conclusion}
The recommendation is to use the \verb#+# operator for strings where to combine literals, \lstinline|String| constants and/or String variables in a single, standalone statement, but to consider \lstinline|StringBuilder| or even \lstinline|StringJoiner| if strings have to be concatenated in loops or (large) a number of consecutive statements.\footnote{But keep \autocite{KNUTH:PrematureOptimization} in mind, where Donald E. Knuth said something about “premature optimisation”.}

When “adding” primitives to a string, these should be translated to a \lstinline|String| first by calling the \lstinline|static toString()| method of the appropriate wrapper class. This is not necessary if calling \lstinline|StringBuilder::append| as this exists as specialised versions each primitive type.

Also when "adding" an instance of another type to a string, you should consider to first call \lstinline|toString()| on that object.This is not mandatory, as it is done implicitly anyway, but it clearly shows what you intended.

Finally, \lstinline|java.lang.StringBuilder| should always be preferred over \lstinline|java.lang.StringBuffer|. I have not found any use case where I could not use \lstinline|StringBuilder| and was forced to use \lstinline|StringBuffer| instead.

\section{The Annotation @API}\label{sec:APIAnnotation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{“Convention over Configuration”}
The phrase “Convention over Configuration” (or “Coding by Convention”) got popular with the introduction of Ruby on Rails, but it is related to earlier ideas like the concept of “Sensible Defaults” and the “Principle of Least Astonishment” in user interface design.

Basically it means that an object instance can be created and used properly with only minimal configuration because all not absolutely mandatory settings will have meaningful – and useful! – default values.

On the other hand, there is that number~\ref{lst:ZoP:ExplicitVsImplicit} from the “Zen of Python”, saying “Explicit is better than implicit”~…

These are obviously contradictory statements – so whose right?

Both, to some extent!

Your design should support “Convention over Configuration”, but your code should rely on defaults only when a change of these defaults in unlikely, or such a change will not have an effect to your code.

So assume that you are using a 3\textsuperscript{rd} party library that creates reports in HTML format; the default format was HTML3 with the previous version, but in the current version – that one used by you – it is HTML5. The generated reports are consumed by a tool that converts HTML5 input into PDF.

According to “Convention over Configuration”, you are fine: the convention is HTML5, you do not need to set the HTML version for the output format explicitly.

But what happens, if in a few years the next version of that report creator library will support HTML7 as the default, but your PDF generator stucks still with HTML5 for its input? Nothing happens until your successor as the maintainer of your software decides to use that new library~… afterwards you may see funny things in the generated PDF documents.

So the recommendation is: do not always rely on conventions! Whenever possible, provide an explicit configuration! At least leave a comment when you rely on the defaults, and that comment should describe what the anticipated defaults are.

\section{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{Extending Classes, Overriding Methods}\label{sec:ExtendingClassesOverridingMethods}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\subsection{Non-Final Methods}\label{sec:NonFinalMethods}
\lipsum[1]

\section{Types of Arguments and Return Values}\label{sec:TypeOfArgumentsAndReturnValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Compiler Warnings and Errors}\label{sec:CompilerWarningsAndErrors}
It is not allowed to commit any code that emits warnings or even errors on a compiler run to the SCCS. It is also not allowed to switch off any compiler warning globally.

In fact, warnings should even not show up in the development environment, also with the most aggressive settings.

It is allowed to use the annotation \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} to locally deactivate a warning. This is often necessary when dealing with legacy APIs that does not use Generics. So this sample would emit an “unchecked” warning for line 3:
\begin{lstlisting}[numbers=left]
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

To avoid this, the annotation \lstinline|@SuppressWarnings| with the value “unchecked” can be applied – preferably not to the method as a whole, but only to the problematic assignment, even if this means that an additional temporary variable is required (but not in this sample):
\begin{lstlisting}
// RECOMMENDED
public final Map<K,V> clone()
{
    @SuppressWarnings( "unchecked" ) 
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}

// AVOID!!!
@SuppressWarnings( "unchecked" ) 
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

As there is no rule without exception, here is one: I recommend to use labels to mark long code blocks (refer to the chapters \tqfullref{sec:LabelsAndBreakStatements}, \tqfullref{sec:TrailingOrEndOfLineComments}, and \tqfullref{sec:CommentsWhen}), but if those code blocks do not reference these labels, they may cause an “Unused Label” warning in your IDE. The recommendation is here to deactivate that warning – globally.

\section{Returning Values}\label{sec:ReturningValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Lambda Results}\label{sec:LambdaResults}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{The Ternary Operator “?”}\label{sec:TheTernaryOperator}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Encapsulation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Encapsulation with Modules}\label{sec:EncapsulationWithModules}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Lambdas}\label{sec:Lambdas}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\subsection{Functional Interfaces}\label{sec:FunctionalInterfaces}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{The Interface “java.util.Formattable”}\label{sec:FormattableInterface}
\section{-------------------------------------------- Proceed from here!}

\autocite{ORACLE_DOC_STRING_CLASS}
\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\autocite{ORACLE_DOC_STRINGJOINER_CLASS}
\autocite{ORACLE_DOC_FORMATTER_CLASS}
\autocite{ORACLE_DOC_FORMATTABLE_INTERFACE}

\lipsum[1]

\section{The Interface “java.lang.Comparable”}\label{sec:ComparableInterface}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{Utility Classes}\label{sec:UtilityClasses}
\section{-------------------------------------------- Proceed from here!}
\lipsum[5]

\section{try-with-resources}\label{sec:TryWithResources}
The feature \lstinline|try-with-resources| was introduced with Java~7; it can help to make programs more stable and less error prone.

\subsection{Basics}
Basically, \lstinline|try-with-resources| is an extension of the previously existing \lstinline|try-catch-finally| feature.

Instead of writing
\begin{lstlisting}[numbers=left]
InputStream input = null;
try
{
    input = new FileInputStream( file );
    …
}
catch( final IOException e )
{
    // Handle the error
}
finally
{
    try
    {
        if( input != null ) input.close();
    }
    catch( final IOException e )
    {
        // Handle the error
    }
}
\end{lstlisting}

the new feature allows you to write

\begin{lstlisting}[numbers=left]
try( final var input = new FileInputStream( file ); )
{
    …
}
catch( final IOException e )
{
    // Handle the error
}
\end{lstlisting}

It works because the interface \lstinline|java.lang.AutoCloseable|\footnote{In fact, \lstinline|InputStream| will still implement just \lstinline|java.io.Closeable|, as already before Java~7, but this interface will now extend the new interface \lstinline|java.lang.AutoCloseable|.} is implemented by the class \lstinline|java.io.InputStream|. For details refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE}.

This interface defines just one method, \lstinline|close()|, that declares to throw an exception of type \lstinline|java.lang.Exception|.

\lstinline|close()| is called automatically on all instances of \lstinline|AutoClosable| that were declared and defined in the ‘arguments list’ of the new \lstinline|try| when the scope of the \lstinline|try| block is left. If there is more than one resource defined, the sequence is reversed to that of the definition: the last assigned resource will be closed first.

So a code snippet to copy data from an input stream to an output stream may look like this\footnote{This is obviously not a very good implementation, but it illustrates how to use \lstinline|try-with-resources| quite well.}:
\begin{lstlisting}[numbers=left]
try
( 
    InputStream input = new FileInputStream( infile );
    OutputStream output = new FileOutputStream( outfile ) 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
\end{lstlisting}
Both streams will be closed properly in case of a problem or the work is done.

\subsection{Error Handling}
What will happen if the code in the \lstinline|try| block throws an exception and closing the resource will throw one, too?

For the ‘traditional’ pattern this could mean that the first exception would be ‘supplanted’ by the exception from the close. For sure, in a \lstinline|catch| block the original cause could be logged, but usually only checked exceptions (and “expected“ ones) are covered this way.

Together with \lstinline|try-with-resources|, a new feature was introduced to the language: the \textit{suppressed} exception. This deals with the problem described above.

So if the \lstinline|try| block throws an exception (for our example, it would be most probably an \lstinline|IOException|) and the \lstinline|AutoCloseable.close()| will fail with an exception, too, the latter one will be added to the first one as a “suppressed exception” by the JVM.

For this purpose, the API of the class \lstinline|java.lang.Throwable| was extended by the methods \lstinline|addSuppressed()| and \lstinline|getSuppressed()|.\footnote{see \autocite{ORACLE_DOC_THROWABLE_CLASS}}

Using \lstinline|Throwable.printStackTrace()| an output like that below will be produced:
\begin{lstlisting}
java.lang.Error
  at TryWithResources.main(TryWithResources.java:175)
  Suppressed: java.lang.Exception
    at TryWithResources$Resource2.close(TryWithResources.java:103)
    at TryWithResources.main(TryWithResources.java:176)
\end{lstlisting}

\subsection{Execution Sequence}\label{sec:ExecutionSequence}
It is important to know how the execution sequence looks like when using \lstinline|try-with-resources|. For the traditional pattern it is\\
\begin{center}
\verb#try{}->[catch{}]->finally{}#
\end{center} 
for \lstinline|try-with-resources| it will be\\ 
\begin{center}
\verb#try{}->AutoCloseable.close()->[catch{}]->[finally{}]#
\end{center}

This means that the method \lstinline|close()| on the \lstinline|AutoClosable| objects will be called \textit{before} any code in an optional \lstinline|catch| and/or \lstinline|finally| block that is attached to the \lstinline|try| block. For the sample we used above this means that the \lstinline|InputStream input| is already closed when the code in the \lstinline|catch| block that handles the \lstinline|IOException| will be executed.

Therefore the code below will not work as expected in case an exception is thrown in the \lstinline|try| block:
\begin{lstlisting}
// WILL NOT WORK!
final var logStream = new FileOutputStream( logfile )
try
(   
    final var input = new FileInputStream( infile );
    final var output = new FileOutputStream( outfile );
    final var log = logStream 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
catch( final IOException e )
{
    logStream.write( "Copy failed!\n".getBytes( UTF8 ) );
    /* Fails because the log file is already closed! */
}
\end{lstlisting}

\subsection{When to use?}
\lstinline|try-with-resources| is a very powerful feature that should be used whenever possible. Definitively it should be used with all the Java classes that already implement \lstinline|java.lang.AutoCloseable| or \lstinline|java.io.Closeable|:

\begin{itemize}
\item{The \lstinline|java.io| streams}
\item{Sockets}
\item{\lstinline|java.sql.Connection|, \lstinline|java.sql.Statement|, \lstinline|java.sql.ResultSet|}
\item{\lstinline|java.jms.Connection|}
\end{itemize}

\subsubsection{Lifecycle}\label{sec:Lifecycle}
In C++, it is a very common pattern to “wrap” the lifecycle of a resource into the lifecycle of an object:
\begin{lstlisting}[language=C++]
class Resource
{
    //---* Attributes *----------------------------------------------
    private:
        RTYPE m_Res;

    //---* Constructors *--------------------------------------------
    public:
        Resource( RTYPE &r )
        : m_Res( r )
        { m_Res.open(); }

    //---* Destructor *----------------------------------------------
    public:
        ~Resource() { m_Res.close(); }

    //---* Methods *-------------------------------------------------
    // Some methods to access the resource
    …
}
\end{lstlisting}
A use of that class might look like this:
\begin{lstlisting}[language=c++]
…
{
    Resource resource( r );

    // Do something
    …
}
…
\end{lstlisting}
The instance of \lstinline|Resource| will be constructed and \lstinline|open()| is called on \lstinline|r| on the declaration of the variable \lstinline|resource|. On leaving the scope the destructor of \lstinline|Resource| is called implicitly and \lstinline|close()| will be called on \lstinline|r|.

The C++~STL is using a very similar pattern for smart pointers.

Unfortunately, Java does not know destructors\footnote{The deprecated method \lstinline|java.lang.Object.finalizer()| that is part of each Java class is not and was never a replacement for or an alternative to a destructor as it could never be predicted when it is called (just “sometime before the JVM terminates” – if ever).}, so this pattern could not be used.

A workaround is to use a \lstinline|try-finally| block with the cleanup (usually a call to \lstinline|close()|) in the \lstinline|finally| block. But to often we have seen that in the run of modifications and/or corrections (refactorings) suddenly the \lstinline|finally| block and/or its contents had been removed (“optimised away”).

Now, with the \lstinline|try-with-resources| feature, we can have “Lifecycle” classes; they are still not that easy to use that with real destructors, but we can come close.

A sample would be the Class \lstinline|AutoLock|; for the full code, see chapter \tqfullvref{sec:AutoLock}; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

In programs that use \lstinline|java.util.concurrent.locks.Lock| or one of its implementations for thread synchronisation, you will find quite often code like this:
\begin{lstlisting}[numbers=left]
m_Lock.lock();
try
{
    // Do something
    …
}
finally { m_Lock.unlock(); }
\end{lstlisting}

This calls for a lifecycle class. Unfortunately the code below will not work, due to several reasons:
\begin{lstlisting}[numbers=left]
// Does not work!!
try( final var unused = new Lock() )
{
    // Do something
    …
}
\end{lstlisting}

First, \lstinline|java.util.concurrent.locks.Lock| will not implement \lstinline|java.lang.AutoCloseable|, and second – much more important – we cannot create a new instance of \lstinline|Lock| each time we enter the critical section.\footnote{Not to mention that \lstinline|java.util.concurrent.locks.Lock| is an interface so that \lstinline|new Lock()| cannot work at all.}

Fortunately, the \lstinline|try-with-resources| feature will not call \lstinline|close()| on the newly created object, but on the local reference (that is the reason why \lstinline|try-with-resources| will not work with anonymous instances like \lstinline|try( new Lock() )|). If we would now wrap the \lstinline|Lock| instance into a class that implements \lstinline|AutoCloseable|, we can write something like this:
\begin{lstlisting}[numbers=left]
…
AutoLock m_AutoLock = new AutoLock( m_Lock );
…
try( final var unused = m_AutoLock.lock() )
{
    // Do something
    …
}
\end{lstlisting}

\subsubsection{Post-Processing}
Together with lambdas, \lstinline|try-with-resources| can be (ab)used also to enforce a unconditional post-processing when a code block is left. This may look like this:
\begin{lstlisting}[numbers=left]
…
Runnable doAfter = …;
…
try( final var p = new PostProcessor( doAfter ) )
{
    // Do whatever necessary
    …
}
\end{lstlisting}
The \lstinline|PostProcessor| instance will call \lstinline|Runnable::run|\autocite{ORACLE_DOC_RUNNABLE:run} in its \lstinline|close()| method when the \lstinline|try| block is left. Chapter \tqfullref{sec:PostProcessor} in the Appendices provides the source for the class.

‘Unconditional’ means here that the post-processing will be executed if the block terminates regularly or by a thrown exception. Other conditions can be injected into the \lstinline|Runnable|\autocite{ORACLE_DOC_RUNNABLE_INTERFACE} implementation.

The difference between this approach and simply calling \lstinline|doAfter.run()| in a \lstinline|finally| block is that the \lstinline|close()| method of \lstinline|PostProcessor| is invoked before any code in a \lstinline|catch| block (refer to chapter \tqfullref{sec:ExecutionSequence}).

The following code snippet could be a real-life example for where this is useful:
\begin{lstlisting}[numbers=left]
final var builder = new StringBuilder();

final Runnable addTrailer = () -> builder.append( "}\n" );

…

try( final var p = new PostProcessor( addTrailer ) )
{
    …
}
\end{lstlisting}
This ensures that the string in \lstinline|builder| always terminates with a closing curly brace followed by a linefeed.

Another sample is this code snippet:
\begin{lstlisting}[numbers=left]
final List<String> list = new LinkedList();

final Runnable forceSorting = () -> list.sort();

…

try( final var p = new PostProcessor( forceSorting ) )
{
    for( final var s : loadStrings() )
    {
        list.add( s );
    }
}
\end{lstlisting}
Here the \lstinline|PostProcessor| forces that the given list is always sorted after the values had been added.

\section{Date and Time Values}\label{sec:DateAndTimeValues}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Finalisation}\label{sec:Finalisation}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Deprecation of Elements}\label{sec:DeprecationOfElements}
\section{-------------------------------------------- Proceed from here!}
\lipsum[1]

\section{Miscellaneous}
In this chapter I collected some dos and don'ts that do not fit into one of the other chapters, but are not relevant enough for a chapter on there own.

\begin{itemize}
\item{Avoid octal numerical literals in your source code! Although this feature exists since the first versions of Java, it is not very well known.

If you do not know what I talking about: start \verb#jshell#, type in \lstinline|021 + 021| and be surprised that the result is not the ultimate answer to life, the universe, and everything.\autocite{ADAMS_HITCHHIKERS_GUIDE}

Or to summarise it: Do not prefix integer literals with \verb#0#!}

\item{Avoid using an object to access a class (static) variable or method. If you cannot use a static import, refer the element through the class name instead. For example:
\begin{lstlisting}
public final class AClass
{
    public static final void classMethod() { … }
}
//  class AClass

…

import static some.package.AClass.classMethod;

public final class MyClass
{
    public final void myMethod()
    {
        // RECOMMENDED!
        classMethod(); // Using the static import
        
        // OK
        AClass.classMethod();
        
        // AVOID!!
        final var anObject = new AClass();
        …
        anObject.classMethod();
    }   //  myMethod()
}
    //  class MyClass
\end{lstlisting}

You can configure both Eclipse and IntelliJ IDEA to report the access to a static member of a class through an instance as a warning or even as an error.}

\item{In general, static imports are preferred over using the class name as prefix for references to static class members, either to class methods or to constants.}

\item{Try to initialize local variables where they are declared. The only reason not to initialize a variable where it's declared is if the initial value depends on some computation occurring first.}

\item{Avoid the multi-line initialisation for fields; use a constructor instead:
\begin{lstlisting}
public final class MyClass
{
    private final String m_Field;
    // AVOID!!!!!
    {                                                
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }
    
    /**
     *  Creates a new instance for {@code MyClass}.
     */
    public MyClass() 
    {                                                
        // INSTEAD DO IT IN THE CONSTRUCTOR!!
        final var propertyName = readConfig( "user.property" );
        m_Field = System.getProperty( propertyName );
    }   //  MyClass()
}
//  class MyClass    
\end{lstlisting}}

\item{Try to call a method only when its result is needed. This is even more true if the method does not return a value but has other effects.

Although this may seem to be self-evident, you may find often code like this:
\begin{lstlisting}
// AVOID!!!
final var logMessage = composeMessage( params );
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    writeLog( logMessage );
}
…
\end{lstlisting}
or
\begin{lstlisting}
// AVOID!!!
{
    final var param1 = retrieveData( data1 );
    final var param2 = retrieveData( data2 );
    if( option )
    {
        process( param1 );
    }
    else
    {
        process( param2 );
    }
}
\end{lstlisting}
Instead, the samples should look like below:
\begin{lstlisting}
// RECOMMENDED
if( logEnabled )
{
    //---* Log the parameters *--------------------------------------
    final var logMessage = composeMessage( params );
    writeLog( logMessage );
}

…

// RECOMMENDED
{
    final Data param;
    if( option )
    {
        param = retrieveData( data1 );
    }
    else
    {
        param = retrieveData( data2 );
    }
    process( param );
}
// RECOMMENDED/Using the trinary operator
{
    final var param = option 
        ? retrieveData( data1 )
        : retrieveData( data2 );
    process( param );
}
\end{lstlisting}
}

\item{Avoid anonymous classes! Although it (sometimes) reduces the code to write and the number of source files, it makes the resulting code very hard to read in most cases. And the number of generated class files remains exactly the same, no matter if anonymous classes, inner classes, non-\lstinline|public| or \lstinline|public| classes are used.

In most cases, you can use a lambda instead of an anonymous class.}

\item{If you are using collections or maps, declare and define them with generics.

If a legacy interface returns a collection or map that is not declared with generics, map it. The resulting warning can be suppressed using the \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} annotation.

Sometimes this may require the introduction of a temporary helper variable, as in the last sample, below.

\begin{lstlisting}
// AVOID!!
List x = new LinkedList(); 

// RECOMMENDED!!
List<String> x = new LinkedList<String>(); 

public abstract Vector method1();
public abstract Vector method2() throws IOException;
…
public static final void main( String... args )
{
    @SuppressWarnings( "unchecked" )
    final List<String> method1Result = method1();
    List<String> method2Result = null;
    try
    {
        @SuppressWarnings( "unchecked" )
        final List<String> temporary = method2();
        method2result = temporary;
    }
    catch( final IOException e ) { … }
}   //  main()
\end{lstlisting}}

\item{Using \lstinline|java.lang.Object| as the type parameter for a generic data type is useless in most cases and should be avoided:
\begin{lstlisting}
// AVOID!!!
private final List<Object> m_List = new LinkedList<Object>();
\end{lstlisting}
If you want to declare a variable of a generic type that should work for any parameter class, you have to use the question mark:
\begin{lstlisting}
Class<?> dataClass = data.getClass();
\end{lstlisting}}

\item{The classes \lstinline|java.util.Vector|\autocite{ORACLE_DOC_VECTOR_CLASS} or \lstinline|java.util.Hashtable|\autocite{ORACLE_DOC_HASHTABLE_CLASS} should not be used! Although their implementation had been modernised already with Java~1.2, their performance is still inferior to the alternative implementations, because \lstinline|Vector| and \lstinline|Hashtable| are still synchronised.

For method arguments and return values, you should use the interfaces \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} instead of \lstinline|Vector|, and \lstinline|java.util.Map|\autocite{ORACLE_DOC_MAP_INTERFACE} instead of \lstinline|Hashtable|. Refer also to chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} that elaborates further on this topic.

If you need an implementation of the \lstinline|List| interface, you should prefer \lstinline|java.util.ArrayList|\autocite{ORACLE_DOC_ARRAYLIST_CLASS} over \lstinline|java.util.LinkedList|\autocite{ORACLE_DOC_LINKEDLIST_CLASS}. The latter is only more performant in some very rare cases, and it also has a bigger memory footprint\footnote{Internally, an \lstinline|ArrayList| uses an array for the entries, and when this gets too small, a new array with twice the size will be allocated. This means that for some time two large array will exist. For really, really large lists, this may cause an issue. In the opposite, a \lstinline|LinkedList| will grow entry by entry.}.

Instead of \lstinline|Hashtable|, you should use \lstinline|java.util.HashMap|\autocite{ORACLE_DOC_HASHMAP_CLASS} as the implementation for the \lstinline|Map| interface.

If you really need a synchronised list, you can still consider to use \lstinline|Vector| as your implementation of \lstinline|List|, but for a syncronised implementation of \lstinline|Map|, you should take \lstinline|java.util.concurrent.ConcurrentHashMap|\autocite{ORACLE_DOC_CONCURRENTHASHMAP_CLASS}.}

\item{Use the enhanced \lstinline|for-loop| when iterating over collections\footnote{Ok, only implementations of \lstinline|java.util.List|\autocite{ORACLE_DOC_LIST_INTERFACE} provide methods for random access.}. It is also preferred when iterating over arrays.

Alternatively, you can use an iterator, the \lstinline|java.lang.Iterable::forEach| method, or the Stream API:
\begin{lstlisting}
// AVOID!
for( var i = 0; i < list.length(); ++i )
{
    process( list.get( i ) );
}

// RECOMMENDED
for( final var element : collection ) process( element );

collection.forEach( this::process );

// OK
for( final var i = collection.iterator(); i.hasNext(); ) process( i.next() );

collection.stream()
    .forEach( this::process );
\end{lstlisting}

The Stream API allows you to filter the elements in the collection.}

\item{Consider to use the varargs feature when a method takes only one single argument, but can be called repeatedly with different arguments, or when it takes an array as argument:

\begin{lstlisting}
public final void addListener( final Listener... listeners ) { … }
\end{lstlisting}

instead of
\begin{lstlisting}
public final void addListener( final Listener listener ) { … }
\end{lstlisting}

Obviously, the implementation now has to deal with multiple entries, but it allows to write
\begin{lstlisting}
addListener( listener1, listener2, listener3 );
\end{lstlisting}
instead of
\begin{lstlisting}
addListener( listener1 );
addListener( listener2 );
addListener( listener3 );
\end{lstlisting}
making the code easier to read.}

\item{Prefer \lstinline|java.lang.CharSequence|\autocite{ORACLE_DOC_CHARSEQUENCE_INTERFACE} over \lstinline|java.lang.String| for the type of method arguments. See also chapter \tqvref{sec:TypeOfArgumentsAndReturnValues} on the topic of argument and return types.}

\item{“Forever” loops should be coded as
\begin{lstlisting}
ForeverLoop: while( true ) 
{ 
    … 
    
    //---* Terminate the loop *--------------------------------------
    if( <condition> ) break ForeverLoop;
}   //  ForeverLoop:
\end{lstlisting} }

\item{Do not use \lstinline|new String()| with a string constant or a string expression as the argument. There are only very few situations where this is useful or necessary, and most of them are related to JNI. Usually \lstinline|new String()| is a waste of memory and computing time, except you use if with a \lstinline|byte|, \lstinline|char| or \lstinline|int| array as the argument. Refer to \autocite{ORACLE_DOC_STRING_CLASS} for the details.}

\item{Some programmers do not like the Autoboxing feature that was introduced with Java~5. It is up to you to use it, or to transform the primitive types explicitly into their corresponding object types and vice versa.\footnote{Nevertheless, you should consider “\ref{lst:ZoP:ExplicitVsImplicit}.~Explicit is better than implicit, and verbosity is your friend” – see chapter \tqvref{sec:TheBasicRule}.}}

\item{If a constructor calls a method of its own class or a superclass, this method has to be \lstinline|static|, \lstinline|private|, or \lstinline|final|\footnote{The important setting is \lstinline|final|, because \lstinline|private| and \lstinline|static| methods are implicitly \lstinline|final|}.

In addition, it may call another constructor of the same or the super class, using \lstinline|this()| or \lstinline|super()|.}

\item{Ensure that the main thread (that one that executes \lstinline|main()|) always dies as the last non-deamon thread.

This means that you should keep a reference of all the threads that your code starts so that you can kill them explicitly before the program terminates.}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}

\item{}
\end{itemize}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{-------------------------------------------- Proceed from here!}
    • If there is a getter for a field, it should be used even by the methods of the same class. Usually the same yields for setters, but there are exceptions from that rule3, in case a field can be set internally to values that are invalid if set from the outside. In such cases the direct access to the field has to be commented accordingly.
    • 
    • A method or constructor should not have more than 7 (in words: seven) arguments. If you feel inclined to provide more arguments to construct an instance, consider to use an instance of Map instead.
    • Do not use BitFields, at least do not expose them to the API. Although the Java API is using them itself, they are still problematic.
    • Whenever you have to convert a date, time or date-time value to a String that is not primarily meant to be display, used an internal format that is independent from any locale. Our recommendation is to use the ISO 8601 format “YYYY-MM-dd'T'hh:mm:ss.SSS”, normalised to UTC, and to use the class SimpleDateFormat to format the date.4
    • Although releasing resources when they are not longer needed is a good idea in most cases, it can cause trouble in rare occasions.
In some customer code we found a code sequence like this:
\begin{lstlisting}
…
}
catch( Exception e )
{
    PrintStream ps = new PrintStream( System.out );
    ps.println( "Error occured" );
    e.printStackTrace( ps );
    ps.close()
}
\end{lstlisting}
This will not only close the PrintStream ps, but also the wrapped System.out stream – with the consequence, that this exception was the last that was displayed on the console (or written to the log output).
So make sure that your code will only cleans up objects that your code is responsible for, either because it created them or the responsibility was delegated to it. In case of a wrapper (like most implementations of Stream, Reader and Writer), your code should not call methods like close() if it is not responsible for the wrapped object, as in most cases the wrapper would delegate them to the wrapped object.
    • …





\include{6_Summary}

\chapter{Appendices}

\section{The Naming Dictionary}\label{sec:TheNamingDictionary}
The names of program elements provide an implicit contract (or at least a kind of commitment) between the original author of the program and its users/maintainers. But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts here, together with a list of suffixes for class names.

\subsection{Verbs}
This chapter provides a list of verbs\footnote{Ok, some names or prefixes are not verbs, like ‘main’, ‘from’ or ‘to’~…} to be used with method names and a description of their implicit contract. These verbs are usually prefixes to a method name, although some of them could be used as standalone names, too. The form that used more often is mentioned first.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{Verbs.tbl.tex}

That a method name is built using one of the verbs above does not free you from providing a proper JavaDoc comment that describes the purpose of the method in detail, together with the arguments, return values and exceptions.

\subsection{Suffixes for Class Names}\label{sec:SuffixesForClassNames}
This chapter lists defined suffixes for class names and their function.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{ClassNameSuffixes.tbl.tex}

\section{Configurable Errors and Warnings}\label{sec:ConfigurableErrorsAndWarnings}
A very convenient feature of most IDE's is the capability to configure additional warnings and even errors for the compilation.

\subsection{Eclipse}\label{sec:EclipseErrorsAndWarnings}
tdb

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJErrorsAndWarnings}
tdb

\section{IDE Configuration}\label{sec:IDEConfiguration}
This chapter provides samples of configuration files for some IDEs. See also the chapter \tqvref{sec:ConfigurableErrorsAndWarnings} about the errors and warnings that can be configured in Eclipse and IntelliJ IDEA.

\subsection{Eclipse}\label{sec:EclipseConfiguration}
tbd

\subsubsection{Snippets}
This chapter provides the XML code for Eclipse snippets.

\paragraph{Structuring Comments}\label{sec:SnippetStructuringComments}
The snippets for the structuring comments as defined in chapter \tqfullvref{sec:StructuringComments}.
\begin{lstlisting}[language=XML,basicstyle=\ttfamily\footnotesize]
<?xml version="1.0"
      encoding="UTF-16" 
      standalone="no"?>
<snippets>
    <category filters="*"
              id="category_1145179107125"
              initial_state="0"
              label="Structuring Comments"
              largeicon=""
              smallicon="">
        <description><![CDATA[Structuring Comments as defined by the Code Conventions]]></description>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145232938375"
              label="Enum Declaration"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the enum definition part]]></description>
            <content><![CDATA[        /*------------------*\
    ====** Enum Definitions **=================================================
        \*------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179869843"
              label="Inner Classes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the inner classes part]]></description>
            <content><![CDATA[        /*---------------*\
    ====** Inner Classes **====================================================
        \*---------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251889697104"
              label="Constants"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for constants.]]></description>
            <content><![CDATA[      /*-----------*\
    ====** Constants **========================================================
        \*-----------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251888677777"
              label="Attributes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for attributes.]]></description>
            <content><![CDATA[      /*------------*\
    ====** Attributes **=======================================================
        \*------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179436656"
              label="Static Initialisations"
              largeicon="" smallicon="">
            <description><![CDATA[The header comment for the static initialisations part]]></description>
            <content><![CDATA[        /*------------------------*\
    ====** Static Initialisations **===========================================
        \*------------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180117906"
              label="Constructors"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the constructors part]]></description>
            <content><![CDATA[    	/*--------------*\
    ====** Constructors **=====================================================
        \*--------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180168796"
              label="Methods"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the methods part]]></description>
            <content><![CDATA[    	/*---------*\
    ====** Methods **==========================================================
        \*---------*/
]]></content>
        </item>
    </category>
</snippets>
\end{lstlisting}

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJConfiguration}
tbd

\section{Embedded Code}
Sometimes, it is necessary to embed code inside the Java source code. Most often, these are SQL statements, but sometimes it could be also fragments of HTML or XML documents.

\subsection{Formatting SQL inside Java}\label{sec:FormattingSQLInsideJava}

\subsection{Formatting XML inside Java}\label{sec:FormattingXMLInsideJava}
You should embed only small fragments of an XML document into the Java source; larger fragments and full documents can be handled better when provided as resources.

\subsection{Formatting HTML inside Java}\label{sec:FormattingHTMLInsideJava}
Same as for XML, also only small HTML fragments should be embedded into the Java source code. Anything else should go into a resource file.

\section{Examples}\label{sec:Examples}

\subsection{AutoLock}\label{sec:AutoLock}
This class is a sample implementation of the idea described in chapter \tqfullvref{sec:Lifecycle}, like a PoC; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={AutoLock.java}]
package org.tquadrat.util.concurrent;

import static java.util.Objects.requireNonNull;
import java.util.concurrent.locks.Lock;

/**
 *  A wrapper for locks that supports the {@code try-with-resources}
 *  feature of Java 7.
 *  The creation of the local reference to the wrapper object means
 *  some overhead but in very most scenarios this is negligible.
 *
 *  {@code AutoLock} will only expose the methods
 *  {@link #lock()}
 *  and
 *  {@link #lockInterruptibly()}
 *  of the interface
 *  {@link java.util.concurrent.locks.Lock Lock},
 *  but with a return value. Exposing other methods is not
 *  reasonable.
 *  Calling
 *  {@link #close()}
 *  on the {@code AutoLock} instance or
 *  {@link Lock#unlock()}
 *  on the wrapped {@code Lock} object inside the {@code try} block
 *  may cause unpredictable effects.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 *
 *  @see java.util.concurrent.locks.Lock
 */
public class AutoLock implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The wrapped lock.
     */
    private final Lock m_Lock;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code AutoLock} object.
     *
     *  @param  lock    The wrapped lock.
     */
    public AutoLock( final Lock lock )
    {
        m_Lock = requireNonNull( lock );
    }   //  AutoLock()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  {@inheritDoc}
     */
    @Override
    public final void close() { m_Lock.unlock(); }

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lock() lock()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     */
    public final AutoLock lock()
    {
        m_Lock.lock();

        //---* Done *------------------------------------------------
        return this;
    }   //  lock()

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lockInterruptibly()
     *  lockInterruptibly()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     *  @throws InterruptedException The current thread was
     *      interrupted while acquiring the lock (and interruption
     *      of lock acquisition is supported).
     */
    public final AutoLock lockInterruptibly() 
        throws InterruptedException
    {
        m_Lock.lockInterruptibly();
        
        //---* Done *------------------------------------------------
        return this;
    }   //  lock()
}
//  class AutoLock
\end{lstlisting}

\subsection{Patch Identification}\label{sec:PatchIdentification}

\subsection{-------------------------------------------- Proceed from here!}
The annotations \lstinline|@BUG| and \lstinline|@FixList| are part of the Foundation Base project\autocite{TQUADRAT_ORG_FOUNDATION_BASE}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={FixList.java}]
package org.tquadrat.foundation.annotation;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.MODULE;
import static java.lang.annotation.ElementType.PACKAGE;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.RECORD_COMPONENT;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.TYPE_PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 *  The annotation container for
 *  {@link BUG &#64;BUG}
 *  annotations.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
@Documented
@Retention( RUNTIME )
@Target( {ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, MODULE, PACKAGE, PARAMETER, RECORD_COMPONENT, TYPE, TYPE_PARAMETER, TYPE_USE} )
public @interface FixList
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  Provides the list of
     *  {@link BUG &#64;BUG}
     *  annotations.
     *
     *  @return The annotations.
     */
    public BUG [] value();
}
//  @interface FixList
\end{lstlisting}

\begin{lstlisting}[numbers=left,caption={BUG.java}]
package org.tquadrat.foundation.annotation;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.MODULE;
import static java.lang.annotation.ElementType.PACKAGE;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.RECORD_COMPONENT;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.TYPE_PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 *  This annotation allows to add information about applied fixes to 
 *  a program element.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
@API( status = STABLE, since = "0.1.0" )
@Documented
@Retention( RUNTIME )
@Target( {ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, MODULE, PACKAGE, PARAMETER, RECORD_COMPONENT, TYPE, TYPE_PARAMETER, TYPE_USE} )
@Repeatable( FixList.class )
public @interface BUG
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  An optional comment regarding the bug fix.
     *
     *  @return The comment.
     */
    String comment() default "";

    /**
     *  The BUG id as provided by the bug tracking system.
     *
     *  @return The BUG id.
     */
    String id();
}
//  @interface BUG
\end{lstlisting}

\subsection{PostProcessor}\label{sec:PostProcessor}
This implementation is basically a PoC; currently it is not part of any library.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={PostProcessor.java}]
package util;

import static java.util.Objects.requireNonNull;

/**
 *  Use this class to implement an uncoditional post-processing
 *  feature utilising try-with-resources.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public class PostProcessor implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The action.
     */
    private final Runnable m_Action;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code PostProcessor} object.
     *
     *  @param  action  The action that has to executed.
     */
    public PostProcessor( final Runnable action )
    {
        m_Action = requireNonNull( action );
    }   //  PostProcessor()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  Calls the
     *  {@link Runnable#run() run()}
     *  method of the
     *  {@linkplain #m_Action action}.
     *
     *  @see java.lang.AutoCloseable#close()
     */
    @Override
    public void close() throws Exception { m_Action.run(); }
}
//  class PostProcessor
\end{lstlisting}

\subsection{ThreadGroup}\label{sec:ThreadGroup}
The class \lstinline|java.lang.ThreadGroup|\autocite{ORACLE_DOC_THREADGROUP_CLASS} provides a method \lstinline|uncaughtException()| that has the same signature as the \lstinline|UncaughtExceptionHandler::uncaughtException|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER:uncaughtException} method.

The method \lstinline|java.lang.ThreadGroup:uncaughtException| is called by the Java Virtual Machine when a thread in this thread group stops because of an uncaught exception, and no specific \lstinline|Thread.UncaughtExceptionHandler|\autocite{ORACLE_DOC_UNCAUGHTEXCEPTIONHANDLER_INTERFACE} instance was installed
to that thread.

The default implementation of that method does the following:
\begin{enumerate}
\item{If this thread group has a parent thread group, the \lstinline|uncaughtException()| method of that parent is called with the same two arguments.}
\item{Otherwise, this method checks to see if there is a default uncaught exception handler installed, and if so, its \lstinline|uncaughtException()| method is called with the same two arguments.}
\item{Otherwise, this method determines if the \lstinline|Throwable| argument is an instance of \lstinline|java.lang.ThreadDeath|. If so, nothing special is done.

Otherwise, a message containing the thread's name, as returned from the thread's \lstinline|getName()| method, and a stack backtrace, using the \lstinline|Throwable|'s \lstinline|printStackTrace()| method, is printed to the standard error stream.}
\end{enumerate}

Unfortunately, the class \lstinline|java.lang.ThreadGroup| itself does not provide an API to change the behaviour of its \lstinline|uncaughtException()| method. To do that, you have to override that method in a subclass.

Below you find an implementation of \lstinline|ThreadGroup| that fixes that.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={ThreadGroupExt.java}]
package org.tquadrat.foundation.lang;

import static org.tquadrat.foundation.lang.Objects.isNull;
import static org.tquadrat.foundation.lang.Objects.requireNonNullArgument;
import static org.tquadrat.foundation.lang.Objects.requireNotBlankArgument;

import java.lang.Thread.UncaughtExceptionHandler;

/**
 *  <p>{@summary An implementation of
 *  {@link ThreadGroup}
 *  that allows to configure the behaviour of
 *  {@link #uncaughtException(Thread, Throwable)}}.</p>
 *  <p>This class is not final, to allow further modifications.</p>
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public class ThreadGroupExt extends ThreadGroup
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The
     *  {@link java.lang.Thread.UncaughtExceptionHandler}
     *  for this thread group. It can be {@code null}.
     */
    private final UncaughtExceptionHandler m_UncaughtExceptionHandler;

        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  <p>{@summary Constructs a new thread group.}</p>
     *  <p>The parent of this new group is the thread group of the 
     *  currently running thread.</p>
     *  <p>The behaviour of
     *  {@link #uncaughtException(Thread, Throwable)}
     *  is that of the superclass.</p>
     *
     *  @param  name    The name of the new thread group.
     *  @throws IllegalArgumentException    The {@code name} argument
     *      is either {@code null}, empty or blank.
     *  @throws SecurityException   The current thread cannot create
     *      a thread in this thread group.
     */
    public ThreadGroupExt( final String name ) throws IllegalArgumentException
    {
        super( requireNotBlankArgument( name, "name" ) );
        m_UncaughtExceptionHandler = null;
    }   //  ThreadGroupExt()

    /**
     *  <p>{@summary Constructs a new thread group.}</p>
     *  <p>The parent of this new group is the specified thread
     *  group.</p>
     *  <p>The behaviour of
     *  {@link #uncaughtException(Thread, Throwable)}
     *  is that of the superclass.</p>
     *
     *  @param  parent  The parent thread group.
     *  @param  name    The name of the new thread group.
     *  @throws IllegalArgumentException    The {@code name} argument
     *      is either {@code null}, empty or blank, or the 
     *      {@code parent} thread group argument is {@code null}.
     *  @throws SecurityException   The current thread cannot create
     *      a thread in this thread group.
     */
    public ThreadGroupExt( final ThreadGroup parent, final String name ) throws IllegalArgumentException
    {
        super( requireNonNullArgument( parent, "parent" ), requireNotBlankArgument( name, "name" ) );
        m_UncaughtExceptionHandler = null;
    }   //  ThreadGroupExt()

    /**
     *  <p>{@summary Constructs a new thread group.}</p>
     *  <p>The parent of this new group is the specified thread
     *  group.</p>
     *  <p>The behaviour of
     *  {@link #uncaughtException(Thread, Throwable)}
     *  is determined by the provided handler.</p>
     *
     *  @param  name    The name of the new thread group.
     *  @param  handler The handler for the uncaught exceptions.
     *  @throws IllegalArgumentException    The {@code name} argument
     *      is either {@code null}, empty or blank, or the
     *      {@code handler} argument is {@code null}.
     *  @throws SecurityException   The current thread cannot create
     *      a thread in this thread group.
     */
    public ThreadGroupExt( final String name, final UncaughtExceptionHandler handler ) throws IllegalArgumentException
    {
        super( requireNotBlankArgument( name, "name" ) );
        m_UncaughtExceptionHandler = requireNonNullArgument( handler, "handler" );
    }   //  ThreadGroupExt()

    /**
     *  <p>{@summary Constructs a new thread group.}</p>
     *  <p>The parent of this new group is the specified thread
     *      group.</p>
     *  <p>The behaviour of
     *  {@link #uncaughtException(Thread, Throwable)}
     *  is determined by the provided handler.</p>
     *
     *  @param  parent  The parent thread group.
     *  @param  name    The name of the new thread group.
     *  @param  handler The handler for the uncaught exceptions.
     *  @throws IllegalArgumentException    The {@code name} argument
     *      is either {@code null}, empty or blank, or one of the 
     *      {@code parent} thread group  or the {@code handler}
     *      arguments is {@code null}.
     *  @throws SecurityException   The current thread cannot create
     *      a thread in this thread group.
     */
    public ThreadGroupExt( final ThreadGroup parent, final String name, final UncaughtExceptionHandler handler ) throws IllegalArgumentException
    {
        super( requireNonNullArgument( parent, "parent" ), requireNotBlankArgument( name, "name" ) );
        m_UncaughtExceptionHandler = requireNonNullArgument( handler, "handler" );
    }   //  ThreadGroupExt()

        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  {@inheritDoc}
     */
    @Override
    public final void uncaughtException( final Thread t, final Throwable e )
    {
        if( isNull( m_UncaughtExceptionHandler ) )
        {
            super.uncaughtException( t, e );
        }
        else
        {
            m_UncaughtExceptionHandler.uncaughtException( t, e );
        }
    }   //  uncaughtException()
}
//  class ThreadGroupExt

/*
 *  End of File
 */
\end{lstlisting}


\subsection{UnsupportedEnumError}\label{sec:UnsupportedEnumError}
This implemenation of \lstinline|java.lang.Error| is meant to be used in the \lstinline|default| branch of a \lstinline|switch| statement (refer to \tqfullvref{sec:SwitchStatements}), in cases where the selector is an enum.

It will be used like this:
\begin{lstlisting}[numbers=left]
enum Color
{
    RED, BLUE, GREEN, YELLOW
}

Color color = …    

// Traditional switch statement
switch( color )
{
    case RED: …; break;
    case BLUE: …; break;
    case GREEN: …; break;
    case YELLOW: …; break;

    default: throw new UnsupportedEnumError( color );
}

// New switch statement
switch( color )
{
    case RED -> …;
    case BLUE -> …;
    case GREEN -> …;
    case YELLOW -> …;

    default: throw new UnsupportedEnumError( color );
}

// switch expression
var result = switch( color )
{
    case RED -> "Rot";
    case BLUE ->"Blau";
    case GREEN -> "Grün";
    case YELLOW -> "Gelb";

    default: throw new UnsupportedEnumError( color );
}
\end{lstlisting}

Also refer to \autocite{TQUADRAT_ORG_FOUNDATION_UNSUPPORTEDENUMERROR}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={UnsupportedEnumError.java}]
package org.tquadrat.foundation.exception;

import static org.tquadrat.foundation.lang.Objects.requireNonNullArgument;
import static org.tquadrat.foundation.lang.Objects.requireNotEmptyArgument;
import static org.tquadrat.foundation.lang.internal.SharedFormatter.format;

import java.io.Serial;

/**
 *  This is a specialized implementation for
 *  {@link Error}
 *  that is to be thrown especially from the {@code default} branch
 *  of a {@code switch} statement that uses an {@code enum} type as
 *  selector.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public final class UnsupportedEnumError extends Error
{
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    /**
     *  The message text.
     */
    private static final String MSG_UnsupportedEnum = "The value '%2$s' of enum class '%1$s' is not supported";

        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The serial version UID for objects of this class: {@value}.
     *
     *  @hidden
     */
    @Serial
    private static final long serialVersionUID = 1174360235354917591L;

        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new instance of this class.
     *
     *  @param  <T> The type of the enum.
     *  @param  value   The unsupported value.
     */
    public <T extends Enum<T>> UnsupportedEnumError( final T value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( value, "value" ).getClass().getName(), value.name() ) );
    }   //  UnsupportedEnumError()

    /**
     *  Creates a new instance of this class.
     *
     *  @param  type    The class of the enum.
     *  @param  value   The unsupported value.
     */
    public UnsupportedEnumError( final Class<? extends Enum<?>> type, final String value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( type, "type" ).getName(), requireNotEmptyArgument( value, "value" ) ) );
    }   //  UnsupportedEnumError()
}
//  class UnsupportedEnumError

/*
 *  End of File
 */
 \end{lstlisting}

\listoftables

\lstlistoflistings

\begin{FlushLeft}
\printbibliography
\end{FlushLeft}

\printindex
\end{document}
