%% LaTeX2e file `Verbs.tbl.tex'
%% generated by the `filecontents' environment
%% from source `JavaCodingConventions' on 2022/11/10.
%%
  \begin{longtable}{|l|X|}
    \caption{Verbs} \\
    \hline
    Verb & Contract \\
    \hline\endfirsthead
    \caption{Verbs (continued)} \\
    \hline
    Verb & Contract \\
    \hline\endhead

    \makecell{\lstinline|add…( <arg> )| \\ \lstinline|add( <arg> )|} & A method with this name will add the given argument value to an internal list in the object, keeping the argument as it is, so that it could be retrieved again later.\newline Usually, an ‘add’-method would not return something. \\
    \hline

    \makecell{\lstinline|append( <arg> )| \\ \lstinline|append…( <arg> )|} & The name ‘append’ for a method indicates that it will append the given argument to an extensible data structure, usually with interpreting the argument in some way. In most cases, it is not possible to retrieve the argument from the data structure afterwards. This a typical method for a builder, so usually the method returns the owning object itself (\lstinline|this|).\newline A sample for this is \lstinline|java.lang.StringBuffer.append()|. \\
    \hline

    \makecell{\lstinline|build()|} & The terminal method for a builder has this name. It returns the built object. Usually it can be called only once on the owning object. \\
    \hline

    \makecell{\lstinline|call()|} & This is the name of the main method of a thread that returns a result (an implementation of the \lstinline|Callable| interface) and should usually only used in this or a similar context.\newline For details on this, refer to \autocite{ORACLE_DOC_UTIL_CONCURRENT_PACKAGE} and \autocite{ORACLE_DOC_CALLABLE_INTERFACE}. \\
    \hline

    \makecell{\lstinline|check()| \\ \lstinline|check( <arg> )| \\ \lstinline|check…()|} & Usually ‘to check’ is understood as testing for a given condition, but sometimes it is also used if an object should be marked (as used in “CheckBox”). I do not recommend the latter usage (use ‘mark’ instead), and because of the chance to generally misinterpret the verb, I do not recommend to use it at all.\newline If used anyway, the respective method may not modify the object and it should return a boolean. \\
    \hline

   \makecell{\lstinline|clear()|} & A method with this name will empty or reset the owning object. \\
    \hline

   \makecell{\lstinline|clone()|} & The method \lstinline|clone()| creates an identical copy of the owning object.\newline Refer to \autocite{ORACLE_DOC_OBJECT_CLONE_METHOD} and \autocite{ORACLE_DOC_CLONEABLE_INTERFACE}. \\
    \hline

    \makecell{\lstinline|close()| \\ \lstinline|close…()|} & This name will be assigned to methods to close a connection to an external resource, like a file or device.\newline Refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE} and \autocite{ORACLE_DOC_CLOSEABLE_INTERFACE} for details. \\
    \hline

    \makecell{\lstinline|compose…( <arg> )| \\ \lstinline|compose…()|} & A ‘compose’ method will compose a new object or data structure from the internal state and the given arguments – if any. It will not modify the owning object itself, and each call with identical arguments (and on an unchanged object) will return the same value. Different from a ‘build’ method, a ‘compose’ method can be called more than once on the same object instance. \\
    \hline

    \makecell{\lstinline|connect()| \\ \lstinline|connect( <arg> )| \\ \lstinline|connect…()| \\ \lstinline|connect…( <arg> )|} & A method with this name initialises the connection of the owning object to an external resource, like a device or a remote system. \\
    \hline

    \makecell{\lstinline|copy( <arg> )|} & A ‘copy’ method makes a copy of the given argument and returns it. If this is an identical copy (like through the invocation of \lstinline|clone()| or not depends from the implementation. \\
    \hline

    \makecell{\lstinline|create…( <arg> )| \\ \lstinline|create…()|} & This name indicates a method that creates something based on the given arguments, but different from the ‘compose’ method, each call can have a different result, even for identical arguments.\newline A ‘create’ method usually returns created entity as the result. \\
    \hline

    \makecell{\lstinline|delete()| \\ \lstinline|delete( <arg> )|} & A method with the name ‘delete’ deletes something, either identified by the state of the owning object or by the given arguments. A sample would be \lstinline|java.io.File::delete| that removes the file that is associated with the respective instance of \lstinline|java.io.File|. \\
    \hline

    \makecell{\lstinline|execute()| \\ \lstinline|execute( <arg> )|} & This is the name for a method that does the program's or application's work. Usually the arguments are the command line arguments for the program, although this is not mandatory.\newline This is used in pattern similar this:
\begin{lstlisting}[xleftmargin=.7cm,numbers=left]
public final class MyProgram
{
    public final void execute( final String [] args ) { … }
    public final boolean initialize( final String [] args ) { … }
    public static final void main( final String... args )
    {
        final var application = new MyProgram();
        if( application.initialize( args ) ) application.execute();
    }   //  main()
}
//  class MyProgram
\end{lstlisting}
    Obviously, the method \lstinline|initialize()| is optional, put if available, only this may take the command line arguments instead of lstinline|execute()|, too.\newline This allows to use an application/program class also in the context of another program/application. \\
    \hline

    \makecell{\lstinline|exec…()| \\ \lstinline|exec…( <arg> )|} & Use the prefix \lstinline|exec| to name methods the will execute an operation, identified by the main part of the name. The arguments are parameters for this operation.\newline Nothing is said about the state of the owning object, any return values or the state of the arguments. \\
    \hline

    \makecell{\lstinline|from( <arg> )| \\ \lstinline|from…( <arg> )|} & Methods with the name \lstinline|from()| or a name prefixed with ‘from’ had been introduced with the \lstinline|java.time| API and Java~8. These are static factory methods that create an instance of the owning class based on the given argument (usually a String). \\
    \hline

    \makecell{\lstinline|generate…()| \\ \lstinline|generate…( <arg> )| \\ \lstinline|generate()| \\ \lstinline|generate( <arg> )|} & A ‘generate’ method generates something based on the object state, with or without changing it. Each call to generate may have a different result, even for the same arguments – this distinguishes it from ‘compose’.\newline Different from a ‘create’ method, a ‘generate’ method may work on entities outside the program (a file, an image, a report, …); this means it does not have a return value, or the return value is just the status of the generation process. \\
    \hline

    \makecell{\lstinline|get…()|} & The prefix \lstinline|get| indicates a \textit{getter} method; it does not take any arguments, and it does not change the state of the owning object.\newline The remaining part of the method name is known as the ‘property name’: the getter returns the value for that property (attribute). For more details, refer to \autocite{ORACLE_DOC_JAVABEANS:Chapter8_3}\footnote{Although the whole document \autocite{ORACLE_DOC_JAVABEANS} could be relevant here.}.\newline A special variant is the method \lstinline|public static <Type> getInstance()| method: it returns an instance of the class \lstinline|<Type>| – each invocation returns the same instance. It does not matter whether the first invocation creates that instance, or if it will exist previously. \\
    \hline

    \makecell{\lstinline|has…()| \\ \lstinline|has( <arg> )| \\ \lstinline|has…( <arg> )|} & A method with a name starting with \lstinline|has| checks whether the owning object ‘contains’ something, either identified by the rest of the name, or by the given argument. Samples could be \lstinline|hasChildren()| for a tree node object, or \lstinline|hasOrders()| for a customer record instance.\newline Calling the method may not change the state of the owning object. \\
    \hline

    \makecell{\lstinline|initialize()| \\ \lstinline|initialize( <arg> )|} & The ‘initialize’ method does what its name says: it initialises the owning object. Obviously, this changes the state of that object.\newline If the method cannot be called multiple times, it should throw an \lstinline|IllegalStateException| on any invocation after the first. \\
    \hline

    \makecell{\lstinline|is…()|} & This is the prefix for a \textit{getter} that returns a \lstinline|boolean|. Refer to \lstinline|get…|, above. \\
    \hline

    \makecell{\lstinline|load()| \\ \lstinline|load( <arg> )|} & The method with the name \lstinline|load()| ‘loads’ the data for the owning object from somewhere (usually an external source) and initialises it with this data. The argument is usually the reference to the source.\newline The return type is either \lstinline|void|, or the method returns some kind of status for the load operation.\\
    \hline

    \makecell{\lstinline|load…()| \\ \lstinline|load…( <arg> )|} & If this is used as the prefix for a method name, that method also loads data from an external source, but it initialised and returns a data structure that is described by the remainder of the name.\newline Depending on the context, a name like \lstinline|loadData()| could be valid, but some more meaningful is preferred, like \lstinline|loadClientHistory()| or \lstinline|loadArticleList()|. \\
    \hline

    \makecell{\lstinline|main()| \\ \lstinline|main( <arg> )|} & Although ‘main’ is not a reserved word in the Java language, it should be treated as one. Therefore a method should never be named as \lstinline|main()| unless it is the program entry point. Not to mention that ‘main’ is not even a verb at all.\newline The usual signature for the main method is
\begin{lstlisting}
public static void main( String [] args )
\end{lstlisting}
but I prefer it as
\begin{lstlisting}
public static final void main( final String... args )
\end{lstlisting}
Refer to \autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:Invoke_Test.main}. \\
    \hline

    \makecell{\lstinline|make…()| \\ \lstinline|make…( <arg> )|} & The prefix ‘make’ is similar to ‘create’,‘compose’, or ‘generate’, but usually a method with a name starting with ‘make’ produces something outside the program – like a file or a database (table). In this regard it is like ’generate’, but the process of ‘making’ is less complex as that of ‘generation’. \\
    \hline

    \makecell{\lstinline|mark()| \\ \lstinline|mark( <arg> )| \\ \lstinline|mark…()| \\ \lstinline|mark…( <arg> )|} & A ‘mark’ method changes the state of the owning object by setting (when taking a \lstinline|boolean| argument) or toggling (when taking no argument) an internal flag (see also ‘check’). Usually those methods will not return something, but for chaining, they can return \lstinline|this|, or they return the previous state of the flag. \\
    \hline

    \makecell{\lstinline|obtain…()| \\ \lstinline|obtain…( <arg> )|} & A method with a name prefixed with ‘obtain’ is similar to a getter, but with the difference that an ‘obtain’ method can change the state of the owning object, and that it does not necessarily return just a property. \\
    \hline

    \makecell{\lstinline|of( <arg> )|} & The method name \lstinline|of()| was more or less introduced with Java~9 and the static factory methods for \lstinline|java.util.List|,  \lstinline|java.util.Set| and  \lstinline|java.util.Map|. The methods with the that name creates an instance of owning class containing the given arguments.\newline If there is no argument, an empty instance will be created. \\
    \hline

    \makecell{\lstinline|open()|} & An ‘open’ method opens a connection to an external resource that is represented by the owning object. Obviously, that object changes its state.\newline Usually, \lstinline|open()| will not return something; or when it returns something, in will be that status of the open operation.\newline It will also not take any arguments as all necessary information are given by the state of the owning object. \\
    \hline

    \makecell{\lstinline|open…( <arg> )| \\ \lstinline|open( <arg> )|} & A method with a name that is prefixed with ‘open’ will also open a connection to an external resource, but it will return an object representing this connection or the external resource. The required information can either be taken from the owning object or given as the arguments or both.\newline Such a method may or may not change the state of the owning object. And the owning object may or may not provide a corresponding ‘close’ method.\newline A sample could be a method
\begin{lstlisting}
public final File openLogFile( final File logFolder ) {…}
\end{lstlisting}
that can be even used with \lstinline|try-with-resources|. \\
    \hline

    \makecell{\lstinline|peek()|} & A method with this name is meant to spy into a data structure without modifying the state of the owning object. The method \lstinline|java.util.Queue::peek| \autocite{ORACLE_DOC_QUEUE_INTERFACE:peek} is a sample for this.\newline The method \lstinline|java.util.stream.Stream::peek| \autocite{ORACLE_DOC_STREAM_INTERFACE:peek} does not examine a data structure, but it allows to spy on the intermediate results of the stream processing. \\
    \hline
  \end{longtable}
