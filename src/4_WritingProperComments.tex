\chapter{Writing proper Comments}\label{sec:WritingProperComments}
Comments are crucial for the understanding of source code, in any programming language. Source code without any comments is not maintainable, meaning it is worthless in the long run.

In addition, Java also provides a tool that allows to externalize program comments, so that they can be used as the external documentation; the name of this tool is \textit{JavaDoc}. The “Javadoc Guide”\autocite{ORACLE_DOC_JAVADOC_GUIDE} provides an overview of the tool\footnote{see \autocite{ORACLE_DOC_JAVADOC_MAN} on how to invoke the tool on your source code}, the “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG} explains how to write the comments for a proper documentation generated with the JavaDoc tool.\footnote{JavaDoc is not the only tool for this purpose; another well known tool is Doxygen\autocite{DOXYGEN_HOMEPAGE} that was created primarily to generate the documentation for annotated C++ code, but it works also for Java, C and several other programming languages. But for Java sources, JavaDoc is the preferred tool.}

So Java source code can generally have three kinds of comments:
\begin{itemize}[nosep]
\item{documentation comments}
\item{implementation comments}
\item{maintenance comments}
\end{itemize}
In Java, the \textit{documentation comments} (also known as “doc comments” or “the JavaDoc”) are delimited by “\verb#/**…*/#” and cannot be placed everywhere; they will be externalised for the generation of the program/library documentation. Obviously, \textit{implementation comment}s are the other comments, that are not externalized and published.

\textit{Maintenance comments} are technically a special form of implementation comments, but as the have a special function, they are covered separately (see chapter \tqfullvref{sec:MaintenanceComments}).

Roughly, the documentation comments describe how to use the code (the API), unrelated to the implementation, while the implementation comments describe what the code is doing and why.

Comments should be used to give overviews of code and provide additional information that is not readily available in the code itself. Comments should contain only information that is relevant to reading and understanding the program. For example, information about how the corresponding package is built or in what directory it resides should not be included as a comment to a class.

Discussion of non-trivial or non-obvious design decisions is appropriate, but avoid duplicating information that is present in (and clear from) the code. It is too easy for redundant comments to get out of date. In general, avoid any comments that are likely to get out of date as the code evolves.

The frequency of comments reflects poor quality of code. Unfortunately, code can be “under-commented” or “over-commented”, meaning there is a “frequency band” for comments that has to be hit for good quality code.

One often heard advice is: “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” But clearer to whom?

With increasing programming experience, things get more and more obvious to the programmers, so they write lesser comments – with the result, that newbies do not have any help to understand the code written by the experts.

Obviously, the advice: “Even if you don't think, a comment might be necessary, add it nevertheless” is the other extrema and equally bad, so writing proper comments remains a complex art, but it follows some rules, and for the rest, we will give some advice. Refer to chapter \tqfullvref{sec:CommentsWhen} where this is discussed further.

In general:
\begin{itemize}
\item{Comments should not be enclosed in large boxes drawn with asterisks or other characters, with the exception of structuring comments as described below.}
\item{Comments should never include special characters such as tabulator, form-feed and backspace or alike. In JavaDoc comments only (see below), most other non-ASCII characters should be escaped with their HTML equivalent.}
\item{While code lines can have any length, comment lines will always end in or before column 80, except when their contents cannot be wrapped (like URLs for references to additional information).}
\item{Comments should be in full sentence and using a clear language.}
\item{Finally: all comments has to be in English language; they should be grammatically correct and without typos.\footnote{…~but it is still much more important that there is at least \textit{some} comment than a correctly spelled one.}}
\end{itemize}

\section{Documentation Comments}\label{sec:DocumentationComments}
It is a well known fact that most programmers are poor technical writers. That's the reason why programmers rarely write the public documentation for their product.

But that is no excuse why programmers do not write proper documentation comments into their source code. They are the only people that could write these comments because technical writers usually do neither have the time nor the required skills to analyse the code to extract the information from it that is necessary for the documentation.\footnote{In addition, the technical writers often do not have (write) access to the source code and are therefore not able to add the documentation comments.}

In general there are (at least) two different target groups for the documentation that is generated from the documentation comments. The first group are the maintenance programmers, the second are programmers writing code interfacing with this one, using the public APIs. This means that each program element that can have a documentation comment must have a documentation comment! No exception! No excuse for missing documentation comments! The programmer must provide a documentation comment wherever it is possible. 

Eclipse can be configured in a way that it will issue warnings or even errors for missing documentation comments: see \verb#Window|Preferences|Java|Compiler|Javadoc#.

To achieve the same for IntelliJ IDEA, you go to \verb#File|Settings#, and there you select \verb#Editor|Inspections>Java>Javadoc#.

Documentation comments describe Java modules, packages, classes\footnote{All types of \textit{classes}, including \textit{interfaces}, \textit{enums}, \textit{records} and \textit{annotations}}, constructors, methods, and fields\footnote{All types of fields: \textit{attributes}, \textit{constants}, but also the \textit{enum values}}. Each documentation comment is set inside the comment delimiters “\verb#/**…*/#”, with one comment per module, package\footnote{The documentation comment for a Java package is special; refer to chapter \tqfullvref{sec:PackageDocumentation} for the details}, class, or member. This comment has to appear just before the declaration:

\begin{lstlisting}
/**
 *  The Example class provides …
 */
public class Example
{
    /**
     *  The inner class provides …
     */
    private static class InnerClass
    {
        …
    }
    //  class InnerClass
     
    …
    
    /**
     *  This flag …
     */
    private boolean m_Flag;
    …

    /**
     *  Method that performs some action …
     *
     *  @param  arg   The argument.
     */
    public final void method( int arg )
    {
        …
    }   //  main()
}   //  class Example
\end{lstlisting}

The first line of the documentation comments (“/**”) for top level classes is not indented; subsequent lines for the documentation comment have one space of indentation (to vertically align the asterisks). All members, including inner classes, have 4 spaces for the first documentation comment line and 5 spaces thereafter (this is congruent for inner classes).

If you need to give information about a class, interface, variable, or method that isn't appropriate for the public documentation, use an implementation comment immediately after the declaration. For example, internal details about the implementation of a class should go in such an implementation block comment following the class statement, not in the class documentation comment.

Documentation comments should not be positioned inside a method or constructor definition block, because Java associates documentation comments with the first declaration after the comment.

\subsection{Structure and Contents}\label{sec:StructureAndContents}
Latest since the introduction of Java~9, the JavaDoc tool produces (more or less) correct HTML~5 documents from the JavaDoc comments in the source code. Therefore it is strongly recommended to use correct HTML~5 syntax inside the documentation comments itself. This means that tags has to be closed properly, empty tags like \lstinline|<br>| and \lstinline|<img>| are not closed, and so on.

If the comment has more than one single paragraph, use the \lstinline|<p>| tag; do not use the \lstinline|<br>| tag:

\begin{lstlisting}
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The first sentence of each JavaDoc comment is taken to be placed on an overview. Per default, that sentence is defined as everything from the beginning until the first full stop followed by a blank (“. ”) or other whitespace, or the first not-inline HTML tag.

This means that a comment like this

\begin{lstlisting}
// AVOID!!
/**
 *  <b>Returns the status for this operation.</b>
 *
 *  …
 */
\end{lstlisting}

may cause some strange output\footnote{Writing the comment like that (with the \lstinline|<b>…</b>| tag) should be avoided anyway.}. Java~10 introduced the JavaDoc tag \nameref{sec:TagSummary} to address issues like this; it allows the programmer to explicitly specify what portion of the JavaDoc comment appears in the overview rather than relying on JavaDoc's default behaviour to determine the summary portion of the comment. Refer to \autocite{ORACLE_DOC_JAVADOC_TAG,DZONE_JAVADOC_SUMMARY} for the details and additional samples.

The \nameref{sec:TagSummary} tag has to be used always when a documentation comment has more than one sentence:

\begin{lstlisting}
// OK – as single sentence
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
// AVOID!! – Two sentences. 
/**
 *  <p>Returns the status for this operation. The return value will 
 *  never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

// RECOMMENDED
/**
 *  <p>{@summary Returns the status for this operation.} The return 
 *  value will never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>{@summary Returns the status for this operation.}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The documentation comments for modules, packages and classes may get longer, so that you want to structure it by giving headlines to sections. Usually this is done through the HTML tag \lstinline|<h#>|, with \# being a number in the range from 1 to 6. You can use these tags in the documentation comments, too, but the tags \lstinline|<h1>| and \lstinline|<h2>| are already used by JavaDoc itself; that means that you should only use \lstinline|<h3>| to \lstinline|<h6>| in the documentation comments.\footnote{In the overview comment (refer to chapter \ref{sec:OverviewComment}), you can make use of the all the \lstinline|<h#>| tags to structure that comment.}

When a class, method, constant, field is mentioned the first time in a documentation comment, its documentation should be linked, using the \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tags. This is not necessary if the type is used for a formal parameter or the return value. In these cases, JavaDoc generates these links automatically.

Each \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tag has to placed into a line of its own.

Some examples:
\begin{lstlisting}
/**
 *  <p>{@summary Searches the given key in the list and returns the
 *  associated data.} If the key is
 *  {@linkplain String#isBlank() blank},
 *  the method will throw a
 *  {@link BlankArgumentException},
 *  while an empty will just not return a result.</p>
 *
 *  @param  key The key.
 *  @returns An instance of
 *      {@link Optional}
 *      that holds the search result.
 *  @throws IllegalArgumentException    The key is somehow invalid.
 *
public final Optional<Data> searchData( final String key ) { … }
\end{lstlisting}

JavaDoc creates links to the documentation of \lstinline|java.lang.IllegalArgumentException|, \lstinline|java.lang.String| and \lstinline|Data| automatically; it also creates a link to \lstinline|java.util.Optional| but it is recommeded to use the pattern shown here, even when this means that the comment holds two links to the \lstinline|Optional| class documentation.

The names of classes, methods, constant, fields, parameters etc. as well as \lstinline|null|, \lstinline|true|, and \lstinline|false| have to be written in a monotype font. This can be achieved by encapsulating them in \lstinline|<code>…</code>| HTML tags or placing them inside the JavaDoc \nameref{sec:TagCode} tag. The monotype font is used automatically for everything inside a \nameref{sec:TagLink} tag.

Each comment, including each text for a \nameref{sec:TagParam}, \nameref{sec:TagReturn}, and \nameref{sec:TagThrows} tag, ends with a full stop.

The document “How to Write Doc Comments for the Javadoc Tool”\autocite{ORACLE_DOC_JAVADOC_HOWTO} is already a little bit older and therefore outdated in parts, but it still provides some useful hints on how to write proper documentation comments that should be processed by the JavaDoc tool.

\subsubsection{The Overview Comment}\label{sec:OverviewComment}
When the JavaDoc tool is called with the option \verb#-overview <filename># (see \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}), an ‘Overview’ comment is  added to the generated documentation. \verb#<filename># is the (fully-qualified)  filename of a valid HTML~5 document (The recommended name is \verb#overview.html#) containing general information about the project.

You can put nearly everything here, from the project's history to manual on how to use the program or library, but you should not reproduce information that is given in the module, package, or class documentation comments.

Several JavaDoc tags can be also used in the overview comment; for details refer to the chapter "Where Tags Can Be Used" in \autocite{ORACLE_DOC_JAVADOC_TAG}.

\subsubsection{The module Comment}\label{sec:ModuleComment}
The \verb#<module description># (refer to chapter \tqfullref{sec:ModuleDefinition}) describes the current module, its dependencies and what it provides. See the JavaDoc tags \nameref{sec:TagProvides} and \nameref{sec:TagUses} for details.

If the project has just one module, the module comment can replace the overview comment.

\subsubsection{The package Comment}\label{sec:PackageComment}
Each and every Java package has to have a file named \verb#package-info.java#; the structure of that file was already discussed in chapter \tqfullvref{sec:PackageDocumentation}.

The \verb#<package description># provides information about the package. So it describes the purpose of the classes in this package. It lists conventions that are common for all contained classes, it should specify their prerequisites.

If the package defines a single API, it can describe the usage of that API, too. 

The package comment can list the authors of the code, using the \nameref{sec:TagAuthor} tag\footnote{Or the tag \nameref{sec:TagExtAuthor}, refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc})}, the version with the \nameref{sec:TagVersion} tag, when the package was created or with which version it was integrated with the \nameref{sec:TagSince} tag, and other things.

It should not repeat details that are written already in the documentation of a class in that package, instead it should reference that class documentation. If those details are  important for the whole package, it should be considered to move them from the class comment to the package description and place a reference into the class documentation instead.

The package comment for the main package of a project can replace the overview comment (if not the module comment is used for this\footnote{Not all projects will produce modules, so it is possible that your project does not have a module definition file at all.}).

\subsubsection{The class Comment}\label{sec:ClassComment}
The documentation comment for a class, an interface, an enum, a record or an annotation (the ‘class comment’) describes that class, its purpose and its usage. If the class is not \lstinline|final|, the comment should provide some hints what the mount points\footnote{Another term for “mount point” is “extension point”, but I do not like this expression as we do not always “extend” a class on these points. Most often we replace existing behaviour to customise the class to our needs.} are and how to utilise them.

Then the class comment should list the authors of the class, using the \nameref{sec:TagAuthor} tag, the class version (using the \nameref{sec:TagVersion} tag), and when the class was added to the project with the \nameref{sec:TagSince} tag\footnote{Although this can be omitted if this information is already given within the package.}.

In case of a parametrised type (a ‘generic’), it contains a \nameref{sec:TagParam} tag for each formal parameter.

Here a real life sample for an interface:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object). It is based on sample code from the book &quot;Java
 *  Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @author Thomas Thrien - thomas.thrien@pega.com
 *  @version <version information>
 *  @since 1.2.3
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}

The \verb#<version information># should be a reference to the version in the SCCS; if you are using Subversion, that line would look like this:
\begin{lstlisting}
/**
 …
 *  @version $Id:$
 …
 */
\end{lstlisting}

I also recommend to use the custom tags provided by the “Foundation JavaDoc” project\autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC} (see chapter \tqfullvref{sec:CustomTagsForJavaDoc}); then the same class documentation comment would look this:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object).
 * 
 *  @inspired &quot;Java Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @extauthor Thomas Thrien - thomas.thrien@pega.com
 *  @version $Id:$
 *  @since 1.2.3
 *
 *  @UMLGraph.link
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}
The tag \nameref{sec:TagExtAuthor} is an enhanced replacement for the \nameref{sec:TagAuthor} tag, and the tag \nameref{sec:TagUMLGraph} places an UML diagram for the current class to the generated documentation.

\subsubsection{The Field Comment}\label{sec:FieldComment}
Attributes/properties, constants and enum values are all summarised under ‘fields’ here.

Each and every field will have a comment, the ‘field comment‘, describing it. For \lstinline|private| fields it can be sufficient to refer to the related getter method instead of writing a lengthy comment into the field comment itself; do not use the \nameref{sec:TagSee} tag instead of the \nameref{sec:TagLink} tag:
\begin{lstlisting}
/**
 *  Refer to
 *  {@link #getValue()}.
 */
private final Value m_Value;

// AVOID!!
/**
 *  @see #getOtherValue()}.
 */
private final Value m_OtherValue;
\end{lstlisting}

If there is no getter method for a field, or it is not \lstinline|private|, a description is mandatory. Usually one sentence might be sufficient, although \lstinline|public| constants may require a full fledged usage description if that is not given elsewhere (for example, in the class comment or the package comment) and a reference to that description could be placed here.

It is always a good idea to describe the valid values for the field, its default value, and if \lstinline|null| is a possible value for a reference. This is a must for non-\lstinline|final| \lstinline|public| or \lstinline|protected| fields.

For a serialisable class, the fields that will be serialised should be tagged with \nameref{sec:TagSerial} and the appropriate description.

Constants (\lstinline|public static final| fields) that are initialised with a literal have to use the \nameref{sec:TagValue} tag in there description. Also \lstinline|private static final| or \lstinline|protected static final| fields that are initialised with a literal should use the \nameref{sec:TagValue}.

This looks like this:
\begin{lstlisting}
/**
 *  The vested system property for the file encoding used by the JVM:
 *  {@value}.
 */
public static final String PROPERTY_FILE_ENCODING = "file.encoding";
\end{lstlisting}

The comments for enum values are nothing else than field comments for constants – in fact, an enum value is exactly that: a \lstinline|public static final| field initialised with an instance of the enum type.

\subsubsection{The Method Comment}\label{sec:MethodComment}
The documentation comment for a method describes its usage and its function within the class, together with its arguments, the return value, and any exception it may throw.

For each method parameter there have to be a \nameref{sec:TagParam} tag that describes it in detail (if not already described in the main text of the method comment; in that case, a short sentence should be sufficient). The description has to cover the function of the parameter, its value range, and whether the parameter can be \lstinline|null|. Usually, \lstinline|null| is an invalid parameter value per default, so it has to be mentioned in the respective comment if it is allowed.

It is not enough to only give the type of the parameter in the comment; in fact, this is obsolete as it can be easily taken from the method's signature.

Usually, the return value (given the method is not of type \lstinline|void|) will be described in the comment for the \nameref{sec:TagReturn} tag; the tag is mandatory, and with some text, even if the return value is described already in the method description itself. The description for the return value should provide the possible values and there meanings, whether \lstinline|null| is a valid return value, and so on. 

In particular, the comment for the \nameref{sec:TagReturn} tag has to describe which return values indicate special or error conditions.

It is obsolete to give the type of the return value here; it can already be seen from the method's declaration.

Next there has to be a \nameref{sec:TagThrows} tag for each checked exception that may be thrown by the method, describing the condition that may trigger that exception. It is also possible to add \nameref{sec:TagThrows} clauses for unchecked exceptions, but not required. Refer to chapter \tqfullvref{sec:GeneralExceptionHandling} for additional details on exception handling.

A method that implements an interface method or that overrides a method from a base class be commented with the \nameref{sec:TagInheritDoc} tag instead of writing a full comment. The tag can be combined with additional text, too.

The documentation comment for a non-\lstinline|final| \lstinline|public| or \lstinline|protected| method has to provide detailed information when and how it has to be overwritten; especially if the overriding method has to call the super implementation and when:\footnote{Usually you should avoid the requirement for calling the super implementation, but that is not always appropriate or possible; refer to chapter \tqref{sec:NonFinalMethods} about some more details.}.

A comment for that case may look like this:\footnote{The tag @note is a custom tag; refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc}}
\begin{lstlisting}
/**
 *  …
 *
 *  @note Call this implementation {before|after} your code, to make
 *      sure that the initialisations provided here are performed.
 *
 *  …
 */
\end{lstlisting}

For more details on this refer to chapter \tqfullvref{sec:ExtendingClassesOverridingMethods}.

Usually, the documentation comment for a method does not reveal details about the method's implementation, but in case of empty “place holder methods” or mount points, a sentence like below does not harm.
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 */
\end{lstlisting}

If such a method has a dummy or default return value, there has to be an appropriate \nameref{sec:TagReturn} tag, specifying that value:
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 *  @return Always <the default value>.
 */
\end{lstlisting}
 
Finally it is absolutely crucial that the documentation comment provides all information about possible side effects of a call to the method, even more when these side effects are unexpected.

\subsubsection{The Constructor Comment}\label{sec:ConstructorComment}
Basically, a constructor is a special kind of a method, so the same rules are valid for the documentation comment for a constructor than for the documentation comment for a method, as given in chapter \tqref{sec:MethodComment}.

For an empty default constructor, the constructor comment may be as simple as this, no matter if it is \lstinline|public|, \lstinline|private|, or \lstinline|protected|:
\begin{lstlisting}
/**
 *  Creates a new {@code MyClass} instance object.
 */
public MyClass() { /* Does nothing */ }
\end{lstlisting}
or
\begin{lstlisting}
/**
 *  Default constructor for class {@code MyClass}.
 */
private MyClass() { /* Does nothing */ }
\end{lstlisting}
with the first alternative being the preferred one; in fact, this comment can be used for every constructor, not only for the default ones.

Of course, these comments do not say very much, but the constructor is also not doing that much, and what it does is very obvious. But if it has side effects, these should be described properly.

A class that does have only \lstinline|static| methods\footnote{Such a class is called a “Utility Class”; refer to \tqfullvref{sec:UtilityClasses} for more details.} should have a \lstinline|private| constructor like this:\footnote{The \lstinline|Error| class is described in \autocite{TQUADRAT_ORG_FOUNDATION_PRIVATECONSTRUCTORFORSTATICCLASSCALLEDERROR}.}
\begin{lstlisting}
/**
 *  No instance is allowed for class {@code MyUtilityClass}.
 */
private MyUtilityClass() 
{ 
    throw new PrivateConstructorForStaticClassCalledError( MyUtilityClass.class); 
}   // MyUtilityClass()
\end{lstlisting}

If a constructor takes parameters, there has to be a \nameref{sec:TagParam} tag for each of them, exactly like for a method.

Although constructors should not throw (checked) exceptions, sometimes it could not be avoided without overcomplicating the API of a class. In such case, all exceptions has to be listed with the \nameref{sec:TagThrows} tag and a description of the conditions for the particular exception – as far as it is possible or make sense. Refer also to chapter \tqfullvref{sec:GeneralExceptionHandling} for some more details on exception handling.

\subsection{The JavaDoc Tags}\label{sec:JavaDocTags}
The next two chapters describe the tags that should be used in your documentation comments where appropriate.

One general rule for all JavaDoc tags: Do not insert line breaks between the parameters of a tag:
\begin{lstlisting}
// WRONG!!
/*
 *  …
 *  @param args
 *         The command line arguments
 *  @param  otherArg
 *          This parameter needs a very long explanatory comment that
 *          requires a line break.
 *  @throws IOException
 *          Reading the file failed.
 *  …
 */

// CORRECT:
/*
 *  …
 *  @param  args   The command line arguments
 *  @param  otherArg    This parameter needs a very long explanatory
 *      comment that requires a line break.
 *  @throws IOException Reading the file failed.
 *  …
 */
\end{lstlisting}

\subsubsection{The Standard Doclet Tags}
Most of the contents of this chapter was taken from the document “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG}. 

In the context of the JavaDoc tool, the interpretation of the content of a documentation comment is done by the implementation of the interface \lstinline|jdk.javadoc.doclet.Doclet|\footnote{Refer to \autocite{ORACLE_DOC_DOCLET_INTERFACE}.} interface that is used to process the comment. Other implementation may accept the same syntax as the standard doclet (provided through the class \lstinline|jdk.javadoc.doclet.StandardDoclet|\autocite{ORACLE_DOC_STANDARDDOCLET_CLASS}), or they may support an alternate syntax. However, due to the support by many tools, the syntax supported by the standard doclet has become a \textit{de facto} standard.

\paragraph{\lstinline|@author|}\label{sec:TagAuthor} Usage: \lstinline|@author <name-text>|

The tag adds an “Author” entry with the specified name text to the generated documents when the \verb#-author# option is used. A documentation comment can contain multiple \lstinline|@author| tags. Use the \nameref{sec:TagExtAuthor} tag instead.

\paragraph{\lstinline|@code|}\label{sec:TagCode}  Usage: \lstinline|{@code <text>}|

This is equivalent to \lstinline|<code>{@literal text}</code>|.

It displays text in the code font without interpreting the text as HTML markup or nested JavaDoc tags. This enables you to use regular angle brackets (< and >) instead of the HTML entities (\&lt; and \&gt;) in documentation comments, such as in parameter types (<Object>), inequalities (3 < 4), or arrows (->).

If you want the same functionality without the code font, then use the \nameref{sec:TagLiteral} tag. 

\paragraph{\lstinline|@deprecated|}  Usage: \lstinline|{@deprecated <text>}|

This tag is used in conjunction with the \lstinline|@Deprecated|\autocite{ORACLE_DOC_DEPRECATED_ANNOTATION} annotation to indicate that this API should no longer be used (even though it may continue to work).

The first sentence of the text should tell the user when the API was deprecated and what to use as a replacement. Subsequent sentences can also explain why it was deprecated.

A \nameref{sec:TagLink} tag that points to the replacement API should be added where feasible.

\paragraph{\lstinline|@docRoot|}  Usage: \lstinline|{@docRoot}|

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages.

\paragraph{\lstinline|@exception|} This is a synonym for \nameref{sec:TagThrows}; it should not be used.

\paragraph{\lstinline|@hidden|}  Usage: \lstinline|@hidden|

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all.

\paragraph{\lstinline|@index|}  Usage: \lstinline|{@index <word> <description>}| or \lstinline|{@index "<phrase>" <description>}|

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym.

\paragraph{\lstinline|@inheritDoc|}\label{sec:TagInheritDoc}  Usage: \lstinline|{@inheritDoc}|

Inherits (copies) the documentation comment from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text.

\paragraph{\lstinline|@link|}\label{sec:TagLink}  Usage: \lstinline|{@link <module/package.class#member> <label>}|

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. 

This tag is similar to the \nameref{sec:TagSee} tag. Both tags require the same references and accept the same syntax for \verb|<module/package.class#member>| and the label. The main difference is that the \lstinline|{@link}| tag generates an inline link rather than placing the link in the “See Also” section. The \lstinline|{@link}| tag begins and ends with curly braces to separate it from the rest of the inline text. If you need to use the right curly brace (“\}”) inside the label, then use the HTML entity notation \verb|&#125;|.

\paragraph{\lstinline|@linkplain|}\label{sec:TagLinkplain}  Usage: \lstinline|{@linkplain <module/package.class#member> <label>}|

Behaves the same as the \nameref{sec:TagLink} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text.

\paragraph{\lstinline|@literal|}\label{sec:TagLiteral}  Usage: \lstinline|{@literal <text>}| 

Same as the \nameref{sec:TagCode} tag, but the text is shown as plain text and not in the code font.

\paragraph{\lstinline|@param|}\label{sec:TagParam}  Usage: \lstinline|@param <parameter-name> <description>|

Adds a parameter with the specified parameter name followed by the specified description to the “Parameters” section. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets (“\verb#<…>#”) around such a parameter name to indicate the use of a type parameter.

\paragraph{\lstinline|@provides|}\label{sec:TagProvides}  Usage: \lstinline|@provides <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document an implementation of a service that is provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider itself. 

\paragraph{\lstinline|@return|}\label{sec:TagReturn}  Usage: \lstinline|@return <description>|

Adds a “Returns” section with the description text to the documentation comment of a method.

\paragraph{\lstinline|@see|}\label{sec:TagSee}  Adds a “See Also” heading with a link or text entry that points to a reference. The \lstinline|@see| tag has three variations; see \autocite{ORACLE_DOC_JAVADOC_TAG} for the details.

\paragraph{\lstinline|@serial|}\label{sec:TagSerial} Used in the documentation comment for a default serializable field. See “Documenting Serializable Fields and Data for a Class”\autocite{ORACLE_DOC_OBJECT_SERIALIZATION:DocumentingSerializableFieldsData}. 

\paragraph{\lstinline|@since|}\label{sec:TagSince}  Usage: \lstinline|@since <since-text>|

Adds a “Since” heading with the specified \verb#<since-text># value to the generated documentation. The text has no special internal structure. This tag that this change or feature has existed since the software release specified by the \verb#<since-text># value, for example: \lstinline|@since 1.5|.

Although it would possible to provide a date or something else, it is recommended to always use a version number with the \lstinline|@since| tag.

\paragraph{\lstinline|@summary|}\label{sec:TagSummary}  Usage:  \lstinline|{@summary <text>}|

Identifies  the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content.

The \lstinline|{@summary}| tag has to be used always when a documentation comment has more than one sentence; see also chapter \tqvref{sec:StructureAndContents}.

\paragraph{\lstinline|@throws|}\label{sec:TagThrows}  Usage: \lstinline|@throws <class-name> <description>|

The \lstinline|@throws| tag adds a “Throws” subheading to the generated documentation, with the \verb#<class-name># and the description text. The class name is the name of the exception that might be thrown by the method, and the description provides information about the conditions for that exception to be thrown. 

\paragraph{\lstinline|@uses|}\label{sec:TagUses}  Usage: \lstinline|@uses <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available.

\paragraph{\lstinline|@value|}\label{sec:TagValue}  Usage: \lstinline|{@value}| or \lstinline|{@value <module/package.class#field>}|

This tag is used to display the values of constant in the generated documentation. When the \lstinline|{@value}| tag is used without an argument in the documentation comment of a \lstinline|static final| field, it displays the value of that constant:
\begin{lstlisting}
/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"
\end{lstlisting}

When used with the argument \verb|<module.package.class#field>| in any documentation comment, the \lstinline|{@value}>| tag displays the value of the specified constant:
\begin{lstlisting}
/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public final String evalScript( String script ) { … }
\end{lstlisting}
The argument \verb|<module.package.class#field>| takes a form similar to that of the \nameref{sec:TagLink}, the \nameref{sec:TagLinkplain}, or the \nameref{sec:TagSee} tag argument, except that the member must be a \lstinline|static final| field.

\paragraph{\lstinline|@version|}\label{sec:TagVersion}  Usage: \lstinline|@version <version-text>|

Adds a “Version” subheading with the specified \verb#<version-text># value to the generated documents when the \verb#-version# option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the \nameref{sec:TagSince} tag, which holds the release number where this code was introduced. The \verb#<version-text># value has no special internal structure.

\subsubsection{Custom Tags for JavaDoc}\label{sec:CustomTagsForJavaDoc}
You can define your own JavaDoc tags; simple tags can be defined on the commandline for the JavaDoc tool (see the option \verb#-tag# in \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}) or by implementing the interface \lstinline|jdk.javadoc.doclet.Taglet|\autocite{ORACLE_DOC_TAGLET_INTERFACE}.

I created a set of custom tags that I use regularly, and that I also recommend for your documentation comment. The respective library can be found at \autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC}.

\paragraph{\lstinline|@anchor|}\label{sec:TagAnchor}  Usage: \lstinline|{@anchor #<anchor-name> <text>}|

This tag allows to add an HTML anchor to the generated documentation, where \verb#<anchor-name># is the name of the anchor to the given text. The hash symbol (‘\#’) before the name of the anchor is mandatory!

\paragraph{\lstinline|@extauthor|}\label{sec:TagExtAuthor}  Usage: \lstinline|@extauthor <name-text> - <email-address>|

This is a replacement for the \nameref{sec:TagAuthor} tag that renders the given email address as \verb#mailto:# link in the generated documentation. It does not regard the \verb#-author# option\footnote{This is valid for version 0.1.0 of the library; it may have changed for a later version}. 

\paragraph{\lstinline|@href|}\label{sec:TagHref}  Usage: \lstinline|{@href <url> <text>}| or \lstinline|{@href <url>}|

With this tag, an HTML hyperlink can be added to the generated documentation; if will place inside the description text, but different from the \nameref{sec:TagLink} and \nameref{sec:TagLinkplain} tags, it allows to refer to arbitrary external resources, not only to other documented elements. Obviously, \verb#<url># is the target URL, while \verb#<text># is the clickable text. If the latter is omitted, the URL itself will be used instead.

\paragraph{\lstinline|@inspired|}\label{sec:TagInspired}  Usage: \lstinline|@inspired <text>|

Sometimes a piece of code was inspired by a document of some kind, a description of an algorithm, a product white paper, or whatever. This tag allows you to add a reference to that source of inspiration. 

\paragraph{\lstinline|@modified|}\label{sec:TagModified}  Usage: \lstinline|@modified <name-text> - <email-address>|

This is a variant of the \nameref{sec:TagExtAuthor} tag. It is meant to provide the name of the developer that modified the respective element without claiming to be an author.

\paragraph{\lstinline|@note|}\label{sec:TagNote}  Usage: \lstinline|@note <text>|

With this tag, it is easy to add important notes to the generated documentation for an element. All notes will be added to a bullet list placed immediately beneath the documentation text. The text for the \lstinline|@note| tag is somehow limited as it does not allow other JavaDoc tags.

\paragraph{\lstinline|@thanks|}\label{sec:TagThanks}  Usage: \lstinline|@thanks <name-text> - <email-address>|

Use this tag to mention someone who provided input to the respective element without being an author; that person might have wrote an article about the algorithm that was implemented by this element, or they may have reported a bug.

Same as for the \nameref{sec:TagExtAuthor} and the \nameref{sec:TagModified} tags, the email address will be rendered to a \verb#mailto:# link in the generated documentation.

\paragraph{\lstinline|@UMLGraph.link|}\label{sec:TagUMLGraph}  Usage: \lstinline|@UMLGraph.link|

This adds an UML graph for the current class to the generated documentation.


\section{Implementation Comment Formats}
A source code file can have four styles of implementation comments:
\begin{itemize}[nosep]
\item{structuring comments}
\item{block comments}
\item{single-line comments}
\item{trailing or end-of-line comments}
\end{itemize}

\subsection{Structuring Comments}\label{sec:StructuringComments}
Structuring comments are the most simple comments: they are used to separate the parts of a class (as defined in chapter \tqfullvref{sec:ClassAndInterfaceDeclarations}) from each other. They have the form
\begin{lstlisting}
    /*------------------*\
====** Enum Declaration **===========================================
    \*------------------*/
    /*---------------*\
====** Inner Classes **==============================================
    \*---------------*/
    /*-----------*\
====** Constants **==================================================
    \*-----------*/
    /*------------*\
====** Attributes **=================================================
    \*------------*/
    /*------------------------*\
====** Static Initialisations **=====================================
    \*------------------------*/
    /*--------------*\
====** Constructors **===============================================
    \*--------------*/
    /*---------*\
====** Methods **====================================================
    \*---------*/
\end{lstlisting}

with the lines ending at column 80 (the samples here are too short).

If a class or interface does not have a particular part, the assigned structuring comment must be omitted.

I recommend to create “Building Blocks” with these comments. Eclipse provides the Snippet facility for this purpose\footnote{Storing the comments as code templates is not recommended as a template would be reformatted on insert.}. Refer to chapter \tqfullvref{sec:SnippetStructuringComments} for the snippet code for the structuring comments.

\subsection{Block Comments}\label{sec:BlockComments}
Block comments are used to provide detailed descriptions of files, methods, data structures and algorithms – meaning that the text of the comment is longer than just one line. Block comments may be used at the beginning of each block after the opening brace. They can also be used in other places, such as within methods. Block comments inside a function or method should be indented to the same level as the code they describe. 

A block comment should be preceded by a blank line to set it apart from the rest of the code. If the block comment does not directly refer to the code line immediately after it, it should be followed by another blank line.

Next, the first line of the comment block has to remain empty, and the closing of the comment block has to be placed on a line of its own.

Some samples:
\begin{lstlisting}
{
    /*
     * Here is a sample of a block comment. Block comments are used
     * to provide detailed information about code internals.
     */
    Result value = retrieveResult( parameter );
    …

    /*
     * Here is another sample of block comment, somewhere in the
     * middle of a code block. Please note the blank line above!
     */
    …
}

// AVOID!
/*
 * This block comment is outside the code block it refers to. Block 
 * comments should be placed after the opening curly brace of the
 * block.
 */
{
    Result value = retrieveResult( parameter );
    …
 
/* The first line of the block comment should be left empty and the
 * comment should be indented in the same way as the code in the
 * block.
 */
    processResult( value, parameter );
    /* 
     * Here the empty line above the comment is missing …
     * … and the closing tag should be on a line of its own. */
\end{lstlisting}
 
\subsection{Single-Line Comments}\label{sec:SingleLineComments}
Short comments can appear on a single line; they will be indented also to the level of the code that follows. Usually it should be written in the form of a headline:
\begin{lstlisting}
//---* Handle the condition *----------------------------------------
\end{lstlisting}
with the dashes ending on column 80.\footnote{A quick reminder: the sample code in this document uses a line length of 70, so the dashes in the comment line above ends an column 70.}

If a comment cannot be written in a single line, it should have the block comment format (see chapter \tqref{sec:BlockComments}). A single-line comment should be separated from the preceding code by a blank line. Only when the preceding line contains only the opening curly brace as in the \lstinline|if-then-else| sample below (lines~3 and 8). 

Here are some examples of single-line comments in Java code:
\begin{lstlisting}[numbers=left]
if( cache.contains( key ) )
{
    //---* Take the data from the cache *----------------------------
    …
}
else
{
    //---* Load the data from its original source *------------------
    …
}
…
ResultData resultData = executeService();

//---* Format the output for the UI *--------------------------------
formatResult( resultData );
…
\end{lstlisting}

Another form of the single line comment is the empty block comment:
\begin{lstlisting}
public interface Marker
{ /* No methods */ }

public class Extension extends Base
{ /* No implementation */ }

private Constructor() { /* Does nothing */ }

public void adapterMethod() { /* Does nothing */ }

public final void method()
{
    …

    try
    {
        …
    }
    catch( final MyException e ) { /* Exception deliberately swallowed /* }

    …
}   // method()
\end{lstlisting}

And finally, there are the “class termination comments” that repeats the name of the class after the last curly brace:
\begin{lstlisting}
public final class MyClass
{
    …
}
//  class MyClass

public final interface MyInterface
{
    public record InnerRecord( final int number )
    {
        …
    }
    //  record InnerRecord
    
    …
}
//  interface MyInterface

\end{lstlisting}

\subsection{Trailing or End-Of-Line Comments}\label{sec:TrailingOrEndOfLineComments}
Very short comments can appear on the same line as the code they describe, but should be shifted right far enough to separate them from the statements. If more than one short comment appears in a chunk of code, they should all be indented to the same tab setting.

Here's an example of a trailing comment in Java code:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            /* special case */
}
else
{
    return isPrime( a );    /* works only for odd a */
}
\end{lstlisting}

But it is more common to use “\verb#//#” instead of “\verb#/*…*/#” for these trailing comments:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            // special case
}
else
{
    return isPrime( a );    // works only for odd a
}
\end{lstlisting}

You will use trailing comments to provide the documentation for local variables\footnote{Usually, the name of that local variable should be sufficient (refer to chapter \tqvref{sec:Fields}), or the meaning of that variable is obvious from the context, but sometimes it still make sense to provide that kind of additional information.}:
\begin{lstlisting}[numbers=left,caption={Gauss's Easter algorithm\autocite{WIKIPEDIA:DateOfEaster,WIKIPEDIA:Gaussche_Osterformel}}]
/**
 *  <p>{@summary This method calculates the date of Easter Sunday 
 *  for the given year.} The year has to be in the range from 1583 
 *  to 3900 (included).</p>
 *  <p>The resulting date is for the Gregorian calendar.</p>
 *  <p>The algorithm itself is not the original one published by Carl
 *  Friedrich Gauß first in 1800 (corrected version in 1816), but
 *  that one published by Heiner Lichtenberg in 1997.
 *
 *  @thanks Carl Friedrich Gauß
 *  @thanks Heiner Lichtenberg  
 *
 *  @param  year    The year for which the date of Easter Sunday is 
 *      wanted for.
 *  @return The date of Easter Sunday in the given year.
 *  
 *  @see <a href="https://de.wikipedia.org/wiki/Gau%C3%9Fsche_Osterformel">Gaußsche Osterformel</a>
 */
public static final LocalDate calcEasterDate( final Year year )
{
    /*
     * The explanation for the variables was taken from the German
     * Wikipedia article and translated by me. The original terms
     * are given in parenthesis.
     */
    final int x;  // The year
    final int k;  // The secular number (die Säkularzahl)   
    final int m;  // The secular moon shift (die säkulare Mondschaltung)
    final int s;  // The secular moon shift (die säkulare Sonnenschaltung)
    final int a;  // The moon parameter (der Mondparameter)
    final int d;  // The seed for the first full moon in spring (der Keim 
        // für den ersten Vollmond im Frühling)
    final int r:  // The calendar adjustment (die kalendarische
        // Korrekturgröße)
    final int og; // The Easter limit (die Ostergrenze)
    final int sz; // The first Sunday in March (der erste Sonntag im März)
    final int oe; // The distance of Easter Sunday from the Easter limit
        // – Easter distance in days (die Entfernung des Ostersonntags
        // von der Ostergrenze – Osterentfernung in Tagen)
    final int os; // The date of Easter Sunday as a March date with 
        // March 32 as April 1 etc. (das Datum des Ostersonntags als 
        // Märzdatum – 32. März = 1. April usw.)
    
    //---* Check the arguments *-------------------------------------    
    if( requireNonNullArgument( year, "year" ).isBefore( Year.of( 1583 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years greater than or equal to 1583" );
    }
    if( year.isAfter( Year.of( 3900 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years less than or equal to 3900" );
    }

    //---* Lichtenberg's Easter formula *----------------------------
    x = year.getValue();
    k = x / 100;    
    m = 15 + (3 * k + 3) / 4 - (8 * k + 13) / 25;
    s = 2 - (3 * k + 3) % 4;
    a = x % 19;
    d = (19 * a + m) % 30;
    r = (d + a / 11) / 29;
    og = 21 + d - r;
    sz = 7 - (x + x / 4 + s) % 7;
    oe = 7 - (og - sz) % 7;
    os = og + oe;

    /*
     * Initialise the return value with the last day of February and 
     * add the calculated number of days.
     */
    final var retValue = LocalDate.of( y, MARCH, 1 )
        .minusDays( 1 )
        .plusDays( os );

    //---* Done *----------------------------------------------------
    return retValue;
}   //  calcEasterDate()
\end{lstlisting}

As you can see, for this use case it is acceptable to continue a long comment in the following line (see lines~31 and 32, for example) without using a block comment.

Another use case for these kind of comments is to provide information about the arguments of a method call; usually, you should avoid method signatures where this is required (the formal parameter of the method should be sufficient to explain the argument), but sometimes it makes still sense:
\begin{lstlisting}
…
drawCircle(
    x, y, // The center of the circle
    d/2.0 // The radius of the circle, calculated from the diameter
);
…
\end{lstlisting}

The end comment for a method is also of this type:
\begin{lstlisting}
public final void method()
{
    …
} //  method()
\end{lstlisting}

Also a long code block\footnote{But if it seems really necessary to add such a comment to a linear code block, you should consider to re-organise your code.} can be commented like this:
\begin{lstlisting}
{
    //---* Calculate the result *------------------------------------
    // Lots of code comes here ...
    …
} //  End of result calculation
\end{lstlisting}

The end comments for the bodies of \lstinline|for|, \lstinline|while|, \lstinline|switch| and even \lstinline|if-then-else| blocks are a special case, as those blocks should be introduced by a label, and this label should be repeated as the end comment:
\begin{lstlisting}
ScanLoop: for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  ScanLoop:

ForeverLoop: while( true )
{
    // Lots of code comes here ...
    …
}   //  ForeverLoop:

TypeSwitch: switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  TypeSwitch:

SpecialCaseTurnout: if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  SpecialCaseTurnout:
else
{
    // Not so much code here
    …
}    
\end{lstlisting}
Note the colon at the end of each of the comments!

Do not use the introducing code line for the end comment! That code line may change at some point in time and then the end comment does not have a corresponding starting line anymore.\footnote{This also means that you should be careful with removing or changing labels in the code.}

Avoid this:
\begin{lstlisting}
// AVOID!!!
for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  for( final var s : lines )

while( true )
{
    // Lots of code comes here ...
    …
}   //  while( true )

switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  switch( type )

if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  if( isSpecialCase() )
else
{
    // Not so much code here
    …
}    
\end{lstlisting}

\section{Maintenance Comments}\label{sec:MaintenanceComments}
It is very likely that source code will be changed more than once during its lifetime. Bugs will be fixed, functionality is added or removed, refactorings will be applied, or the code will be migrated to other platforms or different versions of the programming language, the underlying libraries, the connected systems and/or the operating system.

There is a practice that all the changes made in the code will be commented in the code. These comments are usually referred to as “Maintenance Comments”.

This may look like this:
\begin{lstlisting}
…
//<<BEGIN FSP-4711 – applied by Micky Mouse
//<Old Code>
//…
//>><<
<New Code>
…
//>>END FSP-4711
\end{lstlisting}

It has proved that this is not a good practice at all, and a really bad practice if dealing with code that is managed by an SCCS.

First, this practice causes problems for the compare tools coming with the SCCS – at least it will make it more difficult to read the comparison results from those tools.\footnote{Most comparison tools will recognise the out-commenting of the old code as a change and the new code as additional code instead of the replacement for the old code. This is at least confusing when a code revisions are made on the fix.} And the main function of those comments – documenting the changes – is much better served by the SCCS tools themselves.

Second, this gets even worse when the fix needs a fix. Just think about overlapping changes, like FSP-4712 changes lines from the new code of FSP-4711, together with lines directly below, or changes that has to be partially reverted, and so on.

And finally, the comments does not help to identify if your are currently running the patched code, or the old one.

On the other hand, nothing can be said against adding a line to the file or class comment that lists the patches that were applied to the code.

Therefore I recommend to introduce an annotation that can be used to mark elements that are affected by a fix.

Such an annotation can provide the BUG number of the fix, together with a short description of the issue. This annotation replaces a comment about the applied patches, with the advantage that it can be retrieved also from the compiled classes, even at runtime.

Chapter \tqfullvref{sec:PatchIdentification} provides an example of such an annotation.

Old code will be removed and not commented out, or just replaced by the new code. One or the other short comment with a hint is not mandatory, but does not harm either.

When using the suggested annotation from chapter \tqref{sec:PatchIdentification}, this could look like this:
\begin{lstlisting}
…
@BUG( id = "BUG-4711", comment = "No end criterion for loop" )
@BUG( id = "BUG-4712", comment = "Exception was swallowed" )
public final void myMethod()
{
    ForeverLoop: while( true )
    {
        try
        {
            …
            
            if( !hasMore() ) break ForeverLoop; // BUG-4711
        }
        catch( final IllegalStateException e )
        {
            log( e );
            break ForeverLoop; // BUG-4712: Added exception handling
        }
    }   //  ForeverLoop:
}   //  myMethod()
…
\end{lstlisting}

\section{Special Comments}
The “Code Conventions for the Java\textsuperscript{TM} Programming Language”\autocite{SUN_CODE_CONVENTIONS:SpecialComments} suggests some special comments: \verb#XXX# in a comment flags something that is bogus but works. \verb#FIXME# flags something that is bogus and broken (and has to be fixed very soon).

Eclipse knows a setting that allows to externalise such comments into a task list: \verb#Window|Preferences|General|Editors|Structured Text Editors|Task Tags#.

It also adds \verb#TODO# to that list, for something that still needs to be implemented.

\section{Commenting out Code}
Use the “//” delimiter to comment out a complete line, only a partial line, or a whole bunch of consecutive lines of code.

Example:
\begin{lstlisting}
if( foo > 1 )
{
    //---* Do a double-flip *----------------------------------------
    …
}
else
{
    return false;          // Explain why here.
}
//if( bar > 1 )
//{
//    //---* Do a triple-flip *--------------------------------------
//    …
//}
//else
//{
//    return false;
//}
\end{lstlisting}

To use a block comment (“\verb#/*…*/#”) for commenting out sections of code is not a good idea, although you do not have to type that much: you cannot have a block comment inside a block comment.

The easiest way to comment out a selected code block this way in Eclipse is to use \verb#Source|Toggle Comment# from the menu or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “7” instead of “/”.}.

In IntelliJ IDEA, it is the menu command \verb#Code|Comment with Line Comment# or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “÷” on the numeric keypad instead of “/”.}.

\section{Comments when?}\label{sec:CommentsWhen}
To repeat what was already said at the beginning of the chapter \tqfullref{sec:WritingProperComments}: The frequency of comments reflects poor quality of code, but code can be “under-commented” or “over-commented”. This means that there is a “frequency band” for comments that has to be hit for good quality code.

The advice “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” raises the question for whom the code has to made clearer, because the experts and the rookies are completely distinct audiences, with different needs in regard of comments in the source code.

Same with that other advice (“Even if you don't think, a comment might be necessary, add it nevertheless”): it is the other extrema, and equally bad.

That leads us (again) to the conclusion, that writing good comments to source code is a complex art.

This means that this document cannot give you a complete rule set here, just some guidance.

That documentation comments are required everywhere possible, and how to write them was already covered in chapter \tqfullvref{sec:DocumentationComments}, thus we focus here on the implementation comments.

\begin{itemize}
\item{No empty blocks are allowed (means that “\{\}” may not occur in the code). If there is really no code in a block, there have to be least a comment, just to show that this is deliberate. For \lstinline|catch| blocks, there should be a good (at least some) explanation, why it is empty (see also chapter \tqfullref{sec:GeneralExceptionHandling}).

Some samples:
\begin{lstlisting}
//---* Skip input stream until then end *----------------------------
while( input.read() != EOF ) { /* empty */ }
// Better
while( input.read() != EOF );

//---* Spent CPU cycles on counting *--------------------------------
for( var i = 0; i < maxValue; ++i ) { /* empty */ }
// Better
for( var i = 0; i < maxValue; ++i );


InputStream input = null; // null if cannot open file
try
{
    input = new FileInputStream( "myFile" );
}
catch( final FileNotFoundException ignored ) { /* Deliberately ignored */ }
// Better
InputStream input; // null if cannot open file
try
{
    input = new FileInputStream( "myFile" );
}
catch( final FileNotFoundException ignored ) 
{ 
    input = null;
}

@MountPoint
public Data customAction( final Data data ) { /* Does nothing */ }

public MyClass() { /* Just exists */ }

public interface MyInterface { /* No methods */ }
\end{lstlisting}}
\item{A short description of the algorithm that was implemented by the current code is always helpful; even just mentioning its name can make a difference when hunting a bug. But in case the implementation changes, such a comment needs to be adjusted as well.}
\item{Whenever you hurt or ignore one of the rules, guidelines, or recommendations from this document, it is worth a comment:
\begin{lstlisting}
value = 7.0 / a; // a != 0.0 was already checked above

o.execute(); // o != null was checked in foo.bar( o )

/*
 * bar.getQ() will never return null, so an explicit check on
 * null for q was omitted
 */
q = bar.getQ();
q.execute();}
\end{lstlisting}
In all these samples, arguments or values are not checked for \lstinline|null| or zero, \textit{because this was already done elsewhere} – and not necessarily just one line above the current location. The comment tells a maintenance engineer that the check was made – at least in the initial version of the code – and that the root cause for the problem might be elsewhere (perhaps because someone eliminated that other location or at least the value check there).}
\item{A comment is mandatory each time an exception is swallowed, no matter if silently or not, meaning the exception is logged somewhere. If the program is continued after an exception was caught, write a comment (see also chapter \tqfullref{sec:GeneralExceptionHandling}).}
\item{As said already in chapter \tqfullvref{sec:SwitchStatements}, a comment is required on a case fall-through.}
\item{Non-obvious class casts should be explained with a comment, in order to document that the programmer knew what they did:
\begin{lstlisting}
private final void valueProcessor( List<Object> values )
{
    …
    Value value;
    for( Object o : values )
    {
        /*
         * We know that values can only contain Value objects;
         * otherwise this method would not have been called to
         * process the list.
         */
        value = (Value) o;
        …
}
\end{lstlisting}
This makes sense here because a check like
\begin{lstlisting}
if( o instanceof Value ) value = (Value) o;
\end{lstlisting}
is relatively expensive – especially if the contract for this \lstinline|private| method is that it is called only with lists containing \lstinline|Value| objects so that the check would not be positive only in very, very, very rare cases. And finally: what else can be done in cases where the object is not of the right type than throwing a ClassCastException? That's the same that is done by the code above in such a case, too.

First, the version
\begin{lstlisting}
if( o instanceof Value value )
{
    …
}
\end{lstlisting}
might be clearer, but it is not less expensive.

Second, having a list of \lstinline|Value| objects declared as \lstinline|List<Object>| is bad design – or legacy code.}
\item{In some sources you will find the recommendation to add a comment at the end of a long compound statement; this was already discussed in chapter \tqfullref{sec:SingleLineComments}.}
\item{With the \lstinline|@SuppressWarnings| annotation\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION}, you can switch off a compiler warning or error caused by code that is somehow “hurting the rules”. Basically, the \lstinline|@SuppressWarnings| annotation is a replacement for a comment about that deviation from the rules, an additional comment is required only in cases it is not obvious why that annotation was applied. More details on this are provided in \tqfullvref{sec:CompilerWarningsAndErrors}.}
\item{tbc}
\end{itemize}

\section{Updating Comments}
If the code has to be modified, no matter if due to regular maintenance, bug fixing or a migration, all related comments has to be updated accordingly. There is no value in keeping “historical comments”, although mentioning the old algorithm when the former implementation has been replaced completely might be useful in some cases.

But keeping the outdated code as a comment is definitely not useful, in particular not when there is an SCCS used to manage the code.