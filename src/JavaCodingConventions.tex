%\RequirePackage{lmodern}
\documentclass[11pt,a4paper,titlepage, parskip=half, headsepline, footsepline, cleardoubleplain]{scrbook}
%\usepackage{DejaVuSansMono}
\usepackage{dejavu}
%\usepackage[T1]{fontenc}
\usepackage{scrhack}
\usepackage{graphicx} 
\usepackage[manualmark]{scrlayer-scrpage}
%\usepackage[utf8]{inputenc}
\usepackage{tocbasic}
%\usepackage{amsmath}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{eurosym}
\usepackage{ragged2e}
\usepackage{textcomp}
\usepackage{framed}
\usepackage{ltxtable}
\usepackage{filecontents}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,gray]{xcolor}
\usepackage{listings}
\usepackage[inline]{enumitem}
\usepackage{varioref}
\usepackage[iso,english]{isodate}
\usepackage{makecell}
\usepackage[english]{babel}
\usepackage[babel]{csquotes}

\usepackage{lipsum}

\usepackage[style=numeric,urldate=iso8601,backend=biber]{biblatex}
\usepackage{nameref}
\usepackage[colorlinks=true]{hyperref}

\addbibresource{JavaCodingConventions.bib}

\automark[section]{chapter}
\lehead*[]{\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}~~\headmark}
\rohead*[\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}]{\headmark~~\raisebox{-\dp\strutbox}{\includegraphics[height=1cm]{Logo_klein}}}

\lstset{
language=Java,
%morekeywords={exports,module,opens,provides,requires,to,transitive,uses,var,with,yield},
morekeywords={var,yield},
backgroundcolor=\color[gray]{.9},
frame=single,
framerule=0.2pt,
basicstyle=\ttfamily\footnotesize,
commentstyle=\color[gray]{.2}\itshape,
keywordstyle=\color[gray]{.4}\bfseries,
identifierstyle=\bfseries,
stringstyle=\itshape,
xleftmargin=.2cm,
xrightmargin=.2cm,
breaklines=true,
breakatwhitespace=true,
inputencoding=utf8,
extendedchars=true,
literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
  {©}{{\copyright}}1
  {…}{{\dots }}2
  {–}{{--}}1
}

\colorlet{shadecolor}{gray!10}
\makeindex

%---* New Commands *-----------------------------------------------------------
\newcommand*{\tqfullref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”}}
\newcommand*{\tqfullvref}[1]{\hyperref[{#1}]{“\ref*{#1} \nameref*{#1}”} on page \pageref{#1}}
\newcommand*{\tqref}[1]{\hyperref[{#1}]{\ref*{#1}}}
\newcommand*{\tqvref}[1]{\hyperref[{#1}]{\ref*{#1}} on page \pageref{#1}}

\begin{document}
\isodate
\titlehead{\includegraphics[height=4cm]{Logo_gross}}
\author{Thomas Thrien\\(thomas.thrien@tquadrat.org)}
\title{Extended Coding Conventions for Java}
\subtitle{Coding and Formatting Rules, Recommendations and Best Practices}
\date{\today}
\maketitle
\tableofcontents

\include{Introduction}
\include{FormattingTheSourceCode}
\include{NamingConventions}

\chapter{Writing proper Comments}\label{sec:WritingProperComments}
Comments are crucial for the understanding of source code, in any programming language. Source code without any comments is not maintainable, meaning it is worthless in the long run.

In addition, Java also provides a tool that allows to externalize program comments, so that they can be used as the external documentation; the name of this tool is \textit{JavaDoc}. The “Javadoc Guide”\autocite{ORACLE_DOC_JAVADOC_GUIDE} provides an overview of the tool\footnote{see \autocite{ORACLE_DOC_JAVADOC_MAN} on how to invoke the tool on your source code}, the “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG} explains how to write the comments for a proper documentation generated with the JavaDoc tool.\footnote{JavaDoc is not the only tool for this purpose; another well known tool is Doxygen\autocite{DOXYGEN_HOMEPAGE} that was created primarily to generate the documentation for annotated C++ code, but it works also for Java, C and several other programming languages. But for Java sources, JavaDoc is the preferred tool.}

So Java source code can generally have three kinds of comments:
\begin{itemize}[nosep]
\item{documentation comments}
\item{implementation comments}
\item{maintenance comments}
\end{itemize}
In Java, the \textit{documentation comments} (also known as “doc comments” or “the JavaDoc”) are delimited by “/**…*/” and cannot be placed everywhere; they will be externalised for the generation of the program/library documentation. Obviously, \textit{implementation comment}s are the other comments, that are not externalized and published.

\textit{Maintenance comments} are technically a special form of implementation comments, but as the have a special function, they are covered separately (see chapter \tqfullvref{sec:MaintenanceComments}).

Roughly, the documentation comments describe how to use the code (the API), unrelated to the implementation, while the implementation comments describe what the code is doing and why.

Comments should be used to give overviews of code and provide additional information that is not readily available in the code itself. Comments should contain only information that is relevant to reading and understanding the program. For example, information about how the corresponding package is built or in what directory it resides should not be included as a comment to a class.

Discussion of non-trivial or non-obvious design decisions is appropriate, but avoid duplicating information that is present in (and clear from) the code. It is too easy for redundant comments to get out of date. In general, avoid any comments that are likely to get out of date as the code evolves.

The frequency of comments reflects poor quality of code. Unfortunately, code can be “under-commented” or “over-commented”, meaning there is a “frequency band” for comments that has to be hit for good quality code.

One often heard advice is: “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” But clearer to whom?

With increasing programming experience, things get more and more obvious to the programmers, so they write lesser comments – with the result, that newbies do not have any help to understand the code written by the experts.

Obviously, the advice: “Even if you don't think, a comment might be necessary, add it nevertheless” is the other extrema and equally bad, so writing proper comments remains a complex art, but it follows some rules, and for the rest, we will give some advice. Refer to chapter \tqfullvref{sec:CommentsWhen} where this is discussed further.

In general:
\begin{itemize}
\item{Comments should not be enclosed in large boxes drawn with asterisks or other characters, with the exception of structuring comments as described below.}
\item{Comments should never include special characters such as tabulator, form-feed and backspace or alike. In JavaDoc comments only (see below), most other non-ASCII characters should be escaped with their HTML equivalent.}
\item{While code lines can have any length, comment lines will always end in or before column 80, except when their contents cannot be wrapped (like URLs for references to additional information).}
\item{Comments should be in full sentence and using a clear language.}
\item{Finally: all comments has to be in English language; they should be grammatically correct and without typos.\footnote{… but it is still much more important that there is at least \textit{some} comment than a correctly spelled one.}}
\end{itemize}

\section{Documentation Comments}\label{sec:DocumentationComments}
It is a well known fact that most programmers are poor technical writers. That's the reason why programmers rarely write the public documentation for their product.

But that is no excuse why programmers do not write proper documentation comments into their source code. They are the only people that could write that comments because technical writers usually do not have the time to analyse the code to extract the information from it that is necessary for the documentation.\footnote{In addition, the technical writers usually do not have (write) access to the source code, and me personally, I believe that most technical writers are not good enough programmers to be able to do that code analysis, at least not in a timely manner.}

In general there are (at least) two different target groups for the documentation that is generated from the documentation comments. The first group are the maintenance programmers, the second are programmers writing code interfacing with this one, using the public APIs. This means that each program element that can have a documentation comment must have a documentation comment! No exception! No excuse for missing documentation comments! The programmer must provide a documentation comment wherever it is possible. 

Eclipse can be configured in a way that it will issue warnings or even errors for missing documentation comments: see \verb#Window|Preferences|Java|Compiler|Javadoc#.

To achieve the same for IntelliJ IDEA, you go to \verb#File|Settings#, and there you select \verb#Editor|Inspections>Java>Javadoc#.

Documentation comments describe Java modules, packages, classes\footnote{All types of \textit{classes}, including \textit{interfaces}, \textit{enums}, \textit{records} and \textit{annotations}}, constructors, methods, and fields\footnote{All types of fields: \textit{attributes}, \textit{constants}, but also the \textit{enum values}}. Each documentation comment is set inside the comment delimiters “/**…*/”, with one comment per module, package\footnote{The documentation comment for a Java package is special; refer to chapter \tqfullvref{sec:PackageDocumentation} for the details}, class, or member. This comment has to appear just before the declaration:

\begin{lstlisting}
/**
 *  The Example class provides …
 */
public class Example
{
    /**
     *  The inner class provides …
     */
    private static class InnerClass
    {
        …
    }
    //  class InnerClass
     
    …
    
    /**
     *  This flag …
     */
    private boolean m_Flag;
    …

    /**
     *  Method that performs some action …
     *
     *  @param  arg   The argument.
     */
    public final void method( int arg )
    {
        …
    }   //  main()
}   //  class Example
\end{lstlisting}

The first line of the documentation comments (“/**”) for top level classes is not indented; subsequent lines for the documentation comment have one space of indentation (to vertically align the asterisks). All members, including inner classes, have 4 spaces for the first documentation comment line and 5 spaces thereafter (this is congruent for inner classes).

If you need to give information about a class, interface, variable, or method that isn't appropriate for the public documentation, use an implementation comment immediately after the declaration. For example, internal details about the implementation of a class should go in such an implementation block comment following the class statement, not in the class documentation comment.

Documentation comments should not be positioned inside a method or constructor definition block, because Java associates documentation comments with the first declaration after the comment.

\subsection{Structure and Contents}\label{sec:StructureAndContents}
Latest since the introduction of Java~9, the JavaDoc tool produces (more or less) correct HTML~5 documents from the JavaDoc comments in the source code. Therefore it is strongly recommended to use correct HTML~5 syntax inside the documentation comments itself. This means that tags has to be closed properly, empty tags like \lstinline|<br>| and \lstinline|<img>| are not closed, and so on.

If the comment has more than one single paragraph, use the \lstinline|<p>| tag; do not use the \lstinline|<br>| tag:

\begin{lstlisting}
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The first sentence of each JavaDoc comment is taken to be placed on an overview. Per default, that sentence is defined as everything from the beginning until the first full stop followed by a blank (“. ”) or other whitespace, or the first not-inline HTML tag.

This means that a comment like this

\begin{lstlisting}
// AVOID!!
/**
 *  <b>Returns the status for this operation.</b>
 *
 *  …
 */
\end{lstlisting}

may cause some strange output\footnote{Writing the comment like that (with the \lstinline|<b>…</b>| tag) should be avoided anyway.}. Java~10 introduced the JavaDoc tag \nameref{sec:TagSummary} to address issues like this; it allows the programmer to explicitly specify what portion of the JavaDoc comment appears in the overview rather than relying on JavaDoc's default behaviour to determine the summary portion of the comment. Refer to \autocite{ORACLE_DOC_JAVADOC_TAG,DZONE_JAVADOC_SUMMARY} for the details and additional samples.

The \nameref{sec:TagSummary} tag has to be used always when a documentation comment has more than one sentence:

\begin{lstlisting}
// OK – as single sentence
/**
 *  Returns the status for this operation.
 *
 *  …
 */
 
// AVOID!! – Two sentences. 
/**
 *  <p>Returns the status for this operation. The return value will 
 *  never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>Returns the status for this operation.</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

// RECOMMENDED
/**
 *  <p>{@summary Returns the status for this operation.} The return 
 *  value will never be {@code null}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */

/**
 *  <p>{@summary Returns the status for this operation.}</p>
 *  <p>Possible return values are …</p>
 *
 *  …
 */
\end{lstlisting}

The documentation comments for modules, packages and classes may get longer, so that you want to structure it by giving headlines to sections. Usually this is done through the HTML tag \lstinline|<h#>|, with \# being a number in the range from 1 to 6. You can use these tags in the documentation comments, too, but the tags \lstinline|<h1>| and \lstinline|<h2>| are already used by JavaDoc itself; that means that you should only use \lstinline|<h3>| to \lstinline|<h6>| in the documentation comments.\footnote{In the overview comment (refer to chapter \ref{sec:OverviewComment}), you can make use of the all the \lstinline|<h#>| tags to structure that comment.}

When a class, method, constant, field is mentioned the first time in a documentation comment, its documentation should be linked, using the \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tags. This is not necessary if the type is used for a formal parameter or the return value. In these cases, JavaDoc generates these links automatically.

Each \nameref{sec:TagLink} or \nameref{sec:TagLinkplain} tag has to placed into a line of its own.

Some examples:
\begin{lstlisting}
/**
 *  <p>{@summary Searches the given key in the list and returns the
 *  associated data.} If the key is
 *  {@linkplain String#isBlank() blank},
 *  the method will throw a
 *  {@link BlankArgumentException},
 *  while an empty will just not return a result.</p>
 *
 *  @param  key The key.
 *  @returns An instance of
 *      {@link Optional}
 *      that holds the search result.
 *  @throws IllegalArgumentException    The key is somehow invalid.
 *
public final Optional<Data> searchData( final String key ) { … }
\end{lstlisting}

JavaDoc creates links to the documentation of \lstinline|java.lang.IllegalArgumentException|, \lstinline|java.lang.String| and \lstinline|Data| automatically; it also creates a link to \lstinline|java.util.Optional| but it is recommeded to use the pattern shown here, even when this means that the comment holds two links to the \lstinline|Optional| class documentation.

The names of classes, methods, constant, fields, parameters etc. as well as \lstinline|null|, \lstinline|true|, and \lstinline|false| have to be written in a monotype font. This can be achieved by encapsulating them in \lstinline|<code>…</code>| HTML tags or placing them inside the JavaDoc \nameref{sec:TagCode} tag. The monotype font is used automatically for everything inside a \nameref{sec:TagLink} tag.

Each comment, including each text for a \nameref{sec:TagParam}, \nameref{sec:TagReturn}, and \nameref{sec:TagThrows} tag, ends with a full stop.

The document “How to Write Doc Comments for the Javadoc Tool”\autocite{ORACLE_DOC_JAVADOC_HOWTO} is already a little bit older and therefore outdated in parts, but it still provides some useful hints on how to write proper documentation comments that should be processed by the JavaDoc tool.

\subsubsection{The Overview Comment}\label{sec:OverviewComment}
When the JavaDoc tool is called with the option \verb#-overview <filename># (see \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}), an ‘Overview’ comment is  added to the generated documentation. \verb#<filename># is the (fully-qualified)  filename of a valid HTML~5 document (The recommended name is \verb#overview.html#) containing general information about the project.

You can put nearly everything here, from the project's history to manual on how to use the program or library, but you should not reproduce information that is given in the module, package, or class documentation comments.

Several JavaDoc tags can be also used in the overview comment; for details refer to the chapter "Where Tags Can Be Used" in \autocite{ORACLE_DOC_JAVADOC_TAG}.

\subsubsection{The module Comment}\label{sec:ModuleComment}
The \verb#<module description># (refer to chapter \tqfullref{sec:ModuleDefinition}) describes the current module, its dependencies and what it provides. See the JavaDoc tags \nameref{sec:TagProvides} and \nameref{sec:TagUses} for details.

If the project has just one module, the module comment can replace the overview comment.

\subsubsection{The package Comment}\label{sec:PackageComment}
Each and every Java package has to have a file named \verb#package-info.java#; the structure of that file was already discussed in chapter \tqfullvref{sec:PackageDocumentation}.

The \verb#<package description># provides information about the package. So it describes the purpose of the classes in this package. It lists conventions that are common for all contained classes, it should specify their prerequisites.

If the package defines a single API, it can describe the usage of that API, too. 

The package comment can list the authors of the code, using the \nameref{sec:TagAuthor} tag\footnote{Or the tag \nameref{sec:TagExtAuthor}, refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc})}, the version with the \nameref{sec:TagVersion} tag, when the package was created or with which version it was integrated with the \nameref{sec:TagSince} tag, and other things.

It should not repeat details that are written already in the documentation of a class in that package, instead it should reference that class documentation. If those details are  important for the whole package, it should be considered to move them from the class comment to the package description and place a reference into the class documentation instead.

The package comment for the main package of a project can replace the overview comment (if not the module comment is used for this\footnote{Not all projects will produce modules, so it is possible that your project does not have a module definition file at all.}).

\subsubsection{The class Comment}\label{sec:ClassComment}
The documentation comment for a class, an interface, an enum, a record or an annotation (the ‘class comment’) describes that class, its purpose and its usage. If the class is not \lstinline|final|, the comment should provide some hints what the mount points\footnote{Another term for “mount point” is “extension point”, but I do not like this expression as we do not always “extend” a class on these points. Most often we replace existing behaviour to customise the class to our needs.} are and how to utilise them.

Then the class comment should list the authors of the class, using the \nameref{sec:TagAuthor} tag, the class version (using the \nameref{sec:TagVersion} tag), and when the class was added to the project with the \nameref{sec:TagSince} tag\footnote{Although this can be omitted if this information is already given within the package.}.

In case of a parametrised type (a ‘generic’), it contains a \nameref{sec:TagParam} tag for each formal parameter.

Here a real life sample for an interface:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object). It is based on sample code from the book &quot;Java
 *  Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @author Thomas Thrien - thomas.thrien@pega.com
 *  @version <version information>
 *  @since 1.2.3
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}

The \verb#<version information># should be a reference to the version in the SCCS; if you are using Subversion, that line would look like this:
\begin{lstlisting}
/**
 …
 *  @version $Id:$
 …
 */
\end{lstlisting}

I also recommend to use the custom tags provided by the “Foundation JavaDoc” project\autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC} (see chapter \tqfullvref{sec:CustomTagsForJavaDoc}); then the same class documentation comment would look this:
\begin{lstlisting}
/**
 *  This is the basic interface for any kind of DAO (Data Access
 *  Object).
 * 
 *  @inspired &quot;Java Persistence with Hibernate&quot;.
 *
 *  @param  <T> The entity type for the DAO.
 *  @param  <I> The type of the entity id.
 *
 *  @extauthor Thomas Thrien - thomas.thrien@pega.com
 *  @version $Id:$
 *  @since 1.2.3
 *
 *  @UMLGraph.link
 */
public interface GenericDAO<T,I>
{
    …
}   //  interface GenericDAO
\end{lstlisting}
The tag \nameref{sec:TagExtAuthor} is an enhanced replacement for the \nameref{sec:TagAuthor} tag, and the tag \nameref{sec:TagUMLGraph} places an UML diagram for the current class to the generated documentation.

\subsubsection{The Field Comment}\label{sec:FieldComment}
Attributes/properties, constants and enum values are all summarised under ‘fields’ here.

Each and every field will have a comment, the ‘field comment‘, describing it. For \lstinline|private| fields it can be sufficient to refer to the related getter method instead of writing a lengthy comment into the field comment itself; do not use the \nameref{sec:TagSee} tag instead of the \nameref{sec:TagLink} tag:
\begin{lstlisting}
/**
 *  Refer to
 *  {@link #getValue()}.
 */
private final Value m_Value;

// AVOID!!
/**
 *  @see #getOtherValue()}.
 */
private final Value m_OtherValue;
\end{lstlisting}

If there is no getter method for a field, or it is not \lstinline|private|, a description is mandatory. Usually one sentence might be sufficient, although \lstinline|public| constants may require a full fledged usage description if that is not given elsewhere (for example, in the class comment or the package comment) and a reference to that description could be placed here.

It is always a good idea to describe the valid values for the field, its default value, and if \lstinline|null| is a possible value for a reference. This is a must for non-\lstinline|final| \lstinline|public| or \lstinline|protected| fields.

For a serialisable class, the fields that will be serialised should be tagged with \nameref{sec:TagSerial} and the appropriate description.

Constants (\lstinline|public static final| fields) that are initialised with a literal have to use the \nameref{sec:TagValue} tag in there description. Also \lstinline|private static final| or \lstinline|protected static final| fields that are initialised with a literal should use the \nameref{sec:TagValue}.

This looks like this:
\begin{lstlisting}
/**
 *  The vested system property for the file encoding used by the JVM:
 *  {@value}.
 */
public static final String PROPERTY_FILE_ENCODING = "file.encoding";
\end{lstlisting}

The comments for enum values are nothing else than field comments for constants – in fact, an enum value is exactly that: a \lstinline|public static final| field initialised with an instance of the enum type.

\subsubsection{The Method Comment}\label{sec:MethodComment}
The documentation comment for a method describes its usage and its function within the class, together with its arguments, the return value, and any exception it may throw.

For each method parameter there have to be a \nameref{sec:TagParam} tag that describes it in detail (if not already described in the main text of the method comment; in that case, a short sentence should be sufficient). The description has to cover the function of the parameter, its value range, and whether the parameter can be \lstinline|null|. Usually, \lstinline|null| is an invalid parameter value per default, so it has to be mentioned in the respective comment if it is allowed.

It is not enough to only give the type of the parameter in the comment; in fact, this is obsolete as it can be easily taken from the method's signature.

Usually, the return value (given the method is not of type \lstinline|void|) will be described in the comment for the \nameref{sec:TagReturn} tag; the tag is mandatory, and with some text, even if the return value is described already in the method description itself. The description for the return value should provide the possible values and there meanings, whether \lstinline|null| is a valid return value, and so on. 

In particular, the comment for the \nameref{sec:TagReturn} tag has to describe which return values indicate special or error conditions.

It is obsolete to give the type of the return value here; it can already be seen from the method's declaration.

Next there has to be a \nameref{sec:TagThrows} tag for each checked exception that may be thrown by the method, describing the condition that may trigger that exception. It is also possible to add \nameref{sec:TagThrows} clauses for unchecked exceptions, but not required. Refer to chapter \tqfullvref{sec:GeneralExceptionHandling} for additional details on exception handling.

A method that implements an interface method or that overrides a method from a base class be commented with the \nameref{sec:TagInheritDoc} tag instead of writing a full comment. The tag can be combined with additional text, too.

The documentation comment for a non-\lstinline|final| \lstinline|public| or \lstinline|protected| method has to provide detailed information when and how it has to be overwritten; especially if the overriding method has to call the super implementation and when:\footnote{Usually you should avoid the requirement for calling the super implementation, but that is not always appropriate or possible; refer to chapter \tqref{sec:NonFinalMethods} about some more details.}.

A comment for that case may look like this:\footnote{The tag @note is a custom tag; refer to chapter \tqfullvref{sec:CustomTagsForJavaDoc}}
\begin{lstlisting}
/**
 *  …
 *
 *  @note Call this implementation {before|after} your code, to make
 *      sure that the initialisations provided here are performed.
 *
 *  …
 */
\end{lstlisting}

For more details on this refer to chapter \tqfullvref{sec:ExtendingClassesOverridingMethods}.

Usually, the documentation comment for a method does not reveal details about the method's implementation, but in case of empty “place holder methods” or mount points, a sentence like below does not harm.
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 */
\end{lstlisting}

If such a method has a dummy or default return value, there has to be an appropriate \nameref{sec:TagReturn} tag, specifying that value:
\begin{lstlisting}
/**
 *  …
 *
 *  @note This implementation does nothing.
 *
 *  …
 *  @return Always <the default value>.
 */
\end{lstlisting}
 
Finally it is absolutely crucial that the documentation comment provides all information about possible side effects of a call to the method, even more when these side effects are unexpected.

\subsubsection{The Constructor Comment}\label{sec:ConstructorComment}
Basically, a constructor is a special kind of a method, so the same rules are valid for the documentation comment for a constructor than for the documentation comment for a method, as given in chapter \tqref{sec:MethodComment}.

For an empty default constructor, the constructor comment may be as simple as this, no matter if it is \lstinline|public|, \lstinline|private|, or \lstinline|protected|:
\begin{lstlisting}
/**
 *  Creates a new {@code MyClass} instance object.
 */
public MyClass() { /* Does nothing */ }
\end{lstlisting}
or
\begin{lstlisting}
/**
 *  Default constructor for class {@code MyClass}.
 */
private MyClass() { /* Does nothing */ }
\end{lstlisting}
with the first alternative being the preferred one; in fact, this comment can be used for every constructor, not only for the default ones.

Of course, these comments do not say very much, but the constructor is also not doing that much, and what it does is very obvious. But if it has side effects, these should be described properly.

A class that does have only \lstinline|static| methods\footnote{Such a class is called a “Utility Class”; refer to \tqfullvref{sec:UtilityClasses} for more details.} should have a \lstinline|private| constructor like this:\footnote{The \lstinline|Error| class is described in \autocite{TQUADRAT_ORG_FOUNDATION_PRIVATECONSTRUCTORFORSTATICCLASSCALLEDERROR}.}
\begin{lstlisting}
/**
 *  No instance is allowed for class {@code MyUtilityClass}.
 */
private MyUtilityClass() 
{ 
    throw new PrivateConstructorForStaticClassCalledError( MyUtilityClass.class); 
}   // MyUtilityClass()
\end{lstlisting}

If a constructor takes parameters, there has to be a \nameref{sec:TagParam} tag for each of them, exactly like for a method.

Although constructors should not throw (checked) exceptions, sometimes it could not be avoided without overcomplicating the API of a class. In such case, all exceptions has to be listed with the \nameref{sec:TagThrows} tag and a description of the conditions for the particular exception – as far as it is possible or make sense. Refer also to chapter \tqfullvref{sec:GeneralExceptionHandling} for some more details on exception handling.

\subsection{The JavaDoc Tags}\label{sec:JavaDocTags}
The next two chapters describe the tags that should be used in your documentation comments where appropriate.

One general rule for all JavaDoc tags: Do not insert line breaks between the parameters of a tag:
\begin{lstlisting}
// WRONG!!
/*
 *  …
 *  @param args
 *         The command line arguments
 *  @param  otherArg
 *          This parameter needs a very long explanatory comment that
 *          requires a line break.
 *  @throws IOException
 *          Reading the file failed.
 *  …
 */

// CORRECT:
/*
 *  …
 *  @param  args   The command line arguments
 *  @param  otherArg    This parameter needs a very long explanatory
 *      comment that requires a line break.
 *  @throws IOException Reading the file failed.
 *  …
 */
\end{lstlisting}

\subsubsection{The Standard Doclet Tags}
Most of the contents of this chapter was taken from the document “Documentation Comment Specification for the Standard Doclet”\autocite{ORACLE_DOC_JAVADOC_TAG}. 

In the context of the JavaDoc tool, the interpretation of the content of a documentation comment is done by the implementation of the interface \lstinline|jdk.javadoc.doclet.Doclet|\footnote{Refer to \autocite{ORACLE_DOC_DOCLET_INTERFACE}.} interface that is used to process the comment. Other implementation may accept the same syntax as the standard doclet (provided through the class \lstinline|jdk.javadoc.doclet.StandardDoclet|\autocite{ORACLE_DOC_STANDARDDOCLET_CLASS}), or they may support an alternate syntax. However, due to the support by many tools, the syntax supported by the standard doclet has become a \textit{de facto} standard.

\paragraph{\lstinline|@author|}\label{sec:TagAuthor} Usage: \lstinline|@author <name-text>|

The tag adds an “Author” entry with the specified name text to the generated documents when the \verb#-author# option is used. A documentation comment can contain multiple \lstinline|@author| tags. Use the \nameref{sec:TagExtAuthor} tag instead.

\paragraph{\lstinline|@code|}\label{sec:TagCode}  Usage: \lstinline|{@code <text>}|

This is equivalent to \lstinline|<code>{@literal text}</code>|.

It displays text in the code font without interpreting the text as HTML markup or nested JavaDoc tags. This enables you to use regular angle brackets (< and >) instead of the HTML entities (\&lt; and \&gt;) in documentation comments, such as in parameter types (<Object>), inequalities (3 < 4), or arrows (->).

If you want the same functionality without the code font, then use the \nameref{sec:TagLiteral} tag. 

\paragraph{\lstinline|@deprecated|}  Usage: \lstinline|{@deprecated <text>}|

This tag is used in conjunction with the \lstinline|@Deprecated|\autocite{ORACLE_DOC_DEPRECATED_ANNOTATION} annotation to indicate that this API should no longer be used (even though it may continue to work).

The first sentence of the text should tell the user when the API was deprecated and what to use as a replacement. Subsequent sentences can also explain why it was deprecated.

A \nameref{sec:TagLink} tag that points to the replacement API should be added where feasible.

\paragraph{\lstinline|@docRoot|}  Usage: \lstinline|{@docRoot}|

Represents the relative path to the generated document's (destination) root directory from any generated page. This tag is useful when you want to include a file, such as a copyright page or company logo, that you want to reference from all generated pages.

\paragraph{\lstinline|@exception|} This is a synonym for \nameref{sec:TagThrows}; it should not be used.

\paragraph{\lstinline|@hidden|}  Usage: \lstinline|@hidden|

Hides a program element from the generated API documentation. This tag may be used when it is not otherwise possible to design the API in a way that such items do not appear at all.

\paragraph{\lstinline|@index|}  Usage: \lstinline|{@index <word> <description>}| or \lstinline|{@index "<phrase>" <description>}|

Declares that a word or phrase, together with an optional short description, should appear in the index files generated by the standard doclet. The index entry will be linked to the word or phrase that will appear at this point in the generated documentation. The description may be used when the word or phrase to be indexed is not clear by itself, such as for an acronym.

\paragraph{\lstinline|@inheritDoc|}\label{sec:TagInheritDoc}  Usage: \lstinline|{@inheritDoc}|

Inherits (copies) the documentation comment from the nearest inheritable class or implementable interface into the current documentation comment at this tag's location. This enables you to write more general comments higher up the inheritance tree and to write around the copied text.

\paragraph{\lstinline|@link|}\label{sec:TagLink}  Usage: \lstinline|{@link <module/package.class#member> <label>}|

Inserts an inline link with a visible text label that points to the documentation for the specified module, package, class, or member name of a referenced class. 

This tag is similar to the \nameref{sec:TagSee} tag. Both tags require the same references and accept the same syntax for \verb|<module/package.class#member>| and the label. The main difference is that the \lstinline|{@link}| tag generates an inline link rather than placing the link in the “See Also” section. The \lstinline|{@link}| tag begins and ends with curly braces to separate it from the rest of the inline text. If you need to use the right curly brace (“\}”) inside the label, then use the HTML entity notation \verb|&#125;|.

\paragraph{\lstinline|@linkplain|}\label{sec:TagLinkplain}  Usage: \lstinline|{@linkplain <module/package.class#member> <label>}|

Behaves the same as the \nameref{sec:TagLink} tag, except the link label is displayed in plain text rather than code font. Useful when the label is plain text.

\paragraph{\lstinline|@literal|}\label{sec:TagLiteral}  Usage: \lstinline|{@literal <text>}| 

Same as the \nameref{sec:TagCode} tag, but the text is shown as plain text and not in the code font.

\paragraph{\lstinline|@param|}\label{sec:TagParam}  Usage: \lstinline|@param <parameter-name> <description>|

Adds a parameter with the specified parameter name followed by the specified description to the “Parameters” section. The parameter name can be the name of a parameter in a method or constructor, or the name of a type parameter of a class, method, or constructor. Use angle brackets (“<…>”) around such a parameter name to indicate the use of a type parameter.

\paragraph{\lstinline|@provides|}\label{sec:TagProvides}  Usage: \lstinline|@provides <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document an implementation of a service that is provided by the module. The description may be used to specify how to obtain an instance of this service provider, and any important characteristics of the provider itself. 

\paragraph{\lstinline|@return|}\label{sec:TagReturn}  Usage: \lstinline|@return <description>|

Adds a “Returns” section with the description text to the documentation comment of a method.

\paragraph{\lstinline|@see|}\label{sec:TagSee}  Adds a “See Also” heading with a link or text entry that points to a reference. The \lstinline|@see| tag has three variations; see \autocite{ORACLE_DOC_JAVADOC_TAG} for the details.

\paragraph{\lstinline|@serial|}\label{sec:TagSerial} Used in the documentation comment for a default serializable field. See “Documenting Serializable Fields and Data for a Class”\autocite{ORACLE_DOC_OBJECT_SERIALIZATION:DocumentingSerializableFieldsData}. 

\paragraph{\lstinline|@since|}\label{sec:TagSince}  Usage: \lstinline|@since <since-text>|

Adds a “Since” heading with the specified \verb#<since-text># value to the generated documentation. The text has no special internal structure. This tag that this change or feature has existed since the software release specified by the \verb#<since-text># value, for example: \lstinline|@since 1.5|.

Although it would possible to provide a date or something else, it is recommended to always use a version number with the \lstinline|@since| tag.

\paragraph{\lstinline|@summary|}\label{sec:TagSummary}  Usage:  \lstinline|{@summary <text>}|

Identifies  the summary of an API description, as an alternative to the default policy to identify and use the first sentence of the API description. The tag only has significance when used at the beginning of a description. In all cases, the tag is rendered by simply rendering its content.

The \lstinline|{@summary}| tag has to be used always when a documentation comment has more than one sentence; see also chapter \tqvref{sec:StructureAndContents}.

\paragraph{\lstinline|@throws|}\label{sec:TagThrows}  Usage: \lstinline|@throws <class-name> <description>|

The \lstinline|@throws| tag adds a “Throws” subheading to the generated documentation, with the \verb#<class-name># and the description text. The class name is the name of the exception that might be thrown by the method, and the description provides information about the conditions for that exception to be thrown. 

\paragraph{\lstinline|@uses|}\label{sec:TagUses}  Usage: \lstinline|@uses <service-type> <description>|

This tag may only appear in the documentation comment inside a \verb#module-info.java# file. It serves to document that a service may be used by the module. The description may be used to specify the characteristics of the service that may be required, and what the module will do if no provider for the service is available.

\paragraph{\lstinline|@value|}\label{sec:TagValue}  Usage: \lstinline|{@value}| or \lstinline|{@value <module/package.class#field>}|

This tag is used to display the values of constant in the generated documentation. When the \lstinline|{@value}| tag is used without an argument in the documentation comment of a \lstinline|static final| field, it displays the value of that constant:
\begin{lstlisting}
/**
 * The value of this constant is {@value}.
 */
public static final String SCRIPT_START = "<script>"
\end{lstlisting}

When used with the argument \verb|<module.package.class#field>| in any documentation comment, the \lstinline|{@value}>| tag displays the value of the specified constant:
\begin{lstlisting}
/**
 * Evaluates the script starting with {@value #SCRIPT_START}.
 */
public final String evalScript( String script ) { … }
\end{lstlisting}
The argument \verb|<module.package.class#field>| takes a form similar to that of the \nameref{sec:TagLink}, the \nameref{sec:TagLinkplain}, or the \nameref{sec:TagSee} tag argument, except that the member must be a \lstinline|static final| field.

\paragraph{\lstinline|@version|}\label{sec:TagVersion}  Usage: \lstinline|@version <version-text>|

Adds a “Version” subheading with the specified \verb#<version-text># value to the generated documents when the \verb#-version# option is used. This tag is intended to hold the current release number of the software that this code is part of, as opposed to the \nameref{sec:TagSince} tag, which holds the release number where this code was introduced. The \verb#<version-text># value has no special internal structure.

\subsubsection{Custom Tags for JavaDoc}\label{sec:CustomTagsForJavaDoc}
You can define your own JavaDoc tags; simple tags can be defined on the commandline for the JavaDoc tool (see the option \verb#-tag# in \autocite{ORACLE_DOC_JAVADOC_MAN:StandardDocletOptions}) or by implementing the interface \lstinline|jdk.javadoc.doclet.Taglet|\autocite{ORACLE_DOC_TAGLET_INTERFACE}.

I created a set of custom tags that I use regularly, and that I also recommend for your documentation comment. The respective library can be found at \autocite{TQUADRAT_ORG_FOUNDATION_JAVADOC}.

\paragraph{\lstinline|@anchor|}\label{sec:TagAnchor}  Usage: \lstinline|{@anchor #<anchor-name> <text>}|

This tag allows to add an HTML anchor to the generated documentation, where \verb#<anchor-name># is the name of the anchor to the given text. The hash symbol (‘\#’) before the name of the anchor is mandatory!

\paragraph{\lstinline|@extauthor|}\label{sec:TagExtAuthor}  Usage: \lstinline|@extauthor <name-text> - <email-address>|

This is a replacement for the \nameref{sec:TagAuthor} tag that renders the given email address as \verb#mailto:# link in the generated documentation. It does not regard the \verb#-author# option\footnote{This is valid for version 0.1.0 of the library; it may have changed for a later version}. 

\paragraph{\lstinline|@href|}\label{sec:TagHref}  Usage: \lstinline|{@href <url> <text>}| or \lstinline|{@href <url>}|

With this tag, an HTML hyperlink can be added to the generated documentation; if will place inside the description text, but different from the \nameref{sec:TagLink} and \nameref{sec:TagLinkplain} tags, it allows to refer to arbitrary external resources, not only to other documented elements. Obviously, \verb#<url># is the target URL, while \verb#<text># is the clickable text. If the latter is omitted, the URL itself will be used instead.

\paragraph{\lstinline|@inspired|}\label{sec:TagInspired}  Usage: \lstinline|@inspired <text>|

Sometimes a piece of code was inspired by a document of some kind, a description of an algorithm, a product white paper, or whatever. This tag allows you to add a reference to that source of inspiration. 

\paragraph{\lstinline|@modified|}\label{sec:TagModified}  Usage: \lstinline|@modified <name-text> - <email-address>|

This is a variant of the \nameref{sec:TagExtAuthor} tag. It is meant to provide the name of the developer that modified the respective element without claiming to be an author.

\paragraph{\lstinline|@note|}\label{sec:TagNote}  Usage: \lstinline|@note <text>|

With this tag, it is easy to add important notes to the generated documentation for an element. All notes will be added to a bullet list placed immediately beneath the documentation text. The text for the \lstinline|@note| tag is somehow limited as it does not allow other JavaDoc tags.

\paragraph{\lstinline|@thanks|}\label{sec:TagThanks}  Usage: \lstinline|@thanks <name-text> - <email-address>|

Use this tag to mention someone who provided input to the respective element without being an author; that person might have wrote an article about the algorithm that was implemented by this element, or they may have reported a bug.

Same as for the \nameref{sec:TagExtAuthor} and the \nameref{sec:TagModified} tags, the email address will be rendered to a \verb#mailto:# link in the generated documentation.

\paragraph{\lstinline|@UMLGraph.link|}\label{sec:TagUMLGraph}  Usage: \lstinline|@UMLGraph.link|

This adds an UML graph for the current class to the generated documentation.


\section{Implementation Comment Formats}
A source code file can have four styles of implementation comments:
\begin{itemize}[nosep]
\item{structuring comments}
\item{block comments}
\item{single-line comments}
\item{trailing or end-of-line comments}
\end{itemize}

\subsection{Structuring Comments}\label{sec:StructuringComments}
Structuring comments are the most simple comments: they are used to separate the parts of a class (as defined in chapter \tqfullvref{sec:ClassAndInterfaceDeclarations}) from each other. They have the form
\begin{lstlisting}
    /*------------------*\
====** Enum Declaration **===========================================
    \*------------------*/
    /*---------------*\
====** Inner Classes **==============================================
    \*---------------*/
    /*-----------*\
====** Constants **==================================================
    \*-----------*/
    /*------------*\
====** Attributes **=================================================
    \*------------*/
    /*------------------------*\
====** Static Initialisations **=====================================
    \*------------------------*/
    /*--------------*\
====** Constructors **===============================================
    \*--------------*/
    /*---------*\
====** Methods **====================================================
    \*---------*/
\end{lstlisting}

with the lines ending at column 80 (the samples here are too short).

If a class or interface does not have a particular part, the assigned structuring comment must be omitted.

I recommend to create “Building Blocks” with these comments. Eclipse provides the Snippet facility for this purpose\footnote{Storing the comments as code templates is not recommended as a template would be reformatted on insert.}. Refer to chapter \tqfullvref{sec:SnippetStructuringComments} for the snippet code for the structuring comments.

\subsection{Block Comments}\label{sec:BlockComments}
Block comments are used to provide detailed descriptions of files, methods, data structures and algorithms – meaning that the text of the comment is longer than just one line. Block comments may be used at the beginning of each block after the opening brace. They can also be used in other places, such as within methods. Block comments inside a function or method should be indented to the same level as the code they describe. 

A block comment should be preceded by a blank line to set it apart from the rest of the code. If the block comment does not directly refer to the code line immediately after it, it should be followed by another blank line.

Next, the first line of the comment block has to remain empty, and the closing of the comment block has to be placed on a line of its own.

Some samples:
\begin{lstlisting}
{
    /*
     * Here is a sample of a block comment. Block comments are used
     * to provide detailed information about code internals.
     */
    Result value = retrieveResult( parameter );
    …

    /*
     * Here is another sample of block comment, somewhere in the
     * middle of a code block. Please note the blank line above!
     */
    …
}

// AVOID!
/*
 * This block comment is outside the code block it refers to. Block 
 * comments should be placed after the opening curly brace of the
 * block.
 */
{
    Result value = retrieveResult( parameter );
    …
 
/* The first line of the block comment should be left empty and the
 * comment should be indented in the same way as the code in the
 * block.
 */
    processResult( value, parameter );
    /* 
     * Here the empty line above the comment is missing …
     * … and the closing tag should be on a line of its own. */
\end{lstlisting}
 
\subsection{Single-Line Comments}\label{sec:SingleLineComments}
Short comments can appear on a single line; they will be indented also to the level of the code that follows. Usually it should be written in the form of a headline:
\begin{lstlisting}
//---* Handle the condition *----------------------------------------
\end{lstlisting}
with the dashes ending on column 80.\footnote{A quick reminder: the sample code in this document uses a line length of 70, so the dashes in the comment line above ends an column 70.}

If a comment cannot be written in a single line, it should have the block comment format (see chapter \tqref{sec:BlockComments}). A single-line comment should be separated from the preceding code by a blank line. Only when the preceding line contains only the opening curly brace as in the \lstinline|if-then-else| sample below (lines~3 and 8). 

Here are some examples of single-line comments in Java code:
\begin{lstlisting}[numbers=left]
if( cache.contains( key ) )
{
    //---* Take the data from the cache *----------------------------
    …
}
else
{
    //---* Load the data from its original source *------------------
    …
}
…
ResultData resultData = executeService();

//---* Format the output for the UI *--------------------------------
formatResult( resultData );
…
\end{lstlisting}

Another form of the single line comment is the empty block comment:
\begin{lstlisting}
public interface Marker
{ /* No methods */ }

public class Extension extends Base
{ /* No implementation */ }

private Constructor() { /* Does nothing */ }

public void adapterMethod() { /* Does nothing */ }

public final void method()
{
    …

    try
    {
        …
    }
    catch( final MyException e ) { /* Exception deliberately swallowed /* }

    …
}   // method()
\end{lstlisting}

And finally, there are the “class termination comments” that repeats the name of the class after the last curly brace:
\begin{lstlisting}
public final class MyClass
{
    …
}
//  class MyClass

public final interface MyInterface
{
    public record InnerRecord( final int number )
    {
        …
    }
    //  record InnerRecord
    
    …
}
//  interface MyInterface

\end{lstlisting}

\subsection{Trailing or End-Of-Line Comments}\label{sec:TrailingOrEndOfLineComments}
Very short comments can appear on the same line as the code they describe, but should be shifted right far enough to separate them from the statements. If more than one short comment appears in a chunk of code, they should all be indented to the same tab setting.

Here's an example of a trailing comment in Java code:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            /* special case */
}
else
{
    return isPrime( a );    /* works only for odd a */
}
\end{lstlisting}

But it is more common to use “//” instead of “/*…*/” for these trailing comments:
\begin{lstlisting}
if( a == 2 )
{
    return TRUE;            // special case
}
else
{
    return isPrime( a );    // works only for odd a
}
\end{lstlisting}

You will use trailing comments to provide the documentation for local variables\footnote{Usually, the name of that local variable should be sufficient (refer to chapter \tqvref{sec:Fields}), or the meaning of that variable is obvious from the context, but sometimes it still make sense to provide that kind of additional information.}:
\begin{lstlisting}[numbers=left,caption={Gauss's Easter algorithm\autocite{WIKIPEDIA:DateOfEaster,WIKIPEDIA:Gaussche_Osterformel}}]
/**
 *  <p>{@summary This method calculates the date of Easter Sunday 
 *  for the given year.} The year has to be in the range from 1583 
 *  to 3900 (included).</p>
 *  <p>The resulting date is for the Gregorian calendar.</p>
 *  <p>The algorithm itself is not the original one published by Carl
 *  Friedrich Gauß first in 1800 (corrected version in 1816), but
 *  that one published by Heiner Lichtenberg in 1997.
 *
 *  @thanks Carl Friedrich Gauß
 *  @thanks Heiner Lichtenberg  
 *
 *  @param  year    The year for which the date of Easter Sunday is 
 *      wanted for.
 *  @return The date of Easter Sunday in the given year.
 *  
 *  @see <a href="https://de.wikipedia.org/wiki/Gau%C3%9Fsche_Osterformel">Gaußsche Osterformel</a>
 */
public static final LocalDate calcEasterDate( final Year year )
{
    /*
     * The explanation for the variables was taken from the German
     * Wikipedia article and translated by me. The original terms
     * are given in parenthesis.
     */
    final int x;  // The year
    final int k;  // The secular number (die Säkularzahl)   
    final int m;  // The secular moon shift (die säkulare Mondschaltung)
    final int s;  // The secular moon shift (die säkulare Sonnenschaltung)
    final int a;  // The moon parameter (der Mondparameter)
    final int d;  // The seed for the first full moon in spring (der Keim 
        // für den ersten Vollmond im Frühling)
    final int r:  // The calendar adjustment (die kalendarische
        // Korrekturgröße)
    final int og; // The Easter limit (die Ostergrenze)
    final int sz; // The first Sunday in March (der erste Sonntag im März)
    final int oe; // The distance of Easter Sunday from the Easter limit
        // – Easter distance in days (die Entfernung des Ostersonntags
        // von der Ostergrenze – Osterentfernung in Tagen)
    final int os; // The date of Easter Sunday as a March date with 
        // March 32 as April 1 etc. (das Datum des Ostersonntags als 
        // Märzdatum – 32. März = 1. April usw.)
    
    //---* Check the arguments *-------------------------------------    
    if( requireNonNullArgument( year, "year" ).isBefore( Year.of( 1583 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years greater than or equal to 1583" );
    }
    if( year.isAfter( Year.of( 3900 ) ) )
    {
        throw new IllegalArgumentException( "This method will work only for years less than or equal to 3900" );
    }

    //---* Lichtenberg's Easter formula *----------------------------
    x = year.getValue();
    k = x / 100;    
    m = 15 + (3 * k + 3) / 4 - (8 * k + 13) / 25;
    s = 2 - (3 * k + 3) % 4;
    a = x % 19;
    d = (19 * a + m) % 30;
    r = (d + a / 11) / 29;
    og = 21 + d - r;
    sz = 7 - (x + x / 4 + s) % 7;
    oe = 7 - (og - sz) % 7;
    os = og + oe;

    /*
     * Initialise the return value with the last day of February and 
     * add the calculated number of days.
     */
    final var retValue = LocalDate.of( y, MARCH, 1 )
        .minusDays( 1 )
        .plusDays( os );

    //---* Done *----------------------------------------------------
    return retValue;
}   //  calcEasterDate()
\end{lstlisting}

As you can see, for this use case it is acceptable to continue a long comment in the following line (see lines~31 and 32, for example) without using a block comment.

Another use case for these kind of comments is to provide information about the arguments of a method call; usually, you should avoid method signatures where this is required (the formal parameter of the method should be sufficient to explain the argument), but sometimes it makes still sense:
\begin{lstlisting}
…
drawCircle(
    x, y, // The center of the circle
    d/2.0 // The radius of the circle, calculated from the diameter
);
…
\end{lstlisting}

The end comment for a method is also of this type:
\begin{lstlisting}
public final void method()
{
    …
} //  method()
\end{lstlisting}

Also a long code block\footnote{But if it seems really necessary to add such a comment to a linear code block, you should consider to re-organise your code.} can be commented like this:
\begin{lstlisting}
{
    //---* Calculate the result *------------------------------------
    // Lots of code comes here ...
    …
} //  End of result calculation
\end{lstlisting}

The end comments for the bodies of \lstinline|for|, \lstinline|while|, \lstinline|switch| and even \lstinline|if-then-else| blocks are a special case, as those blocks should be introduced by a label, and this label should be repeated as the end comment:
\begin{lstlisting}
ScanLoop: for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  ScanLoop:

ForeverLoop: while( true )
{
    // Lots of code comes here ...
    …
}   //  ForeverLoop:

TypeSwitch: switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  TypeSwitch:

SpecialCaseTurnout: if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  SpecialCaseTurnout:
else
{
    // Not so much code here
    …
}    
\end{lstlisting}
Note the colon at the end of each of the comments!

Do not use the introducing code line for the end comment! That code line may change at some point in time and then the end comment does not have a corresponding starting line anymore.\footnote{This also means that you should be careful with removing or changing labels in the code.}

Avoid this:
\begin{lstlisting}
// AVOID!!!
for( final var s : lines )
{
    // Lots of code comes here ...
    …
}   //  for( final var s : lines )

while( true )
{
    // Lots of code comes here ...
    …
}   //  while( true )

switch( type )
{
    case TYPE_1 -> …
    …
    case TYPE_n -> …
    default -> throw new IllegalArgumentException()
}   //  switch( type )

if( isSpecialCase() )
    // Lots of code comes here ...
    …
}   //  if( isSpecialCase() )
else
{
    // Not so much code here
    …
}    
\end{lstlisting}

\section{Maintenance Comments}\label{sec:MaintenanceComments}
It is very likely that source code will be changed more than once during its lifetime. Bugs will be fixed, functionality is added or removed, refactorings will be applied, or the code will be migrated to other platforms or different versions of the programming language, the underlying libraries, the connected systems and/or the operating system.

There is a practice that all the changes made in the code will be commented in the code. These comments are usually referred to as “Maintenance Comments”.

This may look like this:
\begin{lstlisting}
…
//<<BEGIN FSP-4711 – applied by Micky Mouse
//<Old Code>
//…
//>><<
<New Code>
…
//>>END FSP-4711
\end{lstlisting}

It has proved that this is not a good practice at all, and a really bad practice if dealing with code that is managed by an SCCS.

First, this practice causes problems for the compare tools coming with the SCCS – at least it will make it more difficult to read the comparison results from those tools.\footnote{Most comparison tools will recognise the out-commenting of the old code as a change and the new code as additional code instead of the replacement for the old code. This is at least confusing when a code revisions are made on the fix.} And the main function of those comments – documenting the changes – is much better served by the SCCS tools themselves.

Second, this gets even worse when the fix needs a fix. Just think about overlapping changes, like FSP-4712 changes lines from the new code of FSP-4711, together with lines directly below, or changes that has to be partially reverted, and so on.

And finally, the comments does not help to identify if your are currently running the patched code, or the old one.

On the other hand, nothing can be said against adding a line to the file or class comment that lists the patches that were applied to the code.

Therefore I recommend to introduce an annotation that can be used to mark elements that are affected by a fix.

Such an annotation can provide the BUG number of the fix, together with a short description of the issue. This annotation replaces a comment about the applied patches, with the advantage that it can be retrieved also from the compiled classes, even at runtime.

Chapter \tqfullvref{sec:PatchIdentification} provides an example of such an annotation.

Old code will be removed and not commented out, or just replaced by the new code. One or the other short comment with a hint is not mandatory, but does not harm either.

When using the suggested annotation from chapter \tqref{sec:PatchIdentification}, this could look like this:
\begin{lstlisting}
…
@BUG( id = "BUG-4711", comment = "No end criterion for loop" )
@BUG( id = "BUG-4712", comment = "Exception was swallowed" )
public final void myMethod()
{
    ForeverLoop: while( true )
    {
        try
        {
            …
            
            if( !hasMore() ) break ForeverLoop; // BUG-4711
        }
        catch( final IllegalStateException e )
        {
            log( e );
            break ForeverLoop; // BUG-4712: Added exception handling
        }
    }   //  ForeverLoop:
}   //  myMethod()
…
\end{lstlisting}

\section{Special Comments}
The “Code Conventions for the Java\textsuperscript{TM} Programming Language”\autocite{SUN_CODE_CONVENTIONS:SpecialComments} suggests some special comments: \verb#XXX# in a comment flags something that is bogus but works. \verb#FIXME# flags something that is bogus and broken (and has to be fixed very soon).

Eclipse knows a setting that allows to externalise such comments into a task list: \verb#Window|Preferences|General|Editors|Structured Text Editors|Task Tags#.

It also adds \verb#TODO# to that list, for something that still needs to be implemented.

\section{Commenting out Code}
Use the “//” delimiter to comment out a complete line, only a partial line, or a whole bunch of consecutive lines of code.

Example:
\begin{lstlisting}
if( foo > 1 )
{
    //---* Do a double-flip *----------------------------------------
    …
}
else
{
    return false;          // Explain why here.
}
//if( bar > 1 )
//{
//    //---* Do a triple-flip *--------------------------------------
//    …
//}
//else
//{
//    return false;
//}
\end{lstlisting}

To use a block comment (“/*…*/”) for commenting out sections of code is not a good idea, although you do not have to type that much: you cannot have a block comment inside a block comment.

The easiest way to comment out a selected code block this way in Eclipse is to use \verb#Source|Toggle Comment# from the menu or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “7” instead of “/”.}.

In IntelliJ IDEA, it is the menu command \verb#Code|Comment with Line Comment# or the short key \verb#CTRL+/#\footnote{On a German keyboard, it is “÷” on the numeric keypad instead of “/”.}.

\section{Comments when?}\label{sec:CommentsWhen}
To repeat what was already said at the beginning of the chapter \tqfullref{sec:WritingProperComments}: The frequency of comments reflects poor quality of code, but code can be “under-commented” or “over-commented”. This means that there is a “frequency band” for comments that has to be hit for good quality code.

The advice “When you feel compelled to add a comment, consider rewriting the code to make it clearer.” raises the question for whom the code has to made clearer, because the experts and the rookies are completely distinct audiences, with different needs in regard of comments in the source code.

Same with that other advice (“Even if you don't think, a comment might be necessary, add it nevertheless”): it is the other extrema, and equally bad.

That leads us (again) to the conclusion, that writing good comments to source code is a complex art.

This means that this document cannot give you a complete rule set here, just some guidance.

That documentation comments are required everywhere possible, and how to write them was already covered in chapter \tqfullvref{sec:DocumentationComments}, thus we focus here on the implementation comments.

\begin{itemize}
\item{No empty blocks are allowed (means that “\{\}” may not occur in the code). If there is really no code in a block, there have to be least a comment, just to show that this is deliberate. For \lstinline|catch| blocks, there should be a good (at least some) explanation, why it is empty (see also chapter \tqfullref{sec:GeneralExceptionHandling}).

Some samples:
\begin{lstlisting}
//---* Skip input stream until then end *----------------------------
while( input.read() != EOF ) { /* empty */ }
// Better
while( input.read() != EOF );

//---* Spent CPU cycles on counting *--------------------------------
for( var i = 0; i < maxValue; ++i ) { /* empty */ }
// Better
for( var i = 0; i < maxValue; ++i );


InputStream input = null; // null if cannot open file
try
{
    input = new FileInputStream( "myFile" );
}
catch( final FileNotFoundException ignored ) { /* Deliberately ignored */ }
// Better
InputStream input; // null if cannot open file
try
{
    input = new FileInputStream( "myFile" );
}
catch( final FileNotFoundException ignored ) 
{ 
    input = null;
}

@MountPoint
public Data customAction( final Data data ) { /* Does nothing */ }

public MyClass() { /* Just exists */ }

public interface MyInterface { /* No methods */ }
\end{lstlisting}}
\item{A short description of the algorithm that was implemented by the current code is always helpful; even just mentioning its name can make a difference when hunting a bug. But in case the implementation changes, such a comment needs to be adjusted as well.}
\item{Whenever you hurt or ignore one of the rules or recommendations from this document, it is worth a comment:
\begin{lstlisting}
value = 7.0 / a; // a != 0.0 was already checked above

o.execute(); // o != null was checked in foo.bar( o )

/*
 * bar.getQ() will never return null, so an explicit check on
 * null for q was omitted
 */
q = bar.getQ();
q.execute();}
\end{lstlisting}
In all these samples, arguments or values are not checked for \lstinline|null| or zero, \textit{because this was already done elsewhere} – and not necessarily just one line above the current location. The comment tells a maintenance engineer that the check was made – at least in the initial version of the code – and that the root cause for the problem might be elsewhere (perhaps because someone eliminated that other location or at least the value check there).}
\item{A comment is mandatory each time an exception is swallowed, no matter if silently or not, meaning the exception is logged somewhere. If the program is continued after an exception was caught, write a comment (see also chapter \tqfullref{sec:GeneralExceptionHandling}).}
\item{As said already in chapter \tqfullvref{sec:SwitchStatements}, a comment is required on a case fall-through.}
\item{Non-obvious class casts should be explained with a comment, in order to document that the programmer knew what they did:
\begin{lstlisting}
private final void valueProcessor( List<Object> values )
{
    …
    Value value;
    for( Object o : values )
    {
        /*
         * We know that values can only contain Value objects;
         * otherwise this method would not have been called to
         * process the list.
         */
        value = (Value) o;
        …
}
\end{lstlisting}
This makes sense here because a check like
\begin{lstlisting}
if( o instanceof Value ) value = (Value) o;
\end{lstlisting}
is relatively expensive – especially if the contract for this \lstinline|private| method is that it is called only with lists containing \lstinline|Value| objects so that the check would not be positive only in very, very, very rare cases. And finally: what else can be done in cases where the object is not of the right type than throwing a ClassCastException? That's the same that is done by the code above in such a case, too.

First, the version
\begin{lstlisting}
if( o instanceof Value value )
{
    …
}
\end{lstlisting}
might be clearer, but it is not less expensive.

Second, having a list of \lstinline|Value| objects declared as \lstinline|List<Object>| is bad design – or legacy code.}
\item{In some sources you will find the recommendation to add a comment at the end of a long compound statement; this was already discussed in chapter \tqfullref{sec:SingleLineComments}.}
\item{With the \lstinline|@SuppressWarnings| annotation\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION}, you can switch off a compiler warning or error caused by code that is somehow “hurting the rules”. Basically, the \lstinline|@SuppressWarnings| annotation is a replacement for a comment about that deviation from the rules, an additional comment is required only in cases it is not obvious why that annotation was applied. More details on this are provided in \tqfullvref{sec:CompilerWarningsAndErrors}.}
\item{tbc}
\end{itemize}

\section{Updating Comments}
If the code has to be modified, no matter if due to regular maintenance, bug fixing or a migration, all related comments has to be updated accordingly. There is no value in keeping “historical comments”, although mentioning the old algorithm when the former implementation has been replaced completely might be useful in some cases.

But keeping the outdated code as a comment is definitely not useful, in particular not when there is an SCCS used to manage the code.

\chapter{Coding Rules}\label{sec:CodingRules}
These rules are a collection of coding standards and best practices. Obeying them should make your code better readable and less error prone. Some of them will even help to increase the program's overall performance.

As always there may be good reasons to do it different from what is recommended or even requested by the rules\footnote{You remember the bullet points~\ref{lst:ZoP:SpecialCases} and \ref{lst:ZoP:Practicality} from the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython,PYTHON_ORG_MAILING_LIST:ThePythonWay} that I quoted in chapter \tqvref{sec:OtherProgrammingLanguages}?}. In such case a comment is required that describes that reason.\footnote{Omitting this comment is also a deviance from the rule, requiring a comment to explain it. Also known as the Catch~22.}

One basic recommendation is that you should not write the same code over and over again. This is also known as the “DRY Principle” (“Don't Repeat Yourself”) and we will discuss this later again.

And please keep in mind that not always the shortest, most compact source code is the best. Also avoid what is known as “Premature Optimization”\footnote{Donald E. Knuth made the following statement on optimisation: “We should forget about small efficiencies, say about 97\% of the time: premature optimization is the root of all evil.”\autocite{KNUTH:PrematureOptimization}}. Modern optimising compilers and run-time optimisers do a very good job to create compact object code, so in most cases the programmer can concentrate fully on writing readable and comprehensible code. In this context I would like to remind you on the quotation from Martin Fowler's book that I put in front of this document, and again to the “Zen of Python”, here the points~\ref{lst:ZoP:SimpleVsComplex} “Simple is better than complex” and \ref{lst:ZoP:ComplexVsComplicated} “Complex is better than complicated”.\footnote{Yes, I know: for a document about Java Coding Conventions, there is an astonishing amount of references to Python …}

But although optimisation still may have some limits, comments will have never any impact on the runtime performance of a program. So please refer to chapter \tqfullvref{sec:CommentsWhen} (if not done already) and see the recommendation when to apply comments to your code.

\section{Swap Logic Errors for Compiler Errors}
From a book about Java programming :
\begin{quotation}
“One fundamental principle of programming is that, generally, it is best to swap a logic error for a compiler error. Compiler errors tend to be found in seconds and are corrected just as fast. Syntax errors are a good example […]

Logic errors, on the other hand, are the bane of all programmers. They hide and hate to reveal themselves. Logic errors seem to have minds of their own, constantly evading detection and dodging your efforts to pin down their cause. They can easily take a thousand times more effort to solve than the worst compiler errors. Worst of all, many logic errors are not found at all and occur only intermittently in sensitive places, which causes your customer to scream for a fix. Logic errors often require you to throw thousands of man-hours at them, only to finally discover that they are minor typos.”

Hardcore Java\autocite{HARDCORE_JAVA}
\end{quotation}

A sample for swapping a logic error for a compiler error is the recommendation to write comparisons always with the unchangeable value on the left side\footnote{This recommendation originates from C/C++ programming where \lstinline|if| conditions are checking values of type integer – and in C, nearly everything can be an integer, or at least be interpreted like one. Java forces that the type of the expression in the \lstinline|if| condition has to be \lstinline|boolean|, therefore this approach is less useful for Java code.}. So if you forget the second equal sign for a comparison on equal, the compiler will complain immediately:
\begin{lstlisting}
if( length() == len ) …
if( 5 == len ) …
\end{lstlisting}

Another sample for this is the recommendation to name fields with the “m\_” prefix (refer to chapter \tqfullvref{sec:Fields}). The compiler will never complain if you omit the \lstinline|this.| prefix when accessing a field, and it will not complain if you name a local variable in the same way as a field\footnote{Although you can configure both Eclipse and IntelliJ Idea to raise an error or a warning if you access a field without \lstinline|this.| and if you shadow a field through a local variable with the same name.} – but it will scream loudly about a non-existing reference if you forget the “m\_” prefix when accessing a field named along the rules defined here.

The best thing about compiler errors is, that they usually show up during development – and not first after deployment at customer side.

See also chapter \tqvref{sec:CompilerWarningsAndErrors} about compiler warnings and errors.

\section{Access to Properties}
Encapsulation is an important design principle for classes. This means that the internal state of an object can be manipulated only in a well defined manner, through the methods. Consequently, it may not be possible to modify the attributes  directly, by a direct assignment.

To achieve that, instance or class variables – also known as properties, attributes or fields – have to be \lstinline|private|.

If it is necessary to set or retrieve an instance variable (a property) directly, it mandatory to provide the appropriate methods for this (setter and/or getter, or mutator and/or accessor methods). But often attributes are set or retrieved as a side effect of method calls that modify the internal state of the object instance, or rely on it.

Programmers are inclined to use \lstinline|public| fields when the need a data structure like a \lstinline|struct| in C/C++, and not a full-fledged class. But as Java does not now that data structure, it seems to be a quick solution to have a \lstinline|class| with only \lstinline|public| fields and no methods, just to spare typing effort, and sometimes with the idea, that the direct access to the \lstinline|public| field is much faster that accessing it through a method. But modern optimising compilers will inline the code of a simple getter method, so that there is no difference in the end.

And if you want to avoid the typing, use a \lstinline|record|\autocite{ORACLE_DOC_RECORD,ORACLE_DOC_LANGUAGE_SPECIFICATION:RecordClasses} instead. Sometimes also an instance of \lstinline|java.util.Map| or another collection implementation could be an alternative to a specialised class.
 
Sometimes fields from base classes are defined as \lstinline|protected|, to make them directly accessible by methods from the derived implementations, but this is also discouraged.\footnote{The idea behind that is the same false assumption that the direct access to the \lstinline|protected| field is much faster that accessing it through a method.}

It does not matter if we talk about properties (instance variables) or \lstinline|static| field (class variables): both should always be \lstinline|private|.

Constants are the only exception, obviously, because a constant is explicitly defined as a \lstinline|public static final| field.

Regarding encapsulation in general, refer to chapter \tqvref{sec:EncapsulationWithModules}.

\section{Accessing Fields or Methods using Reflection}
First of all, you should avoid to use Reflection whenever possible. Just do not use it!\footnote{The only acceptable exception is for unit tests; we will discuss that later in this chapter.}

One reason is that accessing a field or a method via reflection causes some overhead that decreases a program’s performance. 

Next, such code is usually not easy to read or to understand, not only because of all the necessary error handling code around it.

And with modularisation, it is quite often not even possible to access methods and fields of an object via Reflection, even if they are \lstinline|public|; they are not even visible in some cases.

Of course, there are some patterns whose implementation in Java requires the use of Reflection, because any other approach is either even less performant, much more cumbersome, or will not work at all – meaning there are occasions when it is not really possible to avoid the use of Reflection. Nevertheless, you should still consider an alternative; lambdas\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:LambdaExpressions} and method references\autocite{ORACLE_DOC_LANGUAGE_SPECIFICATION:MethodReference} are quite often a very good replacement for an implementation based on Reflection.

Reflection also allows you to access non-\lstinline|public| member of a class that are usually not accessible by your code. This is considered a “dirty hack” and may not be used in production code. In particular as it may not work properly with modules.

But there are useful applications for this, too: you can and should used it in unit tests for \lstinline|private| or \lstinline|protected| methods that are not \lstinline|public| for good reasons, and if these methods cannot be tested indirectly.\footnote{The alternative would be to make the method at least \lstinline|protected|, but this would make it (more) visible to the consumers of the API, and perhaps even accessible – but there was a reason why that method was originally \lstinline|private|.}

I recommend to use the following pattern if you want to access a \lstinline|private| method in your unit tests:
\begin{lstlisting}[numbers=left]
public final class MyClass
{
    /**
     *  Does something.
     *
     *  @param  value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    private final String myMethod( final CharSequence value ) throws IOException      { … }
}   
//  class MyClass

/**
 *  This class provides some unit tests for
 *  {@link MyClass}.
 */
public final class TestMyClass
{
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The reference to {@code myMethod()}.
     */
    private static final Method METHOD_myMethod;
    
    static
    {
        final var targetClass = MyClass.class;
        String methodName;
        try
        {
            methodName = "myMethod";
            METHOD_myMethod = targetClass.getDeclaredMethod( methodName, CharSequence.class );
            METHOD_myMethod.setAccessible( true );
        }
        catch( final NoSuchMethodException e )
        {
            throw new ExceptionInInitializerError( "Cannot find method '%s()' in class '%s'".formatted( methodName, targetClass.getName() ).initCause( e );
        }
    }
    
        /*---------*\
    ====** Methods **================================================ 
        \*---------*/
    /**
     *  Calls
     *  {@link MyClass#myMethod(CharSequence)}
     *
     *  @param  instance    The candidate.
     *  @param	value   The value.
     *  @return The result.
     *  @throws IOException Something went wrong.
     */
    protected static final String myMethod( final MyClass instance, final CharSequence value )
    {
        final String retValue;
        try
        {
            retValue = (String) METHOD_myMethod.invoke( requireNonNullArgument( instance, "instance" ), value );
        }
        catch( final IllegalAccessException | ClassCastException e )
        {
            throw new AssertionError( e );
        }
        catch( final InvocationTargetException e )
        {
            switch( e.getCause() )
            {
                case null -> throw new AssertionError( e );
                case IOException ioe -> throw ioe;
                default -> throw new AssertionError( e.getCause() );
            }
        }
    }   //  myMethod()   
    
    @Test
    final void testMyMethod() throws Exception
    {
        final var candidate = new MyClass();
        final var result = myMethod( candidate, "" );
        assertTrue( result instanceof String );
    }   // testMyMethod()
}
//  class TestMyClass  
\end{lstlisting}
This allows you to call the method \lstinline|MyClass::myMethod| nearly directly; the method \lstinline|TestMyClass::myMethod| behaves in the same way as the original method.

\lstinline|java.lang.AssertionError|\autocite{ORACLE_DOC_ASSERTIONERROR_CLASS} is the base class for the errors thrown by JUnit\autocite{JUNIT5}.

\section{Implementing the Object Methods}
In Java all \textit{classes} are somehow extending the class \lstinline|java.lang.Object|\autocite{ORACLE_DOC_OBJECT_CLASS}, and therefore, they inherit several methods from it. Four of these methods\footnote{In fact, it is five methods, but the method \lstinline|finalize()|\autocite{ORACLE_DOC_OBJECT_CLASS:finalize} is deprecated and should not be used anymore. Refer to chapter \tqfullvref{sec:Finalisation} for more details on this topic.} can be overridden to adjust the behaviour of your class to your needs:
\begin{itemize}[nosep]
\item{\lstinline|clone()|\autocite{ORACLE_DOC_OBJECT_CLASS:clone}}
\item{\lstinline|equals()|\autocite{ORACLE_DOC_OBJECT_CLASS:equals}}
\item{\lstinline|hashCode()|\autocite{ORACLE_DOC_OBJECT_CLASS:hashCode}}
\item{\lstinline|toString()|\autocite{ORACLE_DOC_OBJECT_CLASS:toString}}
\end{itemize}

The chapters below will provide some guidelines on how to code new implementations for these methods.

\subsection{equals() and hashCode()}\label{sec:EqualsAndHashCode}
Overriding the method \lstinline|java.lang.Object::equals|\autocite{ORACLE_DOC_OBJECT_CLASS:equals} always requires to override the method \lstinline|java.lang.Object::hashCode|\autocite{ORACLE_DOC_OBJECT_CLASS:hashCode}, too – and vice versa.

\textit{This is not optional!}

The method \lstinline|equals()| returns \lstinline|true| if the given reference to refers to an object to is equals to the current one, according to \textit{your criteria what “being equal” means} in this context, and – obviously – \lstinline| false| otherwise.

So two objects can be considered to be equal when they both have the same unique id, or you require for equality that all attributes do have the same values (are also equal), or something in between. The default implementation of \lstinline|java.lang.Object.equals()| returns \lstinline|true| only if the two objects are identical\footnote{This means that both objects are the \textit{same}; the given reference points to the current object itself.}.

If two objects are equal, the result of \lstinline|hashCode()| has to be the same for both objects, but that the hash values for two objects are the same does not necessarily imply that the two objects are equal.

An implementation for the two methods should look like this:
\begin{lstlisting}[numbers=left,caption={Methods equals() and hashCode()}]
public class MyClass
{
    /**
     *  {@inheritDoc}
     */
    public boolean equals( final Object o )
    {
        var retValue = o == this;
        if( !retValue && o instanceof MyClass other
            && getClass().equals( other.getClass() ) )
        {
            retValue = Objects.equals( <attribute>, other.<attribute> )
                && Objects.equals( < … >, other.< … > );
        }
            
        //---* Done *------------------------------------------------
        return retValue;
    }   //  equals()
    
    /**
     *  {@inheritDoc}
     */
    public int hashCode()
    {
        final var retValue = Objects.hash( <attribute>, < … > );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  hashCode()    
}
//  class MyClass
\end{lstlisting}
The check in line~10 can be omitted if \lstinline|MyClass| is \lstinline|final|. If that check is omitted for a non-\lstinline|final| class, it means that instances of derived classes can be equal to an instance of the superclass – something that is rarely wanted, especially because it would break the rule that any implementation of \lstinline|equals()| has to guarantee that
\begin{lstlisting}
a.equals( b ) == b.equals( a )
\end{lstlisting}
is always valid.

The attributes that are compared in the lines~12 and following have all to be used in \lstinline|hashCode()| to calculate the hash value.

When both a superclass and its derived classes implement \lstinline|java.lang.Object::equals| and \lstinline|java.lang.Object::hashCode|, the implementation of the derived class may call the superclass implementations of \lstinline|equals()| and \lstinline|hashCode()|:
\begin{lstlisting}[numbers=left]
public class OtherClass extends MyClass
{
    /**
     *  {@inheritDoc}
     */
    public boolean equals( final Object o )
    {
        var retValue = o == this;
        if( !retValue && o instanceof OtherClass other
            && super.equals( other ) )
        {
            retValue = Objects.equals( <attribute>, other.<attribute> )
                && Objects.equals( < … >, other.< … > );
        }
            
        //---* Done *------------------------------------------------
        return retValue;
    }   //  equals()
    
    /**
     *  {@inheritDoc}
     */
    public int hashCode()
    {
        final var retValue = Objects.hash( Integer.valueOf( super.hashCode ), <attribute>, < … > );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  hashCode()    
}
//  class OtherClass
\end{lstlisting}
Obviously, both methods consider only the attributes that comes with the definition of the derived class; the attributes of the superclass are already covered.

\subsection{toString()}\label{sec:ToString}
According to \autocite{ORACLE_DOC_OBJECT_CLASS:toString}, the method \lstinline|toString()|
\begin{quotation}
“Returns a string representation of the object.

In general, the \lstinline|toString()| method returns a string that ‘textually represents’ this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. […]”
\end{quotation}

What does “textually represents” mean?

The implementation for \lstinline|java.lang.Object::toString| …
\begin{quotation}
“[…] returns a string consisting of the name of the class of which the object is an instance, the at-sign character ‘@’, and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:\
\lstinline|getClass().getName() + '@' + Integer.toHexString( hashCode() )|”
\end{quotation}
But for an instance of \lstinline|java.lang.Integer|\autocite{ORACLE_DOC_INTEGER_CLASS}, that ‘string representation’ is just a string containing the digits for the numerical value of that object, and for an instance of \lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}, it is the current contents of the buffer.

For the class \lstinline|java.util.StringJoiner|\autocite{ORACLE_DOC_STRINGJOINER_CLASS}, \lstinline|toString()| is even the method that provides the result.

Originally, the textual representation of an object as provided by the \lstinline|toString()| method was meant only for debugging purposes, but soon it was also used for the conversion of the object's value to a string, like for the class \lstinline|java.lang.Integer|.

So how to implement the method \lstinline|toString()| for your method?

If your class represents objects that can be easily written as a string, you should implement \lstinline|toString()| accordingly:
\begin{lstlisting}
public final class PhoneNumber
{
    private final int m_AreaCode;
    private final int m_CountryCode;
    private final int m_SubscriberNumber;
    
    …
    
    /**
     *  {@inheritDoc}
     */
    @Override 
    public final String toString()
    {
        final var retValue = "+%d %d %d".formatted( m_CountryCode, m_AreaCode, m_SubscriberNumber );
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  toString()
}   
//  class PhoneNumber
\end{lstlisting}

Some samples for this from the Java Runtime Library are the classes below:
\begin{itemize}
\item\lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\item\lstinline|java.lang.StringBuffer|\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\item\lstinline|java.util.UUID|\autocite{ORACLE_DOC_UUID_CLASS}
\item\lstinline|java.time.Instant|\autocite{ORACLE_DOC_INSTANT_CLASS} and the other classes representing time/date values from the \lstinline|java.time| package\autocite{ORACLE_DOC_TIME_PACKAGE}
\item\lstinline|java.io.File|\autocite{ORACLE_DOC_FILE_CLASS}
\item\lstinline|java.lang.Integer|\autocite{ORACLE_DOC_INTEGER_CLASS} and the other wrapper classes for the primitives
\end{itemize}

In all these cases, you can use a call to \lstinline|toString()| to embed the value of the instance into a regular text:
\begin{lstlisting}
final var phoneNumber = new PhoneNumber( … );
out.printf( "The customer's phonenumber is %s.", phoneNumber.toString() );
\end{lstlisting}

If your class is more complex and/or an output makes only sense for debugging purposes or requires additional formatting instructions, you should consider a different implementation of \lstinline|toString()|:
\begin{lstlisting}
public final class EmailMessage
{
    private final String m_Body;
    private final Map<RecipientType,List<EmailAddress>> m_Recipients;
    private final EmailAddress m_Sender;
    private final ZonedDateTime m_SentWhen;
    private final String m_Subject;
    
    …
    
    /**
     *  {@inheritDoc}
     */
    @Override 
    public final String toString()
    {
        final var buffer = new StringJoiner( ", ", "%s[".formatted( getClass().getName(), "]" )
            .add( "Body='%s'".formatted( m_Body ) )
            .add( "Recipients=%s".formatted( Objects.toString( m_Recipients ) ) )
            .add( "Sender='%s'".formatted( Objects.toString( m_EmailAddress ) ) )
            .add( "Sent_when=%s".formatted( Objects.toString( m_SentWhen ) ) )
            .add( "Subject='%s'".formatted( m_Subject ) );
            
        //---* Compose the return value *----------------------------    
        final var retValue = buffer.toString();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  toString()
}
//  class EmailMessage
\end{lstlisting}

This is basically how the IDEs will generate the \lstinline|toString()| method. The output may look like this\footnote{The backslash indicates where I inserted a linebreak so that it looks fine in this document; otherwise it would be just one long line.}:
\begin{verbatim}
org.tquadrat.sample.EmailMessage[Body='This is the body of the\
email', Recipients=[a.b@c.de], Sender='thomas.thrien@tquadrat.\
org', Sent_when=2022-11-26T20:31:17.884636950+01:00[Europe/Ber\
lin], Subject='Ping!']
\end{verbatim}

This will work fine for a debug log, but to get it ‘pretty printed’, you may have to provide another method. Refer to chapter \tqvref{sec:FormattableInterface} for how
this could look like.

If your class is not \lstinline|final|, the method \lstinline|toString()| should not be \lstinline|final| as well. 

\subsection{clone()}\label{sec:Clone}
Per \autocite{ORACLE_DOC_OBJECT_CLASS:clone}, the method \lstinline|java.lang.Object::clone| returns a copy of the current object.

Usually, this method is \lstinline|protected| and the default implementation throws a \lstinline|java.lang.CloneNotSupportedException|\autocite{ORACLE_DOC_CLONENOTSUPPORTEDEXCEPITON_CLASS} when called.

When instances of your class should support to be cloned, it first has to implement the interface \lstinline|java.lang.Cloneable|\autocite{ORACLE_DOC_CLONEABLE_INTERFACE}, and then you need to override the method \lstinline|clone()|.

The simpliest implementation looks like this:
\begin{lstlisting}[numbers=left,caption={A simple clone() Method}]
public final MyClass implements Cloneable
{
    /**
     *  {@inheritDoc}
     */
    @Override
    public final MyClass clone()
    {
        final MyClass retValue;
        try
        {
            retValue = (MyClass) super.clone();
        }    
        catch( final CloneNotSupportedException e )
        {
            throw new UnexpectedExceptionError( e );
        }
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  clone() 
}
//  class MyClass
\end{lstlisting}
This works despite the fact that the class \lstinline|java.lang.Object| \textit{does not} implement \lstinline|java.lang.Cloneable|!

But it fails in case your class extends a class (other than \lstinline|java.lang.Object|) that does not implement \lstinline|java.lang.Cloneable|.

The implementation of \lstinline|java.lang.Object::clone| uses native code to make a shallow copy of the current object. If all attributes of the class are either immutable or primitives, the implementation shown above is sufficient.

But if any of the attributes are collections, arrays or mutable types, there is some
more work to do; in this case, your implementation of \lstinline|clone()| should declare the \lstinline|java.lang.CloneNotSupportedException|.

Such an extended implementation of \lstinline|clone()| may look like below; it is assumed that \lstinline|T| is not immutable\footnote{If \lstinline|T| will not implement  \lstinline|java.lang.Cloneable|, we can reduce the implementation of \lstinline|clone()| to just throw \lstinline|java.lang.CloneNotSupportedException|. But even if \lstinline|T| implements \lstinline|java.lang.Cloneable|, \lstinline|T::clone| can still throw that exception.}.
\begin{lstlisting}[numbers=left,caption={An extended clone() Method}]
public final MyClass<T extends Cloneable> implements Cloneable
{
    private final T [] m_Array;
    private final Collection<T> m_Collection;
    private T m_Mutable; // MAY NOT BE FINAL!!
    
    /**
     *  {@inheritDoc}
     */
    @Override
    public final MyClass clone() throws CloneNotSupportedException
    {
        final var retValue = (MyClass) super.clone();
        for( var i = 0; i < m_Array.size; ++i )
        {
            retValue.m_Array [i] = nonNull( m_Array [i] ) 
                ? m_Array [i].clone() 
                : null;
        }
        retValue.m_Collection.clear();
        for( final var t : m_Collection ) retValue.m_Collection.add( t.clone() );
        retValue.m_Mutable = m_Mutable.clone();
        
        //---* Done *------------------------------------------------
        return retValue;
    }   //  clone() 
}
//  class MyClass
\end{lstlisting}

The code in line~21 supposes that the collection does not contain any \lstinline|null| values. And obviously, the collection has to be mutable, otherwise already the attempt to clear it in line~20 would throw an exception.

Unfortunately, the interface \lstinline|java.lang.Cloneable| does not declare the method \lstinline|clone()|, therefore the code below will not work:
\begin{lstlisting}
// WILL NOT WORK!!
CloneLoop: for( final var t : m_Collection ) 
{
    if( isNull( t ) ) continue CloneLoop;
    if( t instanceof Cloneable c )
    {
        retValue.m_Collection.add( c.clone() );
    }
    else
    {
        throw new CloneNotSupportedException( t.toString() );
    }    
}   //  CloneLoop:
\end{lstlisting}

So in case a collection (or an array) may contain components that can or cannot be cloned, the test is a bit more complex:
\begin{lstlisting}
CloneLoop: for( final var t : m_Collection ) 
{
    if( isNull( t ) ) continue CloneLoop;
    boolean isCloneable = false;
    if( t instanceof Cloneable )
    {
    	isCloneable = stream( getClass().getMethods() )
    	    .filter( m -> m.getParameterCount() == 0 )
    	    .map( Method::getName )
    	    .filter( n -> n.equals( "clone" ) )
    	    .count() == 1;
    }
    
    if( isCloneable )
    {
        retValue.m_Collection.add( c.clone() );
    }
    else
    {
        throw new CloneNotSupportedException( t.toString() );
    }    
}   //  CloneLoop:
\end{lstlisting}
Instead of the stream operation, you can also use \lstinline|java.lang.Class::getMethod| and respond to the \lstinline|java.lang.NoSuchMethodException| for the check.

If you have to implement the method \lstinline|java.lang.Object::clone| for lots of classes, it could make sense to implement your own \lstinline|Cloneable| interface that then can be used with the \lstinline|instanceof| operator and the pattern:
\begin{lstlisting}
public interface Cloneable<T> extends java.lang.Cloneable
{
    /**
     *  Forces the implementation of
     *  {@link Object#clone()}
     *
     *  @returns The cloned object.
     *  @throws  CloneNotSupportedException One of the mutable
     *      attributes is not cloneable.
     */
    public T clone() throws CloneNotSupportedException; 
}
//  interface Cloneable
\end{lstlisting}

There are several ongoing discussions whether the API that was defined through the \lstinline|java.lang.Object::clone| is generally usefull or more a pain in the ass, and as far as I am aware, these discussions will last for some more time.

I am not a friend of \lstinline|clone()| and I try to avoid its implementation whenever possible. This means that sometimes it is not possible to circumvent the implementation of that method.

My recommendation is to ignore the method \lstinline|java.lang.Object::clone| unless there is a strict requirement to use it.

\section{String Concatenation}
How to concatenate strings has been a topic of discussion since the very beginning of Java. And the truth has changed with nearly each version of the language, not making it easier to decide how it is done correctly. This chapter provides some recommendations and best practices for the current versions of Java (Java~17 and later).

\subsection{The Basics}
The implementation of the concatenation of two (or more) strings – or other data types to create their representation as a text – is a trade off between readability and performance. This is due to one important characteristic of the class \lstinline|java.lang.String|\autocite{ORACLE_DOC_STRING_CLASS}: it is immutable. This means that
\begin{lstlisting}
String a = "part1";
String b = "part2";
a += b;
\end{lstlisting}
will not modify \lstinline|a| but returns a new \lstinline|String| object with the concatenated contents of \lstinline|a| and \lstinline|b| and assigns a reference to that new object to \lstinline|a|.

Older sources described the internal implementation of the \lstinline|+| operator for \lstinline|java.lang.String| like this:
\begin{lstlisting}
// NOT THE REAL IMPLEMENTATION!!
private final String operatorPlus( String a, String b )
{
    final var buffer = new StringBuffer( a )
        .append( b );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  operatorPlus()
\end{lstlisting}

This means that an intermediate object of type \lstinline|java.lang.StringBuffer|\autocite{ORACLE_DOC_STRINGBUFFER_CLASS} has to be created for each concatenation. This gets even worse if you want to append a numerical value to the String, like this:
\begin{lstlisting}
String a = "part1";
a += 42;
\end{lstlisting}

The implementation for this was described as
\begin{lstlisting}
// NOT THE REAL IMPLEMENTATION!!
private final String operatorPlus( String a, int b )
{
    StringBuffer buffer = new StringBuffer( a );
    String bString = Integer.toString( b );
    buffer.append( bString );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  operatorPlus()
\end{lstlisting}
meaning that two intermediate objects are created.

Knowing this, the recommendation was always to write
\begin{lstlisting}
String a = new StringBuffer( b )
    .append( c )
    .toString();
\end{lstlisting}
instead of
\begin{lstlisting}
String a = b + c;
\end{lstlisting}
and
\begin{lstlisting}
String a = new StringBuffer( a )
    .append( b )
    .toString();
\end{lstlisting}
instead of
\begin{lstlisting}
a += b;
\end{lstlisting}
in order to increase performance.\footnote{These recommendations origin from a time when the class \lstinline|java.lang.StringBuilder|\autocite{ORACLE_DOC_STRINGBUILDER_CLASS} did not yet exist. Java~5 introduced \lstinline|StringBuilder| as the successor/replacement for \lstinline|StringBuffer|; it is more perfomant than \lstinline|StringBuffer| because its operations are not synchronised and therefore have less overhead than that of \lstinline|StringBuffer|.}

But with each Java version the \textit{real} implementation of \lstinline|+| and \lstinline|+=| for \lstinline|String| changed, so that today there is no longer just only one recommendation.

\subsection{Concatenating String Constants}
In your code, string literals will be always concatenated with the \verb#plus# operator:
\begin{lstlisting}
String a = "StringOne" + "StringTwo";
\end{lstlisting}
because this way, they will already be concatenated \textit{during compile time}; using \lstinline|StringBuilder| here would cause negative effects on both performance and readability. This is also true when \lstinline|static final String| variables, initialised with a literal, are concatenated with each other or with another string literal:
\begin{lstlisting}
public static final String constantA = "StringOne";
public static final String constantB = "StringTwo";
String a = constantA + constantB;
String b = constantA + "StringThree";
\end{lstlisting}
The compiler replaces each reference to the \lstinline|static final String| variables by either the literal itself or a reference to the literal and concatenates them if required.

\subsection{Concatenating String Variables}
Benchmark tests showed that beginning with one of the later versions of Java~1.4 the variant
\begin{lstlisting}
String a = "part1";
String b = "part2";
String s = a + b;
\end{lstlisting}
is significantly faster than
\begin{lstlisting}
String a = "part1";
String b = "part2";
String s = new StringBuffer( a )
    .append( b );
\end{lstlisting}
Even using \lstinline|StringBuilder| in Java~5 instead of \lstinline|StringBuffer| is slower than the \verb#+# operator.

Appending non-string values to a \lstinline|String| can be done as
\begin{lstlisting}
String a = "part1";
int b = 42;
String s = a + Integer.toString( b );
\end{lstlisting}
and that is still being faster than the \lstinline|StringBu*er| versions.

\subsection{Concatenating Strings in Loops}
The picture changes if strings are extended permanently in a loop:
\begin{lstlisting}
// AVOID!!!
public final String buildSentence( String... words )
{
    var retValue = "";
    for( final var s : words )
    {
        if( !retValue.isEmpty() ) retValue += " ";
        retValue += s;
    }
    retValue += ".";
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()
\end{lstlisting}

Here it is the better option to use \lstinline|StringBuilder| or even \lstinline|java.util.StringJoiner|\autocite{ORACLE_DOC_STRINGJOINER_CLASS}:
\begin{lstlisting}
// BETTER
public final String buildSentence( String... words )
{
    final var buffer = new StringBuilder()
    for( final var s : words )
    {
        if( buffer.length() > 0 ) buffer.append( " " );
        buffer.append( s );
    }
    buffer.append( "." );
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()

// RECOMMENDED
public final String buildSentence( String... words )
{
    final var buffer = new StringJoiner( " ", "", "." );
    for( final var s : words )
    {
        buffer.add( s );
    }
    final var retValue = buffer.toString();
    
    //---* Done *----------------------------------------------------
    return retValue;
}   //  buildSentence()
\end{lstlisting}

This is faster than the first version, although the concatenation with \verb#+# is usually faster than using \lstinline|StringBuilder|, because it will definitely create much less objects that has to be garbage collected later – what will have a negative impact on performance.

\subsection{Conclusion}
The recommendation is to use the \verb#+# operator for strings where to combine literals, \lstinline|String| constants and/or String variables in a single, standalone statement, but to consider \lstinline|StringBuilder| or even \lstinline|StringJoiner| if strings have to be concatenated in loops or (large) a number of consecutive statements.\footnote{But keep \autocite{KNUTH:PrematureOptimization} in mind, where Donald E. Knuth said something about “premature optimisation”.}

When “adding” primitives to a string, these should be translated to a \lstinline|String| first by calling the \lstinline|static toString()| method of the appropriate wrapper class. This is not necessary if calling \lstinline|StringBuilder::append| as this exists as specialised versions each primitive type.

Also when "adding" an instance of another type to a string, you should consider to first call \lstinline|toString()| on that object.This is not mandatory, as it is done implicitly anyway, but it clearly shows what you intended.

Finally, \lstinline|java.lang.StringBuilder| should always be preferred over \lstinline|java.lang.StringBuffer|. I have not found any use case where I could not use \lstinline|StringBuilder| and was forced to use \lstinline|StringBuffer| instead.

\subsection{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\autocite{ORACLE_DOC_STRING_CLASS}
\autocite{ORACLE_DOC_FORMATTER_CLASS}
\autocite{ORACLE_DOC_FORMATTABLE_INTERFACE}



\section{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

In this sense, I would like to steal the “Zen of Python”\autocite{WIKIPEDIA:ZenOfPython,PYTHON_ORG_MAILING_LIST:ThePythonWay}\footnote{The numbering was added by me; I also added the ellipsis.} for this document:
\begin{enumerate}[nosep]
\item Beautiful is better than ugly.
\item Explicit is better than implicit.
\item Simple is better than complex.
\item Complex is better than complicated.
\item Flat is better than nested.
\item Sparse is better than dense.
\item Readability counts.
\item Special cases aren't special enough to break the rules …
\item … although practicality beats purity.
\item Errors should never pass silently …
\item … unless explicitly silenced.
\item In the face of ambiguity, refuse the temptation to guess.
\item There should be one – and preferably only one – obvious way to do\\ it …
\item … although that way may not be obvious at first unless you're Dutch.
\item Now is better than never …
\item … although never is often better than \textit{right now}.
\item If the implementation is hard to explain, it's a bad idea.
\item If the implementation is easy to explain, it may be a good idea.
\item Namespaces are one honking great idea – let's do more of those!
\end{enumerate}
Only number~\ref{lst:ZoP:Namespaces} does not work for code written in Java, unless you translate “Namespace” to “Package” (or “Module” …).



\section{The Annotation @API}\label{sec:APIAnnotation}

\section{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{“Convention over Configuration”}
The phrase “Convention over Configuration” (or “Coding by Convention”) got popular with the introduction of Ruby on Rails, but it is related to earlier ideas like the concept of “Sensible Defaults” and the “Principle of Least Astonishment” in user interface design.

Basically it means that an object instance can be created and used properly with only minimal configuration because all not absolutely mandatory settings will have meaningful – and useful! – default values.

On the other hand, there is that number~\ref{lst:ZoP:ExplicitVsImplicit} from the “Zen of Python”, saying “Explicit is better than implicit” …

These are obviously contradictory statements – so whose right?

Both, to some extent!

Your design should support “Convention over Configuration”, but your code should rely on defaults only when a change of these defaults in unlikely, or such a change will not have an effect to your code.

So assume that you are using a 3\textsuperscript{rd} party library that creates reports in HTML format; the default format was HTML3 with the previous version, but in the current version – that one used by you – it is HTML5. The generated reports are consumed by a tool that converts HTML5 input into PDF.

According to “Convention over Configuration”, you are fine: the convention is HTML5, you do not need to set the HTML version for the output format explicitly.

But what happens, if in a few years the next version of that report creator library will support HTML7 as the default, but your PDF generator stucks still with HTML5 for its input? Nothing happens until your successor as the maintainer of your software decides to use that new library … afterwards you may see funny things in the generated PDF documents.

So the recommendation is: do not always rely on conventions! Whenever possible, provide an explicit configuration! At least leave a comment when you rely on the defaults, and that comment should describe what the anticipated defaults are.

\section{-------------------------------------------- Proceed from here!}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\begin{lstlisting}
\end{lstlisting}

\section{Exceptions}
\lipsum[1]

\subsection{General Exception Handling}\label{sec:GeneralExceptionHandling}
\lipsum[1]

\section{Extending Classes, Overriding Methods}\label{sec:ExtendingClassesOverridingMethods}
\lipsum[1]

\subsection{Non-Final Methods}\label{sec:NonFinalMethods}
\lipsum[1]

\section{Compiler Warnings and Errors}\label{sec:CompilerWarningsAndErrors}
It is not allowed to commit any code that emits warnings or even errors on a compiler run to the SCCS. It is also not allowed to switch off any compiler warning globally.

In fact, warnings should even not show up in the development environment, also with the most aggressive settings.

It is allowed to use the annotation \lstinline|@SuppressWarnings|\autocite{ORACLE_DOC_SUPPRESSWARNINGS_ANNOTATION} to locally deactivate a warning. This is often necessary when dealing with legacy APIs that does not use Generics. So this sample would emit an “unchecked” warning for line 3:
\begin{lstlisting}[numbers=left]
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

To avoid this, the annotation \lstinline|@SuppressWarnings| with the value “unchecked” can be applied – preferably not to the method as a whole, but only to the problematic assignment, even if this means that an additional temporary variable is required (but not in this sample):
\begin{lstlisting}
// RECOMMENDED
public final Map<K,V> clone()
{
    @SuppressWarnings( "unchecked" ) 
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}

// AVOID!!!
@SuppressWarnings( "unchecked" ) 
public final Map<K,V> clone()
{
    HashMap<K,V> retValue = (HashMap<K,V>) this.clone();
    return retValue;
}
\end{lstlisting}

As there is no rule without exception, here is one: I recommend to use labels to mark long code blocks (refer to the chapters \tqfullref{sec:LabelsAndBreakStatements}, \tqfullref{sec:TrailingOrEndOfLineComments}, and \tqfullref{sec:CommentsWhen}), but if those code blocks do not reference these labels, they may cause an “Unused Label” warning in your IDE. The recommendation is here to deactivate that warning – globally.

\section{Returning Values}\label{sec:ReturningValues}
\lipsum[1]

\subsection{Lambda Results}\label{sec:LambdaResults}
\lipsum[1]

\section{The Ternary Operator “?”}\label{sec:TheTernaryOperator}
\lipsum[1]

\section{Encapsulation}
\lipsum[1]

\subsection{Encapsulation with Modules}\label{sec:EncapsulationWithModules}
\lipsum[1]

\section{Lambdas}\label{sec:Lambdas}
\lipsum[1]

\section{The Interface “java.util.Formattable”}\label{sec:FormattableInterface}

\autocite{ORACLE_DOC_STRING_CLASS}
\autocite{ORACLE_DOC_STRINGBUFFER_CLASS}
\autocite{ORACLE_DOC_STRINGBUILDER_CLASS}
\autocite{ORACLE_DOC_STRINGJOINER_CLASS}
\autocite{ORACLE_DOC_FORMATTER_CLASS}
\autocite{ORACLE_DOC_FORMATTABLE_INTERFACE}

\lipsum[1]

\section{Utility Classes}\label{sec:UtilityClasses}
\lipsum[1]

\section{try-with-resources}\label{sec:TryWithResources}
The feature \lstinline|try-with-resources| was introduced with Java~7; it can help to make programs more stable and less error prone.

\subsection{Basics}
Basically, \lstinline|try-with-resources| is an extension of the previously existing \lstinline|try-catch-finally| feature.

Instead of writing
\begin{lstlisting}[numbers=left]
InputStream input = null;
try
{
    input = new FileInputStream( file );
    …
}
catch( final IOException e )
{
    // Handle the error
}
finally
{
    try
    {
        if( input != null ) input.close();
    }
    catch( final IOException e )
    {
        // Handle the error
    }
}
\end{lstlisting}

the new feature allows you to write

\begin{lstlisting}[numbers=left]
try( final var input = new FileInputStream( file ); )
{
    …
}
catch( final IOException e )
{
    // Handle the error
}
\end{lstlisting}

It works because the interface \lstinline|java.lang.AutoCloseable|\footnote{In fact, \lstinline|InputStream| will still implement just \lstinline|java.io.Closeable|, as already before Java~7, but this interface will now extend the new interface \lstinline|java.lang.AutoCloseable|.} is implemented by the class \lstinline|java.io.InputStream|. For details refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE}.

This interface defines just one method, \lstinline|close()|, that declares to throw an exception of type \lstinline|java.lang.Exception|.

\lstinline|close()| is called automatically on all instances of \lstinline|AutoClosable| that were declared and defined in the ‘arguments list’ of the new \lstinline|try| when the scope of the \lstinline|try| block is left. If there is more than one resource defined, the sequence is reversed to that of the definition: the last assigned resource will be closed first.

So a code snippet to copy data from an input stream to an output stream may look like this\footnote{This is obviously not a very good implementation, but it illustrates how to use \lstinline|try-with-resources| quite well.}:
\begin{lstlisting}[numbers=left]
try
( 
    InputStream input = new FileInputStream( infile );
    OutputStream output = new FileOutputStream( outfile ) 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
\end{lstlisting}
Both streams will be closed properly in case of a problem or the work is done.

\subsection{Error Handling}
What will happen if the code in the \lstinline|try| block throws an exception and closing the resource will throw one, too?

For the ‘traditional’ pattern this could mean that the first exception would be ‘supplanted’ by the exception from the close. For sure, in a \lstinline|catch| block the original cause could be logged, but usually only checked exceptions (and “expected“ ones) are covered this way.

Together with \lstinline|try-with-resources|, a new feature was introduced to the language: the \textit{suppressed} exception. This deals with the problem described above.

So if the \lstinline|try| block throws an exception (for our example, it would be most probably an \lstinline|IOException|) and the \lstinline|AutoCloseable.close()| will fail with an exception, too, the latter one will be added to the first one as a “suppressed exception” by the JVM.

For this purpose, the API of the class \lstinline|java.lang.Throwable| was extended by the methods \lstinline|addSuppressed()| and \lstinline|getSuppressed()|.\footnote{see \autocite{ORACLE_DOC_THROWABLE_CLASS}}

Using \lstinline|Throwable.printStackTrace()| an output like that below will be produced:
\begin{lstlisting}
java.lang.Error
  at TryWithResources.main(TryWithResources.java:175)
  Suppressed: java.lang.Exception
    at TryWithResources$Resource2.close(TryWithResources.java:103)
    at TryWithResources.main(TryWithResources.java:176)
\end{lstlisting}

\subsection{Execution Sequence}\label{sec:ExecutionSequence}
It is important to know how the execution sequence looks like when using \lstinline|try-with-resources|. For the traditional pattern it is\\
\begin{center}
\verb#try{}->[catch{}]->finally{}#
\end{center} 
for \lstinline|try-with-resources| it will be\\ 
\begin{center}
\verb#try{}->AutoCloseable.close()->[catch{}]->[finally{}]#
\end{center}

This means that the method \lstinline|close()| on the \lstinline|AutoClosable| objects will be called \textit{before} any code in an optional \lstinline|catch| and/or \lstinline|finally| block that is attached to the \lstinline|try| block. For the sample we used above this means that the \lstinline|InputStream input| is already closed when the code in the \lstinline|catch| block that handles the \lstinline|IOException| will be executed.

Therefore the code below will not work as expected in case an exception is thrown in the \lstinline|try| block:
\begin{lstlisting}
// WILL NOT WORK!
final var logStream = new FileOutputStream( logfile )
try
(   
    final var input = new FileInputStream( infile );
    final var output = new FileOutputStream( outfile );
    final var log = logStream 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
catch( final IOException e )
{
    logStream.write( "Copy failed!\n".getBytes( UTF8 ) );
    /* Fails because the log file is already closed! */
}
\end{lstlisting}

\subsection{When to use?}
\lstinline|try-with-resources| is a very powerful feature that should be used whenever possible. Definitively it should be used with all the Java classes that already implement \lstinline|java.lang.AutoCloseable| or \lstinline|java.io.Closeable|:

\begin{itemize}
\item{The \lstinline|java.io| streams}
\item{Sockets}
\item{\lstinline|java.sql.Connection|, \lstinline|java.sql.Statement|, \lstinline|java.sql.ResultSet|}
\item{\lstinline|java.jms.Connection|}
\end{itemize}

\subsubsection{Lifecycle}\label{sec:Lifecycle}
In C++, it is a very common pattern to “wrap” the lifecycle of a resource into the lifecycle of an object:
\begin{lstlisting}[language=C++]
class Resource
{
    //---* Attributes *----------------------------------------------
    private:
        RTYPE m_Res;

    //---* Constructors *--------------------------------------------
    public:
        Resource( RTYPE &r )
        : m_Res( r )
        { m_Res.open(); }

    //---* Destructor *----------------------------------------------
    public:
        ~Resource() { m_Res.close(); }

    //---* Methods *-------------------------------------------------
    // Some methods to access the resource
    …
}
\end{lstlisting}
A use of that class might look like this:
\begin{lstlisting}[language=c++]
…
{
    Resource resource( r );

    // Do something
    …
}
…
\end{lstlisting}
The instance of \lstinline|Resource| will be constructed and \lstinline|open()| is called on \lstinline|r| on the declaration of the variable \lstinline|resource|. On leaving the scope the destructor of \lstinline|Resource| is called implicitly and \lstinline|close()| will be called on \lstinline|r|.

The C++~STL is using a very similar pattern for smart pointers.

Unfortunately, Java does not know destructors\footnote{The deprecated method \lstinline|java.lang.Object.finalizer()| that is part of each Java class is not and was never a replacement for or an alternative to a destructor as it could never be predicted when it is called (just “sometime before the JVM terminates” – if ever).}, so this pattern could not be used.

A workaround is to use a \lstinline|try-finally| block with the cleanup (usually a call to \lstinline|close()|) in the \lstinline|finally| block. But to often we have seen that in the run of modifications and/or corrections (refactorings) suddenly the \lstinline|finally| block and/or its contents had been removed (“optimised away”).

Now, with the \lstinline|try-with-resources| feature, we can have “Lifecycle” classes; they are still not that easy to use that with real destructors, but we can come close.

A sample would be the Class \lstinline|AutoLock|; for the full code, see chapter \tqfullvref{sec:AutoLock}; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

In programs that use \lstinline|java.util.concurrent.locks.Lock| or one of its implementations for thread synchronisation, you will find quite often code like this:
\begin{lstlisting}[numbers=left]
m_Lock.lock();
try
{
    // Do something
    …
}
finally { m_Lock.unlock(); }
\end{lstlisting}

This calls for a lifecycle class. Unfortunately the code below will not work, due to several reasons:
\begin{lstlisting}[numbers=left]
// Does not work!!
try( final var unused = new Lock() )
{
    // Do something
    …
}
\end{lstlisting}

First, \lstinline|java.util.concurrent.locks.Lock| will not implement \lstinline|java.lang.AutoCloseable|, and second – much more important – we cannot create a new instance of \lstinline|Lock| each time we enter the critical section.\footnote{Not to mention that \lstinline|java.util.concurrent.locks.Lock| is an interface so that \lstinline|new Lock()| cannot work at all.}

Fortunately, the \lstinline|try-with-resources| feature will not call \lstinline|close()| on the newly created object, but on the local reference (that is the reason why \lstinline|try-with-resources| will not work with anonymous instances like \lstinline|try( new Lock() )|). If we would now wrap the \lstinline|Lock| instance into a class that implements \lstinline|AutoCloseable|, we can write something like this:
\begin{lstlisting}[numbers=left]
…
AutoLock m_AutoLock = new AutoLock( m_Lock );
…
try( final var unused = m_AutoLock.lock() )
{
    // Do something
    …
}
\end{lstlisting}

\subsubsection{Post-Processing}
Together with lambdas, \lstinline|try-with-resources| can be (ab)used also to enforce a unconditional post-processing when a code block is left. This may look like this:
\begin{lstlisting}[numbers=left]
…
Runnable doAfter = …;
…
try( final var p = new PostProcessor( doAfter ) )
{
    // Do whatever necessary
    …
}
\end{lstlisting}
The \lstinline|PostProcessor| instance will call \lstinline|Runnable::run| in its \lstinline|close()| method when the \lstinline|try| block is left. Chapter \tqfullref{sec:PostProcessor} in the Appendices provides the source for the class.

‘Unconditional’ means here that the post-processing will be executed if the block terminates regularly or by a thrown exception. Other conditions can be injected into the \lstinline|Runnable| implementation.

The difference between this approach and simply calling \lstinline|doAfter.run()| in a \lstinline|finally| block is that the \lstinline|close()| method of \lstinline|PostProcessor| is invoked before any code in a \lstinline|catch| block (refer to chapter \tqfullref{sec:ExecutionSequence}).

The following code snippet could be a real-life example for where this is useful:
\begin{lstlisting}[numbers=left]
final var builder = new StringBuilder();

final Runnable addTrailer = () -> builder.append( "}\n" );

…

try( final var p = new PostProcessor( addTrailer ) )
{
    …
}
\end{lstlisting}
This ensures that the string in \lstinline|builder| always terminates with a closing curly brace followed by a linefeed.

Another sample is this code snippet:
\begin{lstlisting}[numbers=left]
final List<String> list = new LinkedList();

final Runnable forceSorting = () -> list.sort();

…

try( final var p = new PostProcessor( forceSorting ) )
{
    for( final var s : loadStrings() )
    {
        list.add( s );
    }
}
\end{lstlisting}
Here the \lstinline|PostProcessor| forces that the given list is always sorted after the values had been added.

\section{Date and Time Values}\label{sec:DateAndTimeValues}
\lipsum[1]

\section{Finalisation}\label{sec:Finalisation}
\lipsum[1]

\section{Deprecation of Elements}\label{sec:DeprecationOfElements}
\lipsum[1]

\section{Miscellaneous}
In this chapter I collected some dos and don'ts that do not fit into one of the other chapters, but are not relevant enough for a chapter on there own.

\begin{itemize}
\item{Avoid octal numerical literals in your source code! Although this feature exists since the first versions of Java, it is not very well known.

If you do not know what I talking about: start \verb#jshell#, type in \lstinline|021 + 021| and be surprised that the result is not the ultimate answer to life, the universe, and everything.\autocite{ADAMS_HITCHHIKERS_GUIDE}

Or to summarise it: Do not prefix integer literals with a 0!}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\item{}
\end{itemize}

\include{Summary}

\chapter{Appendices}

\section{The Naming Dictionary}\label{sec:TheNamingDictionary}
The names of program elements provide an implicit contract (or at least a kind of commitment) between the original author of the program and its users/maintainers. But because people understand words differently, I have added a dictionary of common verbs and their implicit contracts here, together with a list of suffixes for class names.

\subsection{Verbs}
This chapter provides a list of verbs\footnote{Ok, some names or prefixes are not verbs, like ‘main’, ‘from’ or ‘to’ …} to be used with method names and a description of their implicit contract. These verbs are usually prefixes to a method name, although some of them could be used as standalone names, too. The form that used more often is mentioned first.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{Verbs.tbl.tex}

That a method name is built using one of the verbs above does not free you from providing a proper JavaDoc comment that describes the purpose of the method in detail, together with the arguments, return values and exceptions.

\subsection{Suffixes for Class Names}\label{sec:SuffixesForClassNames}
This chapter lists defined suffixes for class names and their function.

\renewcommand{\cellalign}{tl}
\LTXtable{\linewidth}{ClassNameSuffixes.tbl.tex}

\section{Configurable Errors and Warnings}\label{sec:ConfigurableErrorsAndWarnings}
A very convenient feature of most IDE's is the capability to configure additional warnings and even errors for the compilation.

\subsection{Eclipse}\label{sec:EclipseErrorsAndWarnings}
tdb

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJErrorsAndWarnings}
tdb

\section{IDE Configuration}\label{sec:IDEConfiguration}
This chapter provides samples of configuration files for some IDEs. See also the chapter \tqvref{sec:ConfigurableErrorsAndWarnings} about the errors and warnings that can be configured in Eclipse and IntelliJ IDEA.

\subsection{Eclipse}\label{sec:EclipseConfiguration}
tbd

\subsubsection{Snippets}
This chapter provides the XML code for Eclipse snippets.

\paragraph{Structuring Comments}\label{sec:SnippetStructuringComments}
The snippets for the structuring comments as defined in chapter \tqfullvref{sec:StructuringComments}.
\begin{lstlisting}[language=XML,basicstyle=\ttfamily\footnotesize]
<?xml version="1.0"
      encoding="UTF-16" 
      standalone="no"?>
<snippets>
    <category filters="*"
              id="category_1145179107125"
              initial_state="0"
              label="Structuring Comments"
              largeicon=""
              smallicon="">
        <description><![CDATA[Structuring Comments as defined by the Code Conventions]]></description>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145232938375"
              label="Enum Declaration"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the enum definition part]]></description>
            <content><![CDATA[        /*------------------*\
    ====** Enum Definitions **=================================================
        \*------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179869843"
              label="Inner Classes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the inner classes part]]></description>
            <content><![CDATA[        /*---------------*\
    ====** Inner Classes **====================================================
        \*---------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251889697104"
              label="Constants"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for constants.]]></description>
            <content><![CDATA[      /*-----------*\
    ====** Constants **========================================================
        \*-----------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251888677777"
              label="Attributes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for attributes.]]></description>
            <content><![CDATA[      /*------------*\
    ====** Attributes **=======================================================
        \*------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179436656"
              label="Static Initialisations"
              largeicon="" smallicon="">
            <description><![CDATA[The header comment for the static initialisations part]]></description>
            <content><![CDATA[        /*------------------------*\
    ====** Static Initialisations **===========================================
        \*------------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180117906"
              label="Constructors"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the constructors part]]></description>
            <content><![CDATA[    	/*--------------*\
    ====** Constructors **=====================================================
        \*--------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180168796"
              label="Methods"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the methods part]]></description>
            <content><![CDATA[    	/*---------*\
    ====** Methods **==========================================================
        \*---------*/
]]></content>
        </item>
    </category>
</snippets>
\end{lstlisting}

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJConfiguration}
tbd

\section{Embedded Code}
Sometimes, it is necessary to embed code inside the Java source code. Most often, these are SQL statements, but sometimes it could be also fragments of HTML or XML documents.

\subsection{Formatting SQL inside Java}\label{sec:FormattingSQLInsideJava}

\subsection{Formatting XML inside Java}\label{sec:FormattingXMLInsideJava}
You should embed only small fragments of an XML document into the Java source; larger fragments and full documents can be handled better when provided as resources.

\subsection{Formatting HTML inside Java}\label{sec:FormattingHTMLInsideJava}
Same as for XML, also only small HTML fragments should be embedded into the Java source code. Anything else should go into a resource file.

\section{Examples}\label{sec:Examples}

\subsection{AutoLock}\label{sec:AutoLock}
This class is a sample implementation of the idea described in chapter \tqfullvref{sec:Lifecycle}, like a PoC; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={AutoLock.java}]
package org.tquadrat.util.concurrent;

import static java.util.Objects.requireNonNull;
import java.util.concurrent.locks.Lock;

/**
 *  A wrapper for locks that supports the {@code try-with-resources}
 *  feature of Java 7.
 *  The creation of the local reference to the wrapper object means
 *  some overhead but in very most scenarios this is negligible.
 *
 *  {@code AutoLock} will only expose the methods
 *  {@link #lock()}
 *  and
 *  {@link #lockInterruptibly()}
 *  of the interface
 *  {@link java.util.concurrent.locks.Lock Lock},
 *  but with a return value. Exposing other methods is not
 *  reasonable.
 *  Calling
 *  {@link #close()}
 *  on the {@code AutoLock} instance or
 *  {@link Lock#unlock()}
 *  on the wrapped {@code Lock} object inside the {@code try} block
 *  may cause unpredictable effects.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 *
 *  @see java.util.concurrent.locks.Lock
 */
public class AutoLock implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The wrapped lock.
     */
    private final Lock m_Lock;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code AutoLock} object.
     *
     *  @param  lock    The wrapped lock.
     */
    public AutoLock( final Lock lock )
    {
        m_Lock = requireNonNull( lock );
    }   //  AutoLock()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  {@inheritDoc}
     */
    @Override
    public final void close() { m_Lock.unlock(); }

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lock() lock()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     */
    public final AutoLock lock()
    {
        m_Lock.lock();

        //---* Done *------------------------------------------------
        return this;
    }   //  lock()

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lockInterruptibly()
     *  lockInterruptibly()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     *  @throws InterruptedException The current thread was
     *      interrupted while acquiring the lock (and interruption
     *      of lock acquisition is supported).
     */
    public final AutoLock lockInterruptibly() 
        throws InterruptedException
    {
        m_Lock.lockInterruptibly();
        
        //---* Done *------------------------------------------------
        return this;
    }   //  lock()
}
//  class AutoLock
\end{lstlisting}

\subsection{Patch Identification}\label{sec:PatchIdentification}

\chapter{-------------------------------------------- Proceed from here!}
The annotations \lstinline|@BUG| and \lstinline|@FixList| are part of the Foundation Base project\autocite{TQUADRAT_ORG_FOUNDATION_BASE}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={FixList.java}]
package org.tquadrat.foundation.annotation;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.MODULE;
import static java.lang.annotation.ElementType.PACKAGE;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.RECORD_COMPONENT;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.TYPE_PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 *  The annotation container for
 *  {@link BUG &#64;BUG}
 *  annotations.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
@Documented
@Retention( RUNTIME )
@Target( {ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, MODULE, PACKAGE, PARAMETER, RECORD_COMPONENT, TYPE, TYPE_PARAMETER, TYPE_USE} )
public @interface FixList
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  Provides the list of
     *  {@link BUG &#64;BUG}
     *  annotations.
     *
     *  @return The annotations.
     */
    public BUG [] value();
}
//  @interface FixList
\end{lstlisting}

\begin{lstlisting}[numbers=left,caption={BUG.java}]
package org.tquadrat.foundation.annotation;

import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
import static java.lang.annotation.ElementType.CONSTRUCTOR;
import static java.lang.annotation.ElementType.FIELD;
import static java.lang.annotation.ElementType.LOCAL_VARIABLE;
import static java.lang.annotation.ElementType.METHOD;
import static java.lang.annotation.ElementType.MODULE;
import static java.lang.annotation.ElementType.PACKAGE;
import static java.lang.annotation.ElementType.PARAMETER;
import static java.lang.annotation.ElementType.RECORD_COMPONENT;
import static java.lang.annotation.ElementType.TYPE;
import static java.lang.annotation.ElementType.TYPE_PARAMETER;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

import java.lang.annotation.Documented;
import java.lang.annotation.Repeatable;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 *  This annotation allows to add information about applied fixes to 
 *  a program element.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
@API( status = STABLE, since = "0.1.0" )
@Documented
@Retention( RUNTIME )
@Target( {ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, MODULE, PACKAGE, PARAMETER, RECORD_COMPONENT, TYPE, TYPE_PARAMETER, TYPE_USE} )
@Repeatable( FixList.class )
public @interface BUG
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  An optional comment regarding the bug fix.
     *
     *  @return The comment.
     */
    String comment() default "";

    /**
     *  The BUG id as provided by the bug tracking system.
     *
     *  @return The BUG id.
     */
    String id();
}
//  @interface BUG
\end{lstlisting}

\subsection{PostProcessor}\label{sec:PostProcessor}
This implementation is basically a PoC; currently it is not part of any library.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={PostProcessor.java}]
package util;

import static java.util.Objects.requireNonNull;

/**
 *  Use this class to implement an uncoditional post-processing
 *  feature utilising try-with-resources.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public class PostProcessor implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The action.
     */
    private final Runnable m_Action;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code PostProcessor} object.
     *
     *  @param  action  The action that has to executed.
     */
    public PostProcessor( final Runnable action )
    {
        m_Action = requireNonNull( action );
    }   //  PostProcessor()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  Calls the
     *  {@link Runnable#run() run()}
     *  method of the
     *  {@linkplain #m_Action action}.
     *
     *  @see java.lang.AutoCloseable#close()
     */
    @Override
    public void close() throws Exception { m_Action.run(); }
}
//  class PostProcessor
\end{lstlisting}

\subsection{UnsupportedEnumError}\label{sec:UnsupportedEnumError}
This implemenation of \lstinline|java.lang.Error| is meant to be used in the \lstinline|default| branch of a \lstinline|switch| statement (refer to \tqfullvref{sec:SwitchStatements}), in cases where the selector is an enum.

It will be used like this:
\begin{lstlisting}[numbers=left]
enum Color
{
    RED, BLUE, GREEN, YELLOW
}

Color color = …    

// Traditional switch statement
switch( color )
{
    case RED: …; break;
    case BLUE: …; break;
    case GREEN: …; break;
    case YELLOW: …; break;

    default: throw new UnsupportedEnumError( color );
}

// New switch statement
switch( color )
{
    case RED -> …;
    case BLUE -> …;
    case GREEN -> …;
    case YELLOW -> …;

    default: throw new UnsupportedEnumError( color );
}

// switch expression
var result = switch( color )
{
    case RED -> "Rot";
    case BLUE ->"Blau";
    case GREEN -> "Grün";
    case YELLOW -> "Gelb";

    default: throw new UnsupportedEnumError( color );
}
\end{lstlisting}

Also refer to \autocite{TQUADRAT_ORG_FOUNDATION_UNSUPPORTEDENUMERROR}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left,caption={UnsupportedEnumError.java}]
package org.tquadrat.foundation.exception;

import static org.tquadrat.foundation.lang.Objects.requireNonNullArgument;
import static org.tquadrat.foundation.lang.Objects.requireNotEmptyArgument;
import static org.tquadrat.foundation.lang.internal.SharedFormatter.format;

import java.io.Serial;

/**
 *  This is a specialized implementation for
 *  {@link Error}
 *  that is to be thrown especially from the {@code default} branch
 *  of a {@code switch} statement that uses an {@code enum} type as
 *  selector.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public final class UnsupportedEnumError extends Error
{
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    /**
     *  The message text.
     */
    private static final String MSG_UnsupportedEnum = "The value '%2$s' of enum class '%1$s' is not supported";

        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The serial version UID for objects of this class: {@value}.
     *
     *  @hidden
     */
    @Serial
    private static final long serialVersionUID = 1174360235354917591L;

        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new instance of this class.
     *
     *  @param  <T> The type of the enum.
     *  @param  value   The unsupported value.
     */
    public <T extends Enum<T>> UnsupportedEnumError( final T value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( value, "value" ).getClass().getName(), value.name() ) );
    }   //  UnsupportedEnumError()

    /**
     *  Creates a new instance of this class.
     *
     *  @param  type    The class of the enum.
     *  @param  value   The unsupported value.
     */
    public UnsupportedEnumError( final Class<? extends Enum<?>> type, final String value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( type, "type" ).getName(), requireNotEmptyArgument( value, "value" ) ) );
    }   //  UnsupportedEnumError()
}
//  class UnsupportedEnumError

/*
 *  End of File
 */
 \end{lstlisting}

\listoftables

\lstlistoflistings

\printbibliography

\printindex
\end{document}
