\RequirePackage{lmodern}
\documentclass[12pt,a4paper,titlepage,parskip=half, headsepline, footsepline, cleardoubleplain]{scrbook}
\usepackage[T1]{fontenc}
\usepackage{scrhack}
\usepackage[utf8]{inputenc}
\usepackage{tocbasic}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{eurosym}
\usepackage{ragged2e}
\usepackage{textcomp}
\usepackage{framed}
\usepackage{ltxtable}
\usepackage{filecontents}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage[table,gray]{xcolor}
\usepackage{listings}
\usepackage[inline]{enumitem}
\usepackage{varioref}
\usepackage[iso,english]{isodate}
%\usepackage[babel]{csquotes}
\usepackage[style=numeric,urldate=iso8601]{biblatex}
\addbibresource{JavaCodingConventions.bib}

\lstset{
language=Java,
backgroundcolor=\color[gray]{.9},
frame=single,
framerule=0.2pt,
basicstyle=\ttfamily\footnotesize\bfseries,
commentstyle=\color[gray]{.2}\bfseries,
keywordstyle=\color[gray]{.2},
xleftmargin=.2cm,
xrightmargin=.2cm,
breaklines=true,
breakatwhitespace=true,
inputencoding=utf8,
extendedchars=true,
literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
  {©}{{\copyright}}1
  {…}{{\dots}}1
}

\colorlet{shadecolor}{gray!10}

\begin{document}
\isodate
\titlehead{Logo}
\author{Thomas Thrien\\(thomas.thrien@tquadrat.org)}
\title{Extended Coding Conventions for Java}
\date{}
\maketitle
\tableofcontents

\chapter{Introduction}

\begin{quotation}
“Everybody can write code that can be read by a computer,
but only good developers will write code that can be read by humans.”
\autocite{Fowler:Refactoring}
\end{quotation}

From a magazine dealing with software development tools, I found the following statement:

\begin{quotation}
“If you compare software development with the Apollo program, most programmers would be very successful bringing man to the moon, but never will get them back alive because of their common incapability to deliver software that can be maintained over a longer period of time with reasonable costs.”
\end{quotation}

Coding Conventions are primarily rules that should help making code better to maintain. Usually, this starts with making it more readable. Obviously, “readability” is a relative term, depending from one's habit. So some people are more familiar with the Kernighan-Ritchie (K\&R) style

\begin{lstlisting}
public void method (){
    if (flag) {
        …
    }
}
\end{lstlisting}

as it is also shown in the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS}, other prefer to have the curly braces on a line of their own (sometimes referred to as GNU or BSD style\footnote{All, BSD, GNU and K\&R styles, will define more than just how to place the curly braces. In addition, all three are originally code conventions for programming in C and/or C++ that cannot applied to Java without modifications. See chapter~\ref{sec:OtherProgrammingLanguages} on this topic.}):

\begin{lstlisting}
public void method()
{
    if( flag )
    {
    	…
    }
}
\end{lstlisting}

Both styles will work, but they look different. So as a lot of other rules from a code conventions document, too, this is a matter of taste (but refer to chapter \vref{sec:IndentationStyle}).

Nevertheless, the main purpose of those rules is to ensure that all source code looks familiar to all members of the team. As a side effect, such a look identifies source code as written by the team, as its trademark.

But there are more practical reasons to enforce these rules on the source: they make it easier …
\begin{itemize}[nosep]
\item … to understand the code
\item … to navigate inside the code
\item … to detect bugs
\item … to fix these bugs
\item … and to amend and enhance the code.
\end{itemize}

It can make it also easier to use automated tools on the source code.

All this is important because most of the lifetime cost of a piece of software is going into maintenance – some sources say 80 to 90\% – and nearly no source is maintained by its original author or even a single programmer for its whole lifetime.

The base of the coding conventions presented in this document are the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS} we have already mentioned above, but with some changes and enhancements that seemed necessary or at least useful to me.

\section{About this Document}
The document itself consists of four major parts: first we want to talk about proper formatting of the source files, next it covers the naming of the program elements before I discuss some guidelines for writing proper comments. The final chapter before the appendices will cover general coding rules.

The code samples in this document should underline some particular aspect or demonstrate a single rule or recommendation; to stay focused on that purpose, and to keep the samples at a reasonable length, they may often hurt other rules or ignore other recommendations. For instance, in most cases, methods are lacking the required comments, or the names are not really meaningful. In addition, some rules or recommendations are first used in the samples \textit{after} being introduced.

For source code samples that obey all rules and follow all recommendations, refer to chapter~\vref{sec:Examples}.

All rules and recommendations assume that at least Java~17 is used to write the code. I used that version also for the samples.

\section{History and Implementation}
I compiled a first version of this document around the year 2000, based on the way I wrote Java code at that time. I was asked to do so for a team of developers that had been new to Java (and to programming …).

Later versions were created for other developer teams, and several software products had been created successfully following these coding conventions – proving my initial statement that coding conventions help to create maintainable software. Some of the code written by the various teams is still running, after 20 twenty years now, another code is live since 12 years now.

I wrote some libraries that supports some of the rules and recommendations, in particalur those mentioned in chapter~\ref{sec:CodingRules}, starting on page~\pageref{sec:CodingRules}. If interested, have a look to \autocite{TQUADRAT_ORG}.

\section{Other Programming Languages}\label{sec:OtherProgrammingLanguages}
Of course coding conventions like those described with this document are not only useful for Java programs, but for code in any other programming language also.\footnote{Even for descriptive languages like XML and HTML they make sense, also for documents written in TeX/LaTeX.} But each language has its unique features and specialities, meaning that coding conventions written for one programming language do not necessarily match the requirements for another.

Obviously there are some common rules that are valid for every language, but usually the differences will outweigh the similarities. So it is not a good idea to do something in language \verb#A# just and only it is done that way in language \verb#B#. On the other side, it should always be proved, if something that worked fine for one language would not be a great idea to be applied to code in another language. A good example for that is the JavaDoc style commenting that was adopted for various other languages, too, including so different specimen as C/C++, JavaScript and PL/SQL.\footnote{Although we have to confess that the commenting style is not part of the specification of these languages but only supported by external tools.}

But no matter what programming language is used: The \textit{Basic Rule} as defined in chapter~\ref{sec:TheBasicRule} below will be applicable to each!

A sample for code conventions for JavaScript can be found in the web at \autocite{JAVASCRIPT_CODE_CONVENTIONS}.

In \vref{sec:FormattingSQLInsideJava} we have added some rules on how to format SQL statements when added as literals into a Java program.

\section{Code Generators}
Java code that is automatically generated by another piece of software should implement this coding conventions in the same way as “hand crafted” code. Most generators are highly configurable and/or allow to use code templates that are customisable.\footnote{Perhaps you want to have a look to \autocite{TQUADRAT_ORG_FOUNDATION_JAVACOMPOSER}}

Especially if base classes will be generated it is important that proper comments are generated at least for all API elements; this means all public and protected elements, and in some cases all package-local elements, too.

Since Java~6 there is an annotation \lstinline|javax.annotation.Generated| (\lstinline|@Generated|) that should be used to mark generated code. Refer to \autocite{ORACLE_DOC_GENERATED_ANNOTATION} for the details.\footnote{In case still Java~5 is used as the source code version, it should be considered to create an own \lstinline|@Generated| annotation along the lines given by the existing one.}

\section{Programming for Sustaining}
And what to do with “legacy” code that has to be fixed?

Most probably that code will not follow this coding conventions (if any at all …), and it is rarely a good idea to reformat or rewrite it completely just to align it with the conventions. Instead a fix should be limited to the area that is broken.

But if possible, the fix should incorporate the standards defined by this document. Be creative how to implement the standards defined here. So if a method has to be reimplemented completely, format it as described here and add the JavaDoc comments. Or if a new field has to be added to a class, add the \lstinline|m_| prefix to its name (see chapter~\ref{sec:Fields}).

Obviously, completely new interfaces and classes should be implemented fully compliant to this conventions.

\section{Tool Support}
Several of the rules and recommendations can be implemented through the configuration of the programming enviroment that is used, especially those from chapter~\ref{sec:FormattinOfTheSourceCode} that deals with the formatting of the source code.

The chapter \ref{sec:IDEConfiguration} provides some configuration samples for Eclipse and JetBrains IntelliJ IDEA.

\section{The Basic Rule}\label{sec:TheBasicRule}
One rule should be followed before any other rule or recommendation given in this document:

\begin{center}
\begin{huge}
\fbox{\textbf{Always do it right in the first place!}}
\end{huge}
\end{center}

Experiences with lots of programming projects has shown that programmers seldom touch their code again, once it is written.\footnote{Usually, they will return to the code only when it is broken – and then the want to fix the bug, not adding missing comments …} As a result, missing comments will never be added, shady programming patterns would not be fixed – with the consequence that in case of a bug the maintainer is lost in a poorly documented chaos of badly formatted source code.

\textit{And this is exactly what we want to avoid!} 

This means there is never ever any excuse for omitting comments, using 'temporary' names or doing other 'funny' things. And we all know about the quick and dirty PoC that made it into a product without significant changes …

So again:

\begin{center}
\begin{huge}
\fbox{\textbf{Always do it right in the first place!}}
\end{huge}
\end{center}

\chapter{Formatting of the Source Code}\label{sec:FormattinOfTheSourceCode}
This chapter deals with the proper formatting of Java source code. The formatting of comments is covered in chapter~\vref{sec:WritingProperComments}.

I start the chapter with a description of the general structure of a source file, then I give some general conventions before I cover the formatting of single elements of the code.

\section{Java Source File Structure}
A file with Java source code consists of sections that should be separated by blank lines and a comment identifying each section.

Files longer than 2000 lines are cumbersome and should be avoided.\footnote{There are some well known scenarios where it is difficult to adhere with this limit. The first is with generated code, the other one is with classes having lots of attributes: the formatting style and coding rules proposed in this document require a least 5 lines for each attribute, 6 lines for each getter method and 11 lines for each setter method, always including all comments and blank lines. This is about 22 lines for each attribute. Nearly one hundred attributes seems to be a lot, but we have seen more than one real life application where database tables had more than that number of columns. We do not think that this is always a good design, but if our new Java class has to reflect the legacy data model, it has to have that number of attributes.}

Each Java source file contains a single public class or interface. When private top-level classes and interfaces are associated with a public class, they can be put into the same source file as the public class, although it is not recommended.\footnote{Usually, it should be considered to have these classes or interfaces as \textit{inner} classes/interfaces} In such a case, the public class should be the first class or interface in the file.

The sections of a Java source file have the following ordering:

\begin{enumerate}[nosep]
\item{Beginning comments}
\item{Package and import statements}
\item{Class and interface declarations}
\item{Closing comment}
\end{enumerate}

\subsection{Beginning Comments}\label{sec:BeginningComments}
All source files have begin with a c-style comment that gives the copyright notice and the license information:\footnote{This is different from \autocite{SUN_CODE_CONVENTIONS}; the Sun coding conventions recommend to put also the class name and the date into the beginning comment. I omitted the name of the class because this is obvious from the file name in case of a public class, and it would confuse the reader if the file contains more than one class. The date is considered obsolete.}
\begin{lstlisting}[numbers=left]
/*
 * ==================================================================
 * Copyright © <Year> <Copyright Notice>
 * ==================================================================
 *
 * <License Notice>
 */
\end{lstlisting}
 
<Year>, <Copyright Notice> and <License Notice> has to be replaced by the appropriate texts.\footnote{The special character \copyright is used not only because is looks better; it tells you immediately whether your environment is capable to deal with UTF-8 encoded files.}

The lines with the equals signs (“===”) will end at column 80; refer to chapter~\vref{sec:LineLength}.

No other information should be added to this comment block.

\subsection{Package and Import Statements}

The first non-comment line of a Java source file is the \lstinline|package| statement\footnote{Production code will never use the default package, so there will be always a \lstinline|package| statement in every source file.}.

After that, usually several \lstinline|import| statements will follow. For example:

\begin{lstlisting}
package java.awt;

import static java.lang.String.format;
import static java.lang.System.out;
…

import java.awt.peer.CanvasPeer;
import java.io.InputStream;
…
\end{lstlisting}

Static imports has to be placed before imports for classes. Inside these blocks, the imports should be ordered alphabetically. Wildcard imports like

\begin{lstlisting}
import static java.lang.String.*;
…

import java.util.*;
…
\end{lstlisting}

are not allowed.

For the names of packages, see chapter~\vref{sec:Packages}.

Eclipse users can use the function \verb#Source|Organize Imports# from the menu, or the short-key \verb#Shift+Ctrl+O#. This will reorder the import statements, explode the wildcards and remove unused imports; it will even add currently missing imports – given that this properly configured in the \verb#preferences# at \verb#Java|Code Style|Organize Imports#.

At IntelliJ~IDEA, the function \verb#Code|Optimize Imports# from the menu does something similar; the short key would be \verb#Ctrl+Alt+O#.

\subsection{Class and Interface Declarations}\label{sec:ClassAndInterfaceDeclarations}
At least since Java~5, there are not only classes and interfaces that are declared in a Java source file. We have

\begin{itemize}[nosep]
\item{classes (keyword \lstinline|class|)}
\item{interfaces (keyword \lstinline|interface|)}
\item{enums (keyword \lstinline|enum|)}
\item{records (keyword \lstinline|record|)}
\item{annotations (keyword \lstinline|@interface|)}
\end{itemize}

Each of these allows different parts in their declaration; the following tables describe the various parts and the order that they should appear in the files. Each part has a header comment, and inside each part, the elements are ordered alphabetically.

\subsubsection{Class}
A skeleton for a Java \lstinline|class| may look like this:
\begin{lstlisting}
public class MyClass 
{
        /*---------------*\
    ====** Inner Classes **==========================================
        \*---------------*/
    …    
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
            
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …            
}
//  class MyClass
\end{lstlisting}
 
\begin{filecontents}{ClassParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of a class declaration} \\
  \hline 
  Part & Description \\ 
  \hline\endfirsthead
  \caption{Parts of a class declaration (continued} \\
  \hline 
  Part & Description \\ 
  \hline\endhead
  Inner Classes (optional) & Given the class defines inner classes or interfaces, either \lstinline|private| or \lstinline|public|, they will come first. Internally, they will follow the same rules as their containing classes. \\ 
  \hline 
  Constants (optional) & This part takes all constants defined by this class (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here go the attributes for the class; technically, this part is in fact optional for a class, but usually a class without any attributes does not make much sense. Attributes are \lstinline|private| (under some exceptional circumstances, they can be \lstinline|protected|) and usually, they are not \lstinline|static|. \\ 
  \hline 
  Static Initialisations (optional) & If a class declares \lstinline|static| fields that are not mere constants or their initialisation is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block.
  
  This is also the right place for the serialVersionUID of a seria­lisable class. \\ 
  \hline 
  Constructors (optional) & All the constructors for the class go into this part. It is optional in case the class will have only an empty \lstinline|public| default constructor, but usually this will be coded, too. \\ 
  \hline 
  Methods (optional) & All methods of the class are in this part. Again, this part is technically optional, but classes without methods are barely useful.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{ClassParts.tbl}

\subsubsection{Interface}
A skeleton for an \lstinline|interface| may look like this:
\begin{lstlisting}
public interface MyInterface 
{
        /*---------------*\
    ====** Inner Classes **==========================================
        \*---------------*/
    …
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  interface MyInterface
\end{lstlisting}
 
\begin{filecontents}{InterfaceParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an interface declaration} \\
  \hline 
  Part & Description \\ 
  \hline\endfirsthead
  \caption{Parts of an interface declaration (continued} \\
  \hline 
  Part & Description \\ 
  \hline\endhead
  Inner Classes (optional) & Defining inner classes for an interface is discouraged, although there are some valid use cases for this. If the interface defines inner classes or interfaces, they have to be \lstinline|public| – classes have to be \lstinline|static|, too, and they will be the first part. Internally, they will follow the same rules as for top-level classes. \\ 
  \hline 
  Constants (optional) & This part takes all constants defined by this class (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time. \\ 
  \hline 
  Methods (optional) & All methods of the interface are in this part. Again, this part is technically optional, it can be omitted for so-called \textit{marker interfaces}.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{InterfaceParts.tbl}

\subsubsection{enum}
An \lstinline|enum| is a special case of a Java \lstinline|class|. Usually it only contains the enumeration values, but it can have more components. A skeleton for a \lstinline|enum| may look like this:
\begin{lstlisting}
public enum MyEnum 
{
        /*------------------*\
    ====** Enum Definitions **=======================================
        \*------------------*/
    …
        
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
        
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  enum MyEnum
\end{lstlisting}
 
\begin{filecontents}{EnumParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an enum declaration} \\
  \hline 
  Part & Description \\ 
  \hline\endfirsthead
  \caption{Parts of an enum declaration (continued} \\
  \hline 
  Part & Description \\ 
  \hline\endhead
  Enum Definitions & This part is mandatory. Each \lstinline|enum| is an instance of the enum class. \\ 
  \hline 
  Constants (optional) & This part takes all additional constants defined by this enum (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here goes the attributes for the enum, if any. Each attribute has to be \lstinline|private final| and will be initialised by the constructor. \\ 
  \hline 
  Static Initialisations (optional) & If an enum declares \lstinline|static final| fields with an initialisation that is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block. \\
  \hline 
  Constructors (optional) & All the constructors for the enum (rarely there is more than one) go into this part, if any. A constructor has to \lstinline|private|. \\ 
  \hline 
  Methods (optional) & All methods of the class are in this part.  \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{EnumParts.tbl}

\subsubsection{Record}
Records had been introduced to Java with version~14. Like an enum, a record is a restricted form of a Java class. It’s ideal for “plain data carriers” classes that contain data not meant to be altered and has only the most fundamental methods such as constructors and accessors.\autocite{ORACLE_DOC_RECORD}

A skeleton for a Java \lstinline|record| may look like this, with all parts being optional:
\begin{lstlisting}
public record MyClass( ... ) 
{
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    …
        
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
        
        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    …
        
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    …
        
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    …
                
}
//  record MyRecord
\end{lstlisting}
 
\begin{filecontents}{RecordParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of a record declaration} \\
  \hline 
  Part & Description \\ 
  \hline\endfirsthead
  \caption{Parts of a record declaration (continued} \\
  \hline 
  Part & Description \\ 
  \hline\endhead
  Constants (optional) & This part takes all constants defined by this record (meaning \lstinline|public final| and \lstinline|public static final| fields). All values for the constants are known at compile time, otherwise you should place the respective field to the \textit{Static Initialisations} part. \\ 
  \hline 
  Attributes (optional) & Here go the attributes for the class; this part is optional, because usually, all attributes are defined as arguments to the \lstinline|record| definition. \\ 
  \hline 
  Static Initialisations (optional) & If a record declares \lstinline|static| fields that are not mere constants or their initialisation is more complex than just assigning a compile time constant, these fields go into this part.
  
  The fields should be initialised in a \lstinline|static {...}| block. \\ 
  \hline 
  Constructors (optional) & If the record needs additional constructors, these go into this part. It is optional, because in most cases no additional constructor is need. \\ 
  \hline 
  Methods (optional) & All additional methods of the record are in this part. \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{RecordParts.tbl}

\subsubsection{Annotation}
Annotations had been introduced with Java~5. 
A skeleton for an \lstinline|annotation| may look like this:
\begin{lstlisting}
public @interface MyAnnotation 
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    …
                
}
//  @interface MyAnnotation
\end{lstlisting}
 
\begin{filecontents}{AnnotationParts.tbl}
  \begin{longtable}{|l|X|}
  \caption{Parts of an annotation declaration} \\
  \hline 
  Part & Description \\ 
  \hline\endfirsthead
  \caption{Parts of an annotation declaration (continued} \\
  \hline 
  Part & Description \\ 
  \hline\endhead
  Attributes (optional) & Here go the attributes for the annotation, if any. \\ 
  \hline 
 \end{longtable} 
\end{filecontents}
\LTXtable{\linewidth}{AnnotationParts.tbl}

\subsection{Closing Comment}
A closing comment like
\begin{lstlisting}
/*
 *  End of File
 */
\end{lstlisting}
at the end of the source file is helpful to detect whether a source file was corrupted: if missing, there is a good chance that the file is incomplete.

I confess that this kind of error has got very unlikely with modern hard-drives, but it can still happen when sending around sources over the net.

\section{Indentation}
Indentation, together with empty lines, is the most important tool to structure any source code.

\subsection{Indentation Style}\label{sec:IndentationStyle}
I prefer the so-called GNU or BSD style and recommend it to you as well, because it makes it easier to detect the begin and the end of a code block. It demands to have the opening and closing curly braces on a line of their own, like this:

\begin{lstlisting}
public class MyClass
{
    public void method()
    {
        if( flag )
        {
            /* do something */
        }
        
        for( final var i = 0; i < max; ++i )
        {
            /* do something else */
        } 
    }   //  method()
}   //  class MyClass
\end{lstlisting}

\subsection{Indentation Size}
Four (4) spaces should be used as the unit of indentation. Tabs are not allowed.\footnote{This is different from \autocite{SUN_CODE_CONVENTIONS}; the Sun Coding Convention do not explicitly specify whether to use blanks or tabs.} Usually this can be configured in your IDE; in Eclipse this is part of the \textit{Formatter} definition (\verb#Window|Preferences|Java|Code Style|Formatter#).

\subsection{Line Length}\label{sec:LineLength}
Some sources (including the “Code Conventions for the Java\textsuperscript{TM} Programming Language” \autocite{SUN_CODE_CONVENTIONS}) recommend to avoid lines longer than 80 characters, because they were not handled well by many terminals and tools.

This had been true at the time those documents were written, but today's  graphical screens are much wider (sometimes even 200 characters can be put into one line), and modern tools do not even care about line length, so we do not want to recommend a fixed line length for source code.

\textbf{Note:} Sample code for use in documentation should have a limited line length – generally not more than 70 characters.

Different to that, comment lines are limited to 80 characters – or more precise, they have to end at column 80. All lines with “ASCII graphics” are extented to that column. This is pertaining to the beginning comments (chapter \vref{sec:BeginningComments}), the structuring comments (chapter \vref{sec:StructuringComments}) and most single-line comments (chapter \ref{sec:SingleLineComments}).

\subsubsection{Wrapping Lines}\label{sec:WrappingLines}
When an expression does not fit on a single line, break it according to these general principles:
\begin{itemize}[nosep]
\item{Break after a comma.}
\item{Break before an operator.}
\item{Prefer higher-level breaks to lower-level breaks.}
\item{Align the new line with the beginning of the expression at the same level on the previous line.}
\item{If the above rules lead to confusing code or to code that's squished up against the right margin, just indent 8 (eight) spaces instead.}
\end{itemize}

Here are some examples of breaking method calls:
\begin{lstlisting}[numbers=left]
// USUAL
someMethod( longExpression1, longExpression2, longExpression3,
    longExpression4, longExpression5 );
        
// SINGLE LINE FOR EACH ARGUMENT
someMethod
( 
    longExpression1,
    longExpression2,
    longExpression3,
    longExpression4, // some comment
    longExpression5
);

// LONG EXPRESSIONS
var = someMethod1( longExpression1,
        someMethod2( longExpression2,
                longExpression3 ) );
\end{lstlisting}

Using a single line for each argument makes especially sense in cases where one or more expressions are really long, or if a comment should be added to the argument.

Next there are two examples of breaking an arithmetic expression. The first is preferred, since the break occurs outside the parenthesized expression, which is at a higher level.
\begin{lstlisting}[numbers=left]
// PREFER
longName1 = longName2 * (longName3 + longName4 - longName5)
           + 4 * longname6;
           
// AVOID!!!           
longName1 = longName2 * (longName3 + longName4
                       - longName5) + 4 * longname6;
\end{lstlisting}

Then we have three examples of indenting method declarations. The first is the conventional case. The second would shift the second and third lines to the far right if it uses conventional indentation, so instead it indents only 8 spaces. The final one uses a single line for each argument.

A throws clause will be either appended on the same line as the closing parentheses, or it can be on its own line with an indentation of four blanks.
\begin{lstlisting}[numbers=left]
// CONVENTIONAL INDENTATION
public void someMethod( int anArg, Object anotherArg,
    String yetAnotherArg, Object andStillAnother )
{
    …
}

public void otherMethod( int anArg, Object anotherArg,
    	String yetAnotherArg, Object andStillAnother )
    throws IllegalArgumentException, IOException
{
    …
}

// INDENT 8 SPACES TO AVOID VERY DEEP INDENTS
private static synchronized void horkingLongMethodName( int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother )
{
    …
}

private static synchronized void horkingLongMethodThrows( int anArg,
        Object anotherArg, String yetAnotherArg,
        Object andStillAnother ) throws IllegalArgumentException
{
    …
}

// SINGLE LINE FOR EACH ARGUMENT
private static synchronized anotherHorkingLongMethodLine
(
    int anArg,
    Object anotherArg,
    String yetAnotherArg,
    Object andStillAnother
)
{
    …
}

private static synchronized anotherHorkingLongMethodLineThrows
(
    int anArg,
    Object anotherArg,
    String yetAnotherArg,
    Object andStillAnother
) throws IllegalArgumentException, IOException
{
    …
}
\end{lstlisting}

Here are three acceptable ways to format ternary expressions\footnote{Read more about the ternary operator \lstinline|?| in chapter \vref{sec:TheTernaryOperator}.}:
\begin{lstlisting}[numbers=left]
alpha = (aLongBooleanExpression) ? beta : gamma;
alpha = (aLongBooleanExpression) ? beta
                                 : gamma;
alpha = (aLongBooleanExpression)
        ? beta
        : gamma;
\end{lstlisting}

\section{Declarations}
This chapter deals with the formatting of declarations. See also chapter \vref{sec:WrappingLines} for informations on how to wrap long declarations.

\subsection{Multiple Declarations per Line}
It is strongly encouraged to have only one declaration per line, as it is also comforting to add comments to the declaration. In other words, 
\begin{lstlisting}
int level; // indentation level
int size;  // size of table
\end{lstlisting}

is preferred over

\begin{lstlisting}
// AVOID!!!
int level, size;
\end{lstlisting}

Do not put different types on the same line, despite the compiler does not complain about it. Example:
\begin{lstlisting}
// WRONG!!!!
int foo, fooarray [];
\end{lstlisting}

\subsection{Array Declarations}
The brackets for an array declaration always have to be put to the type, not to the name. So it should read
\begin{lstlisting}
int [] foo;
String [] bar;
java.awt.Button [] buttons;
\end{lstlisting}
and not
\begin{lstlisting}
// AVOID!!!
int foo [];
// AVOID!!!
String bar [];
// AVOID!!!
java.awt.Button buttons [];
\end{lstlisting}
This is the same way as an array would be declared as the return value for a method:
\begin{lstlisting}
public final static String [] getTexts()
{
    return m_Texts;
}	//	getTexts()
\end{lstlisting}

\subsection{Placement of Declarations}
You should put declarations where there are needed; usually this means that it should be waited with the declaration of variables until their first use.\footnote{In this aspect, my point of view is completely contradicting to that of the authors of \autocite{SUN_CODE_CONVENTIONS}.}

This is true even for variables inside a loop:
\begin{lstlisting}
for( var i = 0; i < limit; ++i )
{
    final var a = getValue( i );
    …
}
\end{lstlisting}

Only the repeated initialisation of a variable inside a loop should be avoided, when possible:
\begin{lstlisting}[numbers=left]
// AVOID!
for( var i = 0; i < limit; ++i )
{
    final var a = new VeryComplexType();
    …
}
\end{lstlisting}
In this case, line~4 should be moved before the loop header (line~2).

Absolutely avoid local declarations that hide declarations at higher levels. For example, do not declare a variable with the same name as a field:
\begin{lstlisting}
public class MyClass
{
    int count;

    public void method()
    {
        if( condition )
        {
            int count = 0; // AVOID!
            // more code
        }
        // more code
    }
}   //  class MyClass
\end{lstlisting}
There are a settings for both Eclipse preferences and IntelliJ~IDEA that triggers a warning or even an error in such cases. In addition, the rules for the naming of fields (refer to chapter \vref{sec:Fields}) would make such a situation unlikely.

\subsection{Class and Interface Declarations}
When coding Java classes and interfaces, the following formatting rules has to be followed:
\begin{itemize}
\item{No space between a method or constructor name and the parenthesis “(” starting its formal parameters list.}
\item{If using generics, no space between the name of the class or interface and the opening “<”.}
\item{An open curly brace “{” appears at a line by itself with the same indentation as the declaration statement.}
\item{A closing curly brace “}” starts a new line, indented to match its corresponding opening statement; in case of a method or constructor declaration, it is followed by a comment with the name of the method. For classes or interfaces, the name of the class or interface is repeated in a new line after the closing brace.}
\item{Inner classes, constants, attributes, constructors, methods, they all are separated by a blank line (see chapter \ref{sec:BlankLines}.}
\item{Short methods may be written in one single line. In this case, “one single line” means exactly that: \textit{one single} line! Any line break requires the full form as for the sample “composeCorrectKey()” below (line 28).}
\end{itemize}
An example:
\begin{lstlisting}[numbers=left]
class Sample extends Object implements Comparable<Sample>
{
    int ivar1;
    
    int ivar2;
    
    Sample( int i, int j ) 
    {
        ivar1 = i;
        ivar2 = j;
        …
    }  //  Sample()
    
    void method()
    {
        …
    }  //  method()
    
    // SHORT METHOD
    int getIVar1() { return ivar1; }
    
    // AVOID!!! Not a short method!
    String composeWrongKey( String component1, String component2,
                            String component3 ) { return component1
        + component2 + component3; }
        
    // Correct
    String composeCorrectKey( String component1, String component2,
                              String component3 )
    {
        return component1 + component2 + component3;
    }   //  composeCorrectKey()
}
//  class Sample
\end{lstlisting}

The comments at the end of the methods make it easier to navigate inside long source files, especially when scrolling upwards.

\section{White Space}
This chapter deals with the white space other than the indentation blanks.

\subsection{Blank Lines}\label{sec:BlankLines}
Blank lines improve readability by setting off sections of code that are logically related.
If not separated by an explicit comment, two blank lines should always be used in the following circumstances:
\begin{itemize}
\item{Between sections of a source file\footnote{Although this would hurt the rules for commenting as set in chapter \ref{sec:StructuringComments}}}
\item{Between class and interface definitions}
\end{itemize}

One blank line should always be used in the following circumstances:
\begin{itemize}
\item{Between methods}
\item{Before a block or single-line comment}
\item{Between logical sections inside a method to improve readability}
\item{To group some code lines logically}
\end{itemize}
More than one blank line should be avoided, except for the case mentioned above.

\subsection{Parenthesis}\label{sec:Parenthesis}
We distinguish between arithmetical parenthesis and parameter parenthesis; the first is used in expressions to order the terms, the latter is used with method or constructor calls or in lambdas.

\paragraph{Arithmetical Parenthesis}–
An opening arithmetical parenthesis is always preceded by a blank or another opening parenthesis and never followed by a blank, a closing one is never preceded by a blank, but always followed either by another closing parenthesis, a blank, or a newline (or a semicolon, in case the statement ends).

\paragraph{Parameter Parenthesis}\label{sec:ParameterParenthesis}–
An opening parameter parenthesis is never preceded by a blank and ever followed by one, while a closing one is always preceded by one. The only exception is for empty arguments lists where the opening parenthesis is immediately followed by the closing parenthesis.

Regarding to this rule, \lstinline|if|, \lstinline|for|, \lstinline|while|, \lstinline|try| and \lstinline|switch| are treated like functions (see also chapter \ref{sec:BlankLines}).\footnote{And also the keywords \lstinline|catch| and \lstinline|synchronized|, but they do not allow complex terms inside there 'argument list'.}

This rule can improve the readability of complex terms drastically, as the examples below will illustrate.

\begin{lstlisting}[numbers=left]
int v = (a + b) * 5;
double d = sin( (a + b) / c );
System.out.println( "Finished!" );
set( get() );
System.out.println( sin( ((a + b) * (c + 4) + c)) / d ) );
if( a < b ) c = (d + e) / sin( f );
while( ((line = reader.readLine()) != null) && (++i < capacity) )
    processLine( line );
\end{lstlisting}

\subsection{Blank Spaces}\label{sec:BlankSpaces}
Additionally, blank spaces should be used in the following circumstances:
\begin{itemize}
\item{With a keyword followed by a parenthesis, like \lstinline|if|, \lstinline|while|, \lstinline|for| etc. There is no blank space between the keyword and the opening parenthesis, but  between that parenthesis and the argument. Another blank space is between the (last) argument and the closing parenthesis. As a short it can be said that parenthesis for these keywords will be treated like parameter parenthesis, as already stated in \ref{sec:ParameterParenthesis}.\footnote{This is in opposite to the sun codeing conventions \autocite{SUN_CODE_CONVENTIONS}; there it is recommended to have a blank between the keyword and the opening parenthesis while not using it between the method name and the opening parenthesis here, just to distinguish between keywords and methods calls. We think that it is more important to distinguish between parenthesis in arithmetical expressions and those in method calls.}

Examples:
\begin{lstlisting}[numbers=left]
while( true )
{
    …
}

for( int i = 0; i < 10; ++i ) { … }

try
{
    …
}
catch( Exception e )
{
    e.printStackTrace();
}

if( list.isEmpty() ) { … }
\end{lstlisting}}
\item{A blank space has to appear after commas in argument lists. The exception are generics where the comma is not followed by a blank space in case there is more than one type.

Examples:
\begin{lstlisting}[numbers=left]
Map<String,String> map = new HashMap<String,String>();
Map<String,String> map = new HashMap<>(); // using the diamond operator
map.put( key, value );
\end{lstlisting}}
\item{All binary operators except “.” has to be separated from their operands by spaces. Blank spaces should never separate unary operators such as unary minus, increment (“++”), and decrement (“--”) from their operands.

Example:
\begin{lstlisting}[numbers=left]
a += c + d;
a = (a + b) / (c * d);

while( d-- > s++ )
{
    ++n;
}

printSize( "size is " + foo + "\n" );
\end{lstlisting}}
\item{The expressions in a \lstinline|for| statement has to be separated by blank spaces after the semicolon.

Example:
\begin{lstlisting}
for( expr1; expr2; expr3 )
{
    …
}
\end{lstlisting}

For an extended for loop, blank spaces has to be placed around the colon, too:
\begin{lstlisting}[numbers=left]
for( String s : stringArray ) System.out.println( s );
\end{lstlisting}}
\item{For ternary statements, the question mark (“?”) and the colon (“:”) has to be surrounded by blank spaces:

Example:
\begin{lstlisting}
int signum = d < 0 ? -1 : d > 0 ? 1 : 0;
\end{lstlisting}

In this sample, some parentheses would be helpful, too.}
\item{Casts should be followed by a blank space. 

Examples:
\begin{lstlisting}
method( (byte) aNum, (Object) x);
method( (int) (cp + 5), ((int) (i + 3)) + 1 );
\end{lstlisting}}
\end{itemize}

\section{Statements}
Now we will have a look on how to format statements.

\subsection{Simple Statements}
Each line should contain at most one statement. Or, the other way round, each (simple) statement has to be written to its own line.

Example:
\begin{lstlisting}
// CORRECT
++argv;
--argc;

// AVOID!!!
--argv; --argc;
\end{lstlisting}

\subsection{Compound Statements}\label{sec:CompoundStatements}
Compound statements are statements that contain lists of statements enclosed in curly braces “{ statements }”. See the following sections for examples.

Here some general rules first:
\begin{itemize}
\item{The enclosed statements should be indented one more level than the compound statement.}
\item{The opening brace should be at a line of itself, indented to the same level as the compound statement.
Accordingly, the closing brace should begin a line and be indented to the beginning of the compound statement. The exception are short methods where all is one line (refer to chapter \vref{sec:ClassAndInterfaceDeclarations})}.
\item{Braces are used around all statements (meaning even if there is just one) when they are part of a control structure, such as a \lstinline|if-else| or \lstinline|for| statement. This makes it easier to add statements without accidentally introducing bugs due to forgetting to add braces.

The only exception from this rule is when a single statement is written on the same line as the compound statement itself.

Examples:

\begin{lstlisting}[numbers=left]
// Ok
if( a < b ) c = d;

// AVOID!!!
if( a < b ) c = d; else e = f;
if( a < b )
    c = d;
if( a < b )
    c = d;
else
    e = f;

// RECOMMENDED
if( a < b )
{
    c = d;
}
else
{
    e = f;
}

// Ok
for( String s : strings ) ++i;

// AVOID!!!!
for( String s : strings )
    ++i;

// RECOMMENDED
for( String s : strings )
{
    ++i;
}

// DISCOURAGED!!!
for( String s : strings ) if( a < b ) c = d;
\end{lstlisting}

See also the chapters \ref{sec:IfStatements}, \ref{sec:SwitchStatement}, and \ref{sec:WhileStatements}.}

\item{Long compound statements (long code blocks) should get an end comment. See chapters \ref{sec:LabelsAndBreakStatements}, \ref{sec:TrailingOrEndOfLineComments}, and \ref{sec:CommentsWhen}.} 
\end{itemize}

\subsection{“Chaining”}
The interface for some classes allow to chain methods. If it is especially designed to allow this, it is referred to as the “Builder pattern”. Examples for this are \lstinline|java.lang.StringBuffer|, \lstinline|java.lang.StringBuilder|, and since Java~5, also \lstinline|java.io.Writer| and the classes derived from that class.

“Chaining” would allow to write

\begin{lstlisting}
writer.append( "Caption\t: " ).append( value );
\end{lstlisting}

instead of

\begin{lstlisting}
writer.append( "Caption\t: " );
writer.append( value );
\end{lstlisting}

The formatting rules are as follows:
\begin{itemize}
\item{If the “chain” does not fit completely into a single line, each method call has to be written into a single line of its own (as in line 4 below}
\item{The dot has to be written in front of the method's name}
\item{The methods will be indented regularly}
\end{itemize}

Some samples:
\begin{lstlisting}[numbers=left]
// Acceptable
writer.append( "Caption\t: " ).append( value );

// RECOMMENDED
writer.append( "Caption\t: " )
    .append( value );
    
// WRONG: The dot is trailing!
writer.append( "Caption\t: " ).
    append( value );
\end{lstlisting}

Java~8 introduced Streams and those will be formatted in the same way.

Example:
\begin{lstlisting}[numbers=left]
final var names = customers.stream()
    .filter( c -> c.getCountry().equals( GERMANY )
    .filter( c -> c.getTurnover() > limit )
    .map( Customer::getName )
    .sorted()
    .toArray( String []::new );
\end{lstlisting}

\subsection{return Statements}
A \lstinline|return| statement with a value should not use parentheses unless they make the return value more obvious in some way. Please see also chapter \vref{sec:ReturningValues}!
Example:
\begin{lstlisting}[numbers=left]
// Usually obsolete
return;

// NOT RECOMMENDED
return myDisk.size();

// MAY BE OK
return (m_Size > 0 ? m_Size : m_DefaultSize); 

// AVOID!!!
return( retValue );

// RECOMMENDED; usually the only valid form 
return retValue; 
\end{lstlisting}

\subsection{if, if-else, if-else-if-else Statements}\label{sec:IfStatements}
The chapters \ref{sec:Parenthesis}, \ref{sec:BlankSpaces}, and \ref{sec:CompoundStatements} covered already some aspects of the \lstinline|if-else| class of statements that may be repeated here again.

The base forms for this class of statements are the following ones:
\begin{lstlisting}[numbers=left]
if( <condition> )
{
    <statements>;
}

if( <condition>)
{
    <statements>;
}
else
{
    <statements>;
}

if( <condition1>)
{
    <statements>;
}
else if( <condition2>)
{
    <statements>;
}
else
{
    <statements>;
}
\end{lstlisting}

In case there are more conditions to check, but a switch statement cannot be used due to the data types involved or the logic for the conditions, use the form in line 15.

The only occasion where an if statement does not need the curly braces (“{}”) is when there is a single statement on the same line as the \lstinline|if| clause and there is no \lstinline|else| clause:

\begin{lstlisting}
if( <condition> ) <singleStatement>;
\end{lstlisting}

In any other case the curly brace are mandatory, to avoid the following error-prone forms:

\begin{lstlisting}[numbers=left]
// AVOID! MISSING CURLY BRACES {}!
if( <condition> )
    <statement>;

// AVOID!!! EVEN WORSE THAN ABOVE!!    
if( <condition> )
    <statement>;
else
    <statement>;
\end{lstlisting}

Please refer also to chapter \vref{sec:TheTernaryOperator} that discusses the ternary “?” operator.


\subsection{switch Statements}\label{sec:SwitchStatements}
Beginning with the first preview in Java~12, an alternative syntax for \lstinline|switch| was introduced, so that we have now two (in fact, three) different forms of that construct.

\subsubsection{The traditional Form of switch}
Originally, a \lstinline|switch| statement in Java looked like this:
\begin{lstlisting}[numbers=left]
switch( <selector> )
{
    case <switchlabel1>:
        <statements>;
        // Falls through!

    case <switchlabel2>:
        <statements>;
        break;

    case <switchlabel3>: <singleStatement>; break;

    case <switchlabel4>:
    {
        <statements>;
        break;
    }

    case <switchlabel5>: // Also a fall-through
    case <switchlabel6>:
    {
        <statements>;
        break;
    }

    default:
       <statements>;
       break;
}
\end{lstlisting}

If a \lstinline|case| falls through, as in line~4, a comment “\lstinline|// Falls through!|” as in the sample is mandatory! In fact, this construct should be avoided when possible, because it also forces a special sequence of the \lstinline|case| clauses – requiring an additional comment to the \lstinline|switch| itself.

Different to that, no comment is required in the case shown in the lines~19 and 20: here we have two case that triggers the \textit{exactly the same} action.

For longer \lstinline|switch| statements it is highly recommended to use a label with the \lstinline|break| statement\footnote{In fact, I recommend to use always a label with \lstinline|break|; see \ref{sec:LabelsAndBreakStatements} on this topic.}; this can look like this:
\begin{lstlisting}
final Color color;
ColorSelector: switch( colorIndex )
{
    case 1: color = RED; break ColorSelector;
    case 2: color = BLUE; break ColorSelector;
    case 3: color = YELLOW; break ColorSelector;
    case 4: color = GREEN; break ColorSelector;
    default: color = NONE; break ColorSelector;
}   //  ColorSelector:
\end{lstlisting}

The break in the default case is redundant, but it prevents a fall-through error if later another case is added – although it should be assured that the default case is always the last case in the switch statement. Of course no \lstinline|break| is required when the branch is left by throwing an exception.

\subsubsection{The new Form of switch}
The alternative syntax for \lstinline|switch| comes in two flavours and looks like this:

\begin{lstlisting}[numbers=left]
// switch statement
switch( <selector> )
{
    case <switchlabel1> -> <singleStatement>;

    case <switchlabel2>, <switchlabel3> -> <singleStatement>;

    case <switchlabel4> ->
    {
        <statements>;
    }

    case <switchlabel4>, <switchlabel5> ->
    {
        <statements>;
    }

    default -> <singleStatement>;
}

// switch expression
var result = switch( <selector> )
{
    case <switchlabel1> -> <expression>;

    case <switchlabel2>, <switchlabel3> -> <expression>;

    case <switchlabel4> ->
    {
        <expressions>;
        yield <value>;
    }

    case <switchlabel4>, <switchlabel5> ->
    {
        <expressions>;
        yield <value>;
    }

    default -> <expression>;
}
\end{lstlisting}

Of course the \lstinline|default| in line~18 can be followed by a statement block as the \lstinline|case| in line~8, and the \lstinline|default| in line~40 can have a complex expression like the \lstinline|case| in line~28.

If used with pattern matching (refer to \autocite{ORACLE_DOC_PATTERNMATCHING}), it looks like this:

\begin{lstlisting}[numbers=left]
var selector = <anObject>
// switch statement
switch( selector )
{
    case null -> <singleStatement>;
    case <class1> <name1> -> <singleStatement>;

    case <class2> <name2> ->
    {
        <statements>;
    }

    default -> <singleStatement>;
}

// switch statement
var result = switch( selector )
{
    case null -> <expression>;
    case <class1> <name1> -> <expression>;

    case <class2> <name2> ->
    {
        <expressions>;
        yield <value>;
    }

    default -> <expression>;
}
\end{lstlisting}

Same as for \lstinline|default|, \lstinline|case null| can be followed by a statement block or a complex expression.

And an expression can also be always a \lstinline|throw|.

\subsubsection{General Rules for switch}
Every \lstinline|switch| statement should include a \lstinline|default| case, even when the cases are exhaustive.

If really all values are covered, the \lstinline|default| should throw an exception about an unknown value.\footnote{Refer to chapter \ref{sec:UnsupportedEnumError} for a sample.}

Syntactically, the use of curly braces in the cases is optional, even for multi-line statements, but here it is set as mandatory. One reason is that it allows to declare additional variables for a given branch that are local to the given branch.

\subsection{for Statements}
A \lstinline|for| statement should have one of the following forms:

\begin{lstlisting}[numbers=left]
// Classic for loop:
for( <initialization>; <condition>; <update> )
{
    <statements>;
}
for( <initialization>; <condition>; <update> ) <singleStatement>;

// Enhanced for loop:
for( <declaration> : <iterable> )
{
    <statements>;
}
for( <declaration> : <iterable> ) <singleStatement>;
\end{lstlisting}

This means that curly braces have to be used in any case when more than one statement has to be executed in the loop. In addition, this single statement has to be written completely into the same line as the \lstinline|for| itself. 

Examples:
\begin{lstlisting}[numbers=left]
// Ok
for( var i = 0; i < max; ++i ) sum += i;
for( final var s : texts ) System.out.println( s );

// DISCOURAGED
for( var i = 0; i < max; ++i ) if( v [i] > 0 ) sum += v [i];
for( final var s : texts ) if( !s.empty() ) out.println( s );

// AVOID!!!
for( var i = 0; i < max; ++i ) if( v [i] > 0 )
{
    sum += v [i];
}
else
{
    sum -= v [i];
}

for( final var s : texts ) if( !s.empty() )
{
    System.out.print( "Value: " );
    System.out.println( s );
}
\end{lstlisting}
The sample in lines~6 and 7 are correct according to this rule, but as said in comment above them, their use is discouraged and therefore should be avoided, too.

An empty \lstinline|for|-loop (one in which all the work is done in the initialization, condition, and update clauses) should have the following form:\footnote{An \textit{enhanced} \lstinline|for|-loop without body does not make that much sense (that mentioned above is a classical \lstinline|for|-loop). It may be possible to write an implementation of \lstinline|java.lang.Iterable| with an iterator that does something as a side effect of \lstinline|hasNext()| or \lstinline|next()|, but this would break the contract of the interface \lstinline|java.lang.Iterator|.}

\begin{lstlisting}
for( <initialization>; <condition>; <update> );
\end{lstlisting}

When using the comma operator in the initialization or update clause of a \lstinline|for| statement, avoid the complexity of using more than three variables. If needed, use separate statements before the \lstinline|for|-loop (for the initialization clause) or at the end of the loop (for the update clause).

\subsection{while Statements}\label{sec:WhileStatements}
A \lstinline|while| statement should have one of the following forms:
\begin{lstlisting}[numbers=left]
while( <condition> ) <singleStatement>

while( <condition> )
{
    <statements>;
}
\end{lstlisting}

Again, the curly braces can only be omitted in case there is only a single statement, written on the same line than the \lstinline|while| statement, that has to be executed in the loop.

An empty \lstinline|while|-loop\footnote{An empty \lstinline|while|-loop usually makes no sense as the compiler optimises it away. Only when the condition causes side effects, it will be executed. But such an implementation is difficult to understand and should be avoided.} should have the following form: 
\begin{lstlisting}
while( <condition> );
\end{lstlisting}

Longer \lstinline|while|-loops should use a label:
\begin{lstlisting}
LoopLabel: while( proceed )
{
    // Lots of code lines here …
}   //  LoopLabel:
\end{lstlisting}

\subsection{do-while Statements}
A \lstinline|do-while| statement should look like below:
\begin{lstlisting}
do
{
    <statements>;
}
while( <condition> );
\end{lstlisting}

\subsection{try-catch Statements}
Basically, there are two different forms of \lstinline|try-catch| statements: the simple one and the \lstinline|try-with-resources| that was introduced with Java~7 (also refer to chapter \vref{sec:TryWithResources}).

\subsubsection{The simple Form}
A simple \lstinline|try-catch| statement has the following format:
\begin{lstlisting}
try
{
    <statements>;
}
catch( <ExceptionClass> e )
{
    <statements>;
}
\end{lstlisting}

\subsubsection{try-with-resources}
A \lstinline|try-with-resources| allows to allocate resources that will be automatically released when the \lstinline|try| block is left. Something similar could be achieved also by adding a \lstinline|finally| block, but \lstinline|try-with-resources| is easier and more secure.

If looks like this:

\begin{lstlisting}[numbers=left]
try( final var resource = new <ResourceClass>() )
{
    <statements>;
}

final var resource = new <ResourceClass>();
try( final var r = resource )
{
    <statements>;
}
\end{lstlisting}

\lstinline|<ResourceClass>| must implement \lstinline|java.lang.Autocloseable|.

It is possible to allocate more than one resource in a single \lstinline|try| statement:
\begin{lstlisting}
try
( 
    final var resource1 = new <ResourceClass1>(); 
    final var resource2 = new <ResourceClass2>() 
)
{
    <statements>;
}
\end{lstlisting}

A \lstinline|catch| block is optional for \lstinline|try-with-resources|.

\subsubsection{General Rules for try-catch}
In case the \lstinline|try| block can issue more than one exception type, these can be combined into one \lstinline|catch| block, like this:
\begin{lstlisting}
…
catch( <ExceptionClass1> | <ExceptionClass2> e )
{
    <statements>;
}
\end{lstlisting}

if all exceptions are handled by the same set of statements, or like this, when the exceptions are handled by different code blocks:

\begin{lstlisting}
…
catch( <ExceptionClass1> e )
{
    <statements>;
}
catch( <ExceptionClass2> e )
{
    <statements>;
}
\end{lstlisting}

Of course both can be combined:

\begin{lstlisting}
…
catch( <ExceptionClass1> | <ExceptionClass2> e )
{
    <statements>;
}
catch( <ExceptionClass3> e )
{
    <statements>;
}
\end{lstlisting}

Each \lstinline|try-catch| statement can also be followed by a \lstinline|finally| block, which  executes regardless of whether or not the \lstinline|try| block has completed successfully.

\begin{lstlisting}
try
{
    <statements>;
}
catch( <ExceptionClass> e )
{
    <statements>;
}
finally
{
    <statements>;
}
\end{lstlisting}

In case a \lstinline|finally| block is present, the \lstinline|catch| block is optional even for a simple \lstinline|try-catch| statement, meaning that no exception is caught:
\begin{lstlisting}
try
{
    <statements>;
}
finally
{
    <statements>;
}
\end{lstlisting}

An \textit{empty} \lstinline|catch| block is unacceptable under all circumstances! Refer to chapter \vref{sec:GeneralExceptionHandling} how to handle exceptions. See also chapter \vref{sec:SingleLineComments} about empty blocks and comments.

An empty \lstinline|finally| block is completely obsolete and must be removed.


\chapter{-------------------------------------------- Proceed from here!}



\subsection{Labels and break Statements}\label{sec:LabelsAndBreakStatements}
Using the break statement outside the context of a switch statement is usually discouraged, but in many cases it makes the logic of an algorithm easier and more understandable.
We recommend to use always a meaningful label together with break. This would make it more obvious what is intended with the break, and it assures that the right block will be terminated. The label can also be used as the end comment for a code block, as described in chapter “4.2.4 Trailing or End-Of-Line Comments” and “4.4 Comments when?”.
Some samples:
// BAD!!!
for( int line = 0; line < maxLines; ++line )
{
    for( int column = 0; column < maxColumns; ++column )
    {
        if( !isValid( field [line] [column] ) break; // What??
        …
    }

    processLine( field [line] );
}
// RECOMMENDED
LineLoop: for( int line = 0; line < maxLines; ++line )
{
    ColumnLoop: for( int column = 0; column < maxColumns; ++column )
    {
        if( !isValid( field [line] [column] ) break ColumnLoop;
        …
    } //  ColumnLoop:
    processLine( field [line] );
} // LineLoop:
// RECOMMENDED
DirectionSwitch: switch( direction )
{
    case LEFT: goLeft(); break DirectionSwitch;
    case RIGHT: goRight(); break DirectionSwitch;
    default:
        throw new IllegalArgumentException( direction.toString() );
} //  DirectionSwitch:

\chapter{Naming Conventions}

\section{Modules}

\section{Packages}\label{sec:Packages}

\section{Fields}\label{sec:Fields}

\chapter{Writing proper Comments}\label{sec:WritingProperComments}

\section{Implementation Comment Formats}

\subsection{Structuring Comments}\label{sec:StructuringComments}
These are the easiest comments: they are used to separate the sections or parts of a class (as defined in chapter \vref{sec:ClassAndInterfaceDeclarations}) from each other. They have the form
\begin{lstlisting}
    /*------------------*\
====** Enum Declaration **===========================================
    \*------------------*/
    /*---------------*\
====** Inner Classes **==============================================
    \*---------------*/
    /*-----------*\
====** Constants **==================================================
    \*-----------*/
    /*------------*\
====** Attributes **=================================================
    \*------------*/
    /*------------------------*\
====** Static Initialisations **=====================================
    \*------------------------*/
    /*--------------*\
====** Constructors **===============================================
    \*--------------*/
    /*---------*\
====** Methods **====================================================
    \*---------*/
\end{lstlisting}

with the lines ending at column 80 (the samples here are too short).

If a class or interface does not have a particular section or part, the assigned structuring comment must be omitted.

I recommend to create “Building Blocks” with these comments. Eclipse provides the Snippet facility for this purpose\footnote{Storing the comments as code templates is not recommended as a template would be reformatted on insert.}. Refer to chapter \vref{sec:SnippetStructuringComments} for the snippet code for the structuring comments.

\subsection{Single-Line Comments}\label{sec:SingleLineComments}

\subsection{Trailing or End-Of-Line Comments}\label{sec:TrailingOrEndOfLineComments}

\section{Comments when?}\label{sec:CommentsWhen}

\chapter{Coding Rules}\label{sec:CodingRules}

\section{Exceptions}

\subsection{General Exception Handling}\label{sec:GeneralExceptionHandling}

\section{Returning Values}\label{sec:ReturningValues}

\section{The Ternary Operator “?”}\label{sec:TheTernaryOperator}

\section{try-with-resources}\label{sec:TryWithResources}

The feature \lstinline|try-with-resources| was introduced with Java~7; it can help to make programs more stable and less error prone.

\subsection{Basics}
Basically, \lstinline|try-with-resources| is an extension of the previously existing \lstinline|try-catch-finally| feature.

Instead of writing
\begin{lstlisting}[numbers=left]
InputStream input = null;
try
{
    input = new FileInputStream( file );
    …
}
catch( final IOException e )
{
    // Handle the error
}
finally
{
    try
    {
        if( input != null ) input.close();
    }
    catch( final IOException e )
    {
        // Handle the error
    }
}
\end{lstlisting}

the new feature allows you to write

\begin{lstlisting}[numbers=left]
try( final var input = new FileInputStream( file ); )
{
    …
}
catch( final IOException e )
{
    // Handle the error
}
\end{lstlisting}

It works because the interface \lstinline|java.lang.AutoCloseable|\footnote{In fact, \lstinline|InputStream| will still implement just \lstinline|java.io.Closeable|, as already before Java~7, but this interface will now extend the new interface \lstinline|java.lang.AutoCloseable|.} is implemented by the class \lstinline|java.io.InputStream|. For details refer to \autocite{ORACLE_DOC_AUTOCLOSEABLE_INTERFACE}.

This interface defines just one method, \lstinline|close()|, that declares to throw an exception of type \lstinline|java.lang.Exception|.

\lstinline|close()| is called automatically on all instances of \lstinline|AutoClosable| that were declared and defined in the ‘arguments list’ of the new \lstinline|try| when the scope of the \lstinline|try| block is left. If there is more than one resource defined, the sequence is reversed to that of the definition: the last assigned resource will be closed first.

So a code snippet to copy data from an input stream to an output stream may look like this\footnote{This is obviously not a very good implementation, but it illustrates how to use \lstinline|try-with-resources| quite well.}:
\begin{lstlisting}[numbers=left]
try
( 
    InputStream input = new FileInputStream( infile );
    OutputStream output = new FileOutputStream( outfile ) 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
\end{lstlisting}
Both streams will be closed properly in case of a problem or the work is done.

\subsection{Error Handling}
What will happen if the code in the \lstinline|try| block throws an exception and closing the resource will throw one, too?

For the ‘traditional’ pattern this could mean that the first exception would be ‘supplanted’ by the exception from the close. For sure, in a \lstinline|catch| block the original cause could be logged, but usually only checked exceptions (and “expected“ ones) are covered this way.

Together with \lstinline|try-with-resources|, a new feature was introduced to the language: the \textit{suppressed} exception. This deals with the problem described above.

So if the \lstinline|try| block throws an exception (for our example, it would be most probably an \lstinline|IOException|) and the \lstinline|AutoCloseable.close()| will fail with an exception, too, the latter one will be added to the first one as a “suppressed exception” by the JVM.

For this purpose, the API of the class \lstinline|java.lang.Throwable| was extended by the methods \lstinline|addSuppressed()| and \lstinline|getSuppressed()|.\footnote{see \autocite{ORACLE_DOC_THROWABLE_CLASS}}

Using \lstinline|Throwable.printStackTrace()| an output like that below will be produced:
\begin{lstlisting}
java.lang.Error
  at TryWithResources.main(TryWithResources.java:175)
  Suppressed: java.lang.Exception
    at TryWithResources$Resource2.close(TryWithResources.java:103)
    at TryWithResources.main(TryWithResources.java:176)
\end{lstlisting}

\subsection{Execution Sequence}\label{sec:ExecutionSequence}
It is important to know how the execution sequence looks like when using \lstinline|try-with-resources|. For the traditional pattern it is\\
\begin{center}
\verb#try{}->[catch{}]->finally{}#
\end{center} 
for \lstinline|try-with-resources| it will be\\ 
\begin{center}
\verb#try{}->AutoCloseable.close()->[catch{}]->[finally{}]#
\end{center}

This means that the method \lstinline|close()| on the \lstinline|AutoClosable| objects will be called \textit{before} any code in an optional \lstinline|catch| and/or \lstinline|finally| block that is attached to the \lstinline|try| block. For the sample we used above this means that the \lstinline|InputStream input| is already closed when the code in the \lstinline|catch| block that handles the \lstinline|IOException| will be executed.

Therefore the code below will not work as expected in case an exception is thrown in the \lstinline|try| block:
\begin{lstlisting}
// WILL NOT WORK!
final var logStream = new FileOutputStream( logfile )
try
(   
    final var input = new FileInputStream( infile );
    final var output = new FileOutputStream( outfile );
    final var log = logStream 
)
{
	int value = EOF;
	
    //---* Read the input, write to the output *---------------------
    while( (value = input.read()) != EOF )
    {
        output.write( value );
    }
}
catch( final IOException e )
{
    logStream.write( "Copy failed!\n".getBytes( UTF8 ) );
    /* Fails because the log file is already closed! */
}
\end{lstlisting}

\subsection{When to use?}
\lstinline|try-with-resources| is a very powerful feature that should be used whenever possible. Definitively it should be used with all the Java classes that already implement \lstinline|java.lang.AutoCloseable| or \lstinline|java.io.Closeable|:

\begin{itemize}
\item{The \lstinline|java.io| streams}
\item{Sockets}
\item{\lstinline|java.sql.Connection|, \lstinline|java.sql.Statement|, \lstinline|java.sql.ResultSet|}
\item{\lstinline|java.jms.Connection|}
\end{itemize}

\subsubsection{Lifecycle}
In C++, it is a very common pattern to “wrap” the lifecycle of a resource into the lifecycle of an object:
\begin{lstlisting}[language=c++]
class Resource
{
    //---* Attributes *----------------------------------------------
    private:
        RTYPE m_Res;

    //---* Constructors *--------------------------------------------
    public:
        Resource( RTYPE &r )
        : m_Res( r )
        { m_Res.open(); }

    //---* Destructor *----------------------------------------------
    public:
        ~Resource() { m_Res.close(); }

    //---* Methods *-------------------------------------------------
    // Some methods to access the resource
    …
}
\end{lstlisting}
A use of that class might look like this:
\begin{lstlisting}[language=c++]
…
{
    Resource resource( r );

    // Do something
    …
}
…
\end{lstlisting}
The instance of \lstinline|Resource| will be constructed and \lstinline|open()| is called on \lstinline|r| on the declaration of the variable \lstinline|resource|. On leaving the scope the destructor of \lstinline|Resource| is called implicitly and \lstinline|close()| will be called on \lstinline|r|.

The C++~STL is using a very similar pattern for smart pointers.

Unfortunately, Java does not know destructors\footnote{The deprecated method \lstinline|java.lang.Object.finalizer()| that is part of each Java class is not and was never a replacement for or an alternative to a destructor as it could never be predicted when it is called (just “sometime before the JVM terminates” – if ever).}, so this pattern could not be used.

A workaround is to use a \lstinline|try-finally| block with the cleanup (usually a call to \lstinline|close()|) in the \lstinline|finally| block. But to often we have seen that in the run of modifications and/or corrections (refactorings) suddenly the \lstinline|finally| block and/or its contents had been removed (“optimised away”).

Now, with the \lstinline|try-with-resources| feature, we can have “Lifecycle” classes; they are still not that easy to use that with real destructors, but we can come close.

A sample would be the Class \lstinline|AutoLock|; for the full code, see chapter \vref{sec:AutoLock}; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

In programs that use \lstinline|java.util.concurrent.locks.Lock| or one of its implementations for thread synchronisation, you will find quite often code like this:
\begin{lstlisting}[numbers=left]
m_Lock.lock();
try
{
    // Do something
    …
}
finally { m_Lock.unlock(); }
\end{lstlisting}

This calls for a lifecycle class. Unfortunately the code below will not work, due to several reasons:
\begin{lstlisting}[numbers=left]
// Does not work!!
try( final var unused = new Lock() )
{
    // Do something
    …
}
\end{lstlisting}

First, \lstinline|java.util.concurrent.locks.Lock| will not implement \lstinline|java.lang.AutoCloseable|, and second – much more important – we cannot create a new instance of Lock each time we enter the critical section.\footnote{… not to mention that \lstinline|java.util.concurrent.locks.Lock| is an interface so that \lstinline|new Lock()| cannot work at all.}

Fortunately, the \lstinline|try-with-resources| feature will not call \lstinline|close()| on the newly created object, but on the local reference (that is the reason why \lstinline|try-with-resources| will not work with anonymous instances like \lstinline|try( new Lock() )|). If we would now wrap the \lstinline|Lock| instance into a class that implements \lstinline|AutoCloseable|, we can write something like this:
\begin{lstlisting}[numbers=left]
…
AutoLock m_AutoLock = new AutoLock( m_Lock );
…
try( final var unused = m_AutoLock.lock() )
{
    // Do something
    …
}
\end{lstlisting}

\subsubsection{Post-Processing}
Together with lambdas, \lstinline|try-with-resources| can be (ab)used also to enforce a unconditional post-processing when a code block is left. This may look like this:
\begin{lstlisting}[numbers=left]
…
Runnable doAfter = …;
…
try( final var p = new PostProcessor( doAfter ) )
{
    // Do whatever necessary
    …
}
\end{lstlisting}
The \lstinline|PostProcessor| instance will call \lstinline|Runnable::run| in its \lstinline|close()| method when the \lstinline|try| block is left. Chapter \ref{sec:PostProcessor} in the Appendices provides the source for the class.

‘Unconditional’ means here that the post-processing will be executed if the block terminates regularly or by a thrown exception. Other conditions can be injected into the \lstinline|Runnable| implementation.

The difference between this approach and simply calling \lstinline|doAfter.run()| in a \lstinline|finally| block is that the \lstinline|close()| method of \lstinline|PostProcessor| is invoked before any code in a \lstinline|catch| block (refer to chapter \ref{sec:ExecutionSequence}).

A real-life example where this is useful could be the following:
\begin{lstlisting}[numbers=left]
final var builder = new StringBuilder();

Runnable addTrailer = () -> builder.append( "}\n" );

…

try( final var p = new PostProcessor( addTrailer ) )
{
    …
}
\end{lstlisting}
This ensures that the string in \lstinline|builder| always terminates with a closing curly brace followed by a linefeed.

\chapter{Appendices}

\section{IDE Configuration}\label{sec:IDEConfiguration}
This chapter provides samples of configuration files for some IDEs.

\subsection{Eclipse}\label{sec:EclipseConfiguration}
tbd
\subsubsection{Snippets}
This chapter provides the XML code for Eclipse snippets.

\paragraph{Structuring Comments}\label{sec:SnippetStructuringComments}
The snippets for the structuring comments as defined in chapter \vref{sec:StructuringComments}.
\begin{lstlisting}[language=xml,basicstyle=\ttfamily\tiny]
<?xml version="1.0"
      encoding="UTF-16" 
      standalone="no"?>
<snippets>
    <category filters="*"
              id="category_1145179107125"
              initial_state="0"
              label="Structuring Comments"
              largeicon=""
              smallicon="">
        <description><![CDATA[Structuring Comments as defined by the Code Conventions]]></description>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145232938375"
              label="Enum Declaration"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the enum definition part]]></description>
            <content><![CDATA[        /*------------------*\
    ====** Enum Definitions **=================================================
        \*------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179869843"
              label="Inner Classes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the inner classes part]]></description>
            <content><![CDATA[        /*---------------*\
    ====** Inner Classes **====================================================
        \*---------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251889697104"
              label="Constants"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for constants.]]></description>
            <content><![CDATA[      /*-----------*\
    ====** Constants **========================================================
        \*-----------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1251888677777"
              label="Attributes"
              largeicon=""
              smallicon="">
            <description><![CDATA[The part comment for attributes.]]></description>
            <content><![CDATA[      /*------------*\
    ====** Attributes **=======================================================
        \*------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145179436656"
              label="Static Initialisations"
              largeicon="" smallicon="">
            <description><![CDATA[The header comment for the static initialisations part]]></description>
            <content><![CDATA[        /*------------------------*\
    ====** Static Initialisations **===========================================
        \*------------------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180117906"
              label="Constructors"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the constructors part]]></description>
            <content><![CDATA[    	/*--------------*\
    ====** Constructors **=====================================================
        \*--------------*/
]]></content>
        </item>
        <item category="category_1145179107125"
              class=""
              editorclass=""
              id="item_1145180168796"
              label="Methods"
              largeicon=""
              smallicon="">
            <description><![CDATA[The header comment for the methods part]]></description>
            <content><![CDATA[    	/*---------*\
    ====** Methods **==========================================================
        \*---------*/
]]></content>
        </item>
    </category>
</snippets>
\end{lstlisting}

\subsection{JetBrains IntelliJ IDEA}\label{sec:IntelliJConfiguration}
tbd

\section{Formatting SQL inside Java}\label{sec:FormattingSQLInsideJava}

\section{Examples}\label{sec:Examples}

\subsection{AutoLock}\label{sec:AutoLock}
This class is a sample implementation of the idea, like a PoC; a real life implementation can be found at \autocite{TQUADRAT_ORG_FOUNDATION_AUTOLOCK}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left]
package org.tquadrat.util.concurrent;

import static java.util.Objects.requireNonNull;
import java.util.concurrent.locks.Lock;

/**
 *  A wrapper for locks that supports the {@code try-with-resources}
 *  feature of Java 7.
 *  The creation of the local reference to the wrapper object means
 *  some overhead but in very most scenarios this is negligible.
 *
 *  {@code AutoLock} will only expose the methods
 *  {@link #lock()}
 *  and
 *  {@link #lockInterruptibly()}
 *  of the interface
 *  {@link java.util.concurrent.locks.Lock Lock},
 *  but with a return value. Exposing other methods is not
 *  reasonable.
 *  Calling
 *  {@link #close()}
 *  on the {@code AutoLock} instance or
 *  {@link Lock#unlock()}
 *  on the wrapped {@code Lock} object inside the {@code try} block
 *  may cause unpredictable effects.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 *
 *  @see java.util.concurrent.locks.Lock
 */
public class AutoLock implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The wrapped lock.
     */
    private final Lock m_Lock;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code AutoLock} object.
     *
     *  @param  lock    The wrapped lock.
     */
    public AutoLock( final Lock lock )
    {
        m_Lock = requireNonNull( lock );
    }   //  AutoLock()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  {@inheritDoc}
     */
    @Override
    public final void close() { m_Lock.unlock(); }

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lock() lock()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     */
    public final AutoLock lock()
    {
        m_Lock.lock();

        //---* Done *------------------------------------------------
        return this;
    }   //  lock()

    /**
     *  Calls
     *  {@link java.util.concurrent.locks.Lock#lockInterruptibly()
     *  lockInterruptibly()}
     *  on the wrapped
     *  {@link java.util.concurrent.locks.Lock}
     *  instance.
     *
     *  @return The reference to this {@code AutoLock} instance.
     *  @throws InterruptedException The current thread was
     *      interrupted while acquiring the lock (and interruption
     *      of lock acquisition is supported).
     */
    public final AutoLock lockInterruptibly() 
        throws InterruptedException
    {
        m_Lock.lockInterruptibly();
        
        //---* Done *------------------------------------------------
        return this;
    }   //  lock()
}
//  class AutoLock
\end{lstlisting}

\subsection{PostProcessor}\label{sec:PostProcessor}
This implementation is basically a PoC; currently it is not part of any library.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left]
package util;

import static java.util.Objects.requireNonNull;

/**
 *  Use this class to implement an uncoditional post-processing
 *  feature utilising try-with-resources.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
public class PostProcessor implements AutoCloseable
{
        /*------------*\
    ====** Attributes **=============================================
        \*------------*/
    /**
     *  The action.
     */
    private final Runnable m_Action;
    
        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new {@code PostProcessor} object.
     *
     *  @param  action  The action that has to executed.
     */
    public PostProcessor( final Runnable action )
    {
        m_Action = requireNonNull( action );
    }   //  PostProcessor()
    
        /*---------*\
    ====** Methods **================================================
        \*---------*/
    /**
     *  Calls the
     *  {@link Runnable#run() run()}
     *  method of the
     *  {@linkplain #m_Action action}.
     *
     *  @see java.lang.AutoCloseable#close()
     */
    @Override
    public void close() throws Exception { m_Action.run(); }
}
//  class PostProcessor
\end{lstlisting}

\subsection{UnsupportedEnumError}\label{sec:UnsupportedEnumError}
This implemenation of \lstinline|java.lang.Error| is meant to be used in the \lstinline|default| branch of a \lstinline|switch| statement (refer to \vref{sec:SwitchStatements}), in cases where the selector is an enum.

It will be used like this:
\begin{lstlisting}[numbers=left]
enum Color
{
    RED, BLUE, GREEN, YELLOW
}

Color color = …    

// Traditional switch statement
switch( color )
{
    case RED: …; break;
    case BLUE: …; break;
    case GREEN: …; break;
    case YELLOW: …; break;

    default: throw new UnsupportedEnumError( color );
}

// New switch statement
switch( color )
{
    case RED -> …;
    case BLUE -> …;
    case GREEN -> …;
    case YELLOW -> …;

    default: throw new UnsupportedEnumError( color );
}

// switch expression
var result = switch( color )
{
    case RED -> "Rot";
    case BLUE ->"Blau";
    case GREEN -> "Grün";
    case YELLOW -> "Gelb";

    default: throw new UnsupportedEnumError( color );
}
\end{lstlisting}

Also refer to \autocite{TQUADRAT_ORG_FOUNDATION_UNSUPPORTEDENUMERROR}.

\paragraph{The Code} \
\begin{lstlisting}[numbers=left]
package org.tquadrat.foundation.exception;

import static org.apiguardian.api.API.Status.STABLE;
import static org.tquadrat.foundation.lang.Objects.requireNonNullArgument;
import static org.tquadrat.foundation.lang.Objects.requireNotEmptyArgument;
import static org.tquadrat.foundation.lang.internal.SharedFormatter.format;

import java.io.Serial;

import org.apiguardian.api.API;

/**
 *  This is a specialized implementation for
 *  {@link Error}
 *  that is to be thrown especially from the {@code default} branch of a
 *  {@code switch} statement that uses an {@code enum} type as selector.
 *
 *  @author Thomas Thrien - thomas.thrien@tquadrat.org
 */
@API( status = STABLE, since = "0.0.5" )
public final class UnsupportedEnumError extends Error
{
        /*-----------*\
    ====** Constants **==============================================
        \*-----------*/
    /**
     *  The message text.
     */
    private static final String MSG_UnsupportedEnum = "The value '%2$s' of enum class '%1$s' is not supported";

        /*------------------------*\
    ====** Static Initialisations **=================================
        \*------------------------*/
    /**
     *  The serial version UID for objects of this class: {@value}.
     *
     *  @hidden
     */
    @Serial
    private static final long serialVersionUID = 1174360235354917591L;

        /*--------------*\
    ====** Constructors **===========================================
        \*--------------*/
    /**
     *  Creates a new instance of this class.
     *
     *  @param <T>  The type of the enum.
     *  @param  value   The unsupported value.
     */
    public <T extends Enum<T>> UnsupportedEnumError( final T value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( value, "value" ).getClass().getName(), value.name() ) );
    }   //  UnsupportedEnumError()

    /**
     *  Creates a new instance of this class.
     *
     *  @param  type    The class of the enum.
     *  @param  value   The unsupported value.
     */
    public UnsupportedEnumError( final Class<? extends Enum<?>> type, final String value )
    {
        super( format( MSG_UnsupportedEnum, requireNonNullArgument( type, "type" ).getName(), requireNotEmptyArgument( value, "value" ) ) );
    }   //  UnsupportedEnumError()
}
//  class UnsupportedEnumError

/*
 *  End of File
 */
 \end{lstlisting}

\printbibliography
\end{document}
